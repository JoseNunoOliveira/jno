\documentclass{elsarticle}
%% Front Matter

% Title
%
\title{
%	Why Adjunctions Matter (Extended Abstract)
	Why Adjunctions Matter --- a Functional Programmer Perspective
}

% Authors
\author[uminho]{Jos\'{e} Nuno Oliveira} %corref{cor1}}
\ead{jno@di.uminho.pt}

%cortext[cor1]{Corresponding author.}

\address[uminho]{
          High Assurance Software Laboratory\\
	 (http://haslab.uminho.pt) \\
          INESC TEC and University of Minho\\
	  Braga, Portugal
}
%----------------------------------------------------------------------------
\date\today
%---------
\newtheorem{theorem}{Theorem} % [section]
\newtheorem{lemma}[theorem]{Lemma} % [section]
\newtheorem{definition}[theorem]{Definition} % [section]
\def\junc#1#2{\mathopen{[} #1,#2 \mathclose{]}}
\long\def\ToDo#1{\par\hskip-6em\noindent\fbox{
\begin{minipage}{1.2\textwidth}
\begin{todobody}#1\end{todobody}
\end{minipage}
}\vskip 1ex}
\newtheorem{todobody}{To-do} % [section]
%-------------------------------------------
\usepackage{xcolor,colortbl}
\newcommand{\one}{\cellcolor{gray!20}1}
%-------------------------------------------
\usepackage{jnoxy}
%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%
%usepackage{jnobasics}
%----------------- tikz -------------------------------------------------------%
\usepackage{tikz}
%----------------- anamorphism's brackets -------------------------------------%
\usepackage{stackengine}

%\newcommand{\lanaparen}{\stackinset{c}{0.01125in}{t}{0in}{\fontsize{5.55}{5.55}\selectfont -}{$[\!($}}

\newcommand{\lanaparen}
{\stackinset{c}{0.001625in}{c}{0.066375in}{\_}{\stackinset{c}{0.001625in}{c}{-0.066375in}{\_}{$[\!($}}}
\newcommand{\ranaparen}{\stackinset{c}{-0.010125in}{c}{0.066375in}{\_}{\stackinset{c}{-0.010125in}{c}{-0.066375in}{\_}{$)\!]$}}}

\def\ana#1{\lanaparen#1\ranaparen\index{Combinador ``pointfree''!\emph{ana}}}
%def\sana#1{\ana{#1}}
%------------------------------
\usepackage{pict2e}
\newcommand{\lbparen}{%
  \mathopen{%
    \sbox0{$()$}%
    \setlength{\unitlength}{\dimexpr\ht0+\dp0}%
    \raisebox{-\dp0}{%
      \begin{picture}(.32,1)
      \linethickness{\fontdimen8\textfont3}
      \roundcap
      \put(0,0){\raisebox{\depth}{$($}}
      \polyline(0.32,0)(0,0)(0,1)(0.32,1)
      \end{picture}%
    }%
  }%
}
\newcommand{\rbparen}{%
  \mathclose{%
    \sbox0{$()$}%
    \setlength{\unitlength}{\dimexpr\ht0+\dp0}%
    \raisebox{-\dp0}{%
      \begin{picture}(.32,1)
      \linethickness{\fontdimen8\textfont3}
      \roundcap
      \put(-0.08,0){\raisebox{\depth}{$)$}}
      \polyline(0,0)(0.32,0)(0.32,1)(0,1)
      \end{picture}%
    }%
  }%
}
%------------------------------
\def\myxym#1{\vcenter{\xymatrix{#1}}}
\def\arrayin#1{\begin{array}{rcl}#1\end{array}}
\def\xarrayin#1{\begin{array}{ccccccc}#1\end{array}}
\def\yarrayin#1{$\begin{array}{ccccccc}#1\end{array}$}
\def\sse{\subseteq}
\newenvironment{lcbr}{\left\{\begin{array}{l}}{\end{array}\right.}
\def\fix#1#2{\rcb\mu{#1}{}{#2}}
\def\unary#1#2{\def\arg{#2}\def\omisso{}\ifx\arg\omisso{\mathit{#1}}\else\ap{\mathit{#1}}{#2}\fi}
\def\curried#1#2#3{
	\def\argA{#2}\def\argB{#3}\def\omisso{}
	\ifx\argA\omisso{
		\ifx\argB\omisso #1
                \else\ap{#1}{#2}
                \fi}
        \else #1\ #2\ #3
        \fi
}
\def\rng#1{\unary{\rho}{#1}}
\def\LNCS{LNCS\index{LNCS!\uk{Lecture Notes in Computer Science}}}
\def\N{\mathbb{N}\index{Números naturais ($I\!\!N$)}}
\def\R{\mathbb{R}\index{Números reais ($I\!\!R$)}}
\def\B{\mathbb{B}\index{Booleans}}
\def\alt#1#2{\mathopen{[}#1\hskip 1pt,#2\mathclose{]}}
\def\ap#1#2{#1\,#2}
\def\arrayin#1{\begin{array}{rcl}#1\end{array}}
\def\bang{{!}}
\def\cjust#1#2{\just{#1}{~\longldots~}}
\def\comp{ \mathbin{\cdot} }
\def\conv#1{#1^\circ}
\def\deff{\stackrel{\mathrm{def}}{=}}          % Function definition symbol
\def\eqnnewpage{\end{eqnarray*}\newpage~\vskip-2em\begin{eqnarray*}&& }
\def\esp{~\\}
\def\ff#1{\ap\f{#1}}
\def\fun#1{\mathsf{#1}}
\def\f{\fun F}
\def\from{\mathbin{\leftarrow}}
\def\implied{\mathbin\Leftarrow}
\def\just#1#2{\\ &#1& \rule{2em}{0pt} \{ \mbox{\rule[-.7em]{0pt}{1.8em} \small #2 \/} \} \nonumber\\ && }
\def\mcond#1#2#3{#1 \rightarrow #2\;,\;#3}
\def\p#1{\pi_{#1}}
\def\qed{\\&\Box&\nonumber}
\def\rcb#1#2#3#4{\def\nothing{}\def\range{#3}\mathopen{\langle}#1 \ #2 \ \ifx\range\nothing::\else: \ #3 :\fi \ #4\mathclose{\rangle}}
\def\scata#1{\llparenthesis\, #1 \,\rrparenthesis}
\def\catajunc#1#2{\llparenthesis\, #1,#2 \,\rrparenthesis} % scata . altx
\def\shrunkby{\mathbin{\upharpoonright}}
\def\wider#1{~ #1 ~}
\def\etaT{\eta_{\fun T}}
\def\etaF{\eta_{\fun F}}
\def\etaV{\eta_{\fun V}}
\def\etaG{\eta_{\fun G}}
\def\etaS{\eta_{\fun S}}
\def\etaM{\eta_{\fun M}}
\def\muM{\mu_{\fun M}}
\def\etam#1{\eta_{\fun #1}}
\def\mum#1{\mu_{\fun #1}}
\def\mmm#1#2#3#4{\xymatrix{%--- MMM, labelled by state
	#2
		\ar[r]^{#3}_{\mbox{\tiny$#1$}}
&
	#4
}}
\def\muK{\mu_{\fun K}}
\def\muF{\mu_{\fun F}}
\def\muG{\mu_{\fun G}}
\def\muH{\mu_{\fun H}}
\def\muT{\mu_{\fun T}}
\def\vgcc#1#2#3#4{\xymatrix@R=2ex{
	#3
		\ar@/_1pc/[dd]_{#2}
\\
	\dashv
\\
	 #1
		\ar@/_1pc/[uu]_{#4}
}}
\def\gcc#1#2#3#4{\xymatrix@R=0.5ex@C=1em{
	#1
		\ar@/^1pc/[rr]^{#4}
&
	\top
&
	#3
		\ar@/^1pc/[ll]^{#2}
}}
\def\lift#1{\stackrel.{#1}}
%%%% ----alcino -----
%%format <= = "\Leftarrow"
%%format <=> = "~\Leftrightarrow~"

%%format inl = "\mathsf{inl}"
%%format inl = "{\in}"
%%format inl = "i_1"
%%format coswap   = "\mathsf s_+"
\def\true{\hbox{\textsc{True}}}
\def\false{\hbox{\textsc{False}}}
%%format reverse = "\mathsf{reverse}"

%%%%% ---- jno --------

%%format ana x = "\mathopen{[\!(}" x "\mathclose{)\!]}"
%%format anaNat (x) = "\mathopen{[\!(}" x "\mathclose{)\!]}"
%%format (ana (x)) = "\sana{" x "}"
\def\conj#1#2{\mathopen{\langle} #1, #2 \mathclose{\rangle}}
\def\crflx#1{\Phi_{#1}}
\def\iso{\cong}
\let\kons=\underline
\def\wlp#1#2{#1 \mathbin{\setminus\hskip-1.1ex\bullet} #2}
\def\ker#1{\mathrm{ker}\;#1}
\def\img#1{\mathrm{img}\;#1}
\def\kcomp{\mathbin{\bullet}}
%%format inL = "{\in}"
\def\for#1#2{\mathsf{for} \ #1 \ #2}
\def\foldr#1#2{\mathsf{foldr} \ #1 \ #2}
\def\foldl#1#2{\mathsf{foldl} \ #1 \ #2}
%folmat (foldl (f) (i)) = "\foldl{" f "}{" i "}"
\def\rdiv{\mathbin{\setminus}}
\def\ldiv{\mathbin{/}}
%%format scl a = "{" a "}^{\sigma}"
%%format Bool  = "\B "
%%format delta = "\delta"
%%format delta' = "\delta\prime "
%%format (grd p) = "{" p "}?"
%%format (grd p) = "{" p "}?"
%%format bang = "{!}"
%%format bang' = "{!''}"
%%format ! = "\bang"
%%format bang = "\bang"
%%format (iplus (a) (b)) = "{" a "}\plus{" b "}"
%%format rec (x) = "\f" x
%%format ++ = "\mathbin{+\!\!+}"
%%format Left = "i_1"
%%format Right = "i_2"
%%format ana t (f) = "\ana{" f "}"
%%format const (x) = "\kons{" x "}"
%%format fst = "\p1"
%%format i1 = "i_1"
%%format i2 = "i_2"
%%format id = "{id}"
%%format inl = "i_1"
%%format inr = "i_2"
%%format LTree = "\mathsf{LTree}"
%%format inLTree = "\mathsf{in}"
%%format map = "\mathsf{map}"
%%format mapT = "\mathsf{T}"
%%format mu = "\mu"
%%format myconst = "\mathsf{const}"
%%format outG = "\mathsf{out}_G"
%%format lms = "\mathsf{lms}"
%%format inl a = "\mathsf{in}"
%%format p1  = "\p1"
%%format p2  = "\p2"
%%format snd = "\p2"
%%format curry x = "\trans{" x "}"
%%format curry (x) = "\trans{" x "}"
%%format _curry f = "\mathsf{curry}\ " f
%%format succ = "\mathsf{succ}"
%%format Lms = "\mathsf{Lms}"
%%format i11 = "\mathit{i}_{11}"
%%format i22 = "\mathit{i}_{22}"
%%format larrow (a) (f) (b) = "\larrow{" a "}{" f "}{" b "}"
%%format (div a b) = "{" a "}\div{" b "}"
%%format bot = "\bot "
%%format Bool = "\mathbb B "
\def\klei#1{\overline{#1}}
%%format (sq (x)) = "{" x "}^2"
%%format delta = "\Delta "
%%format eta = "\eta "
%%format forall = "\forall "
%%format larrow (a) (f) (b) = "\larrow{" a "}{" f "}{" b "}"
%%format apM b m a = m "(" b "," a ")"
%%format enset (t) = "\enset{" t "}"
%%format m1 = " m_1 "
%%format m2 = " m_2 "
%%format undr = "\conv{\mathsf{dr}}"
%%format tot f p = f "~\implied ~" p " "
%%format (rcb q (v) (r) (t)) = "\rcb{" q "}{" v "}{" r "}{" t "}"
%%format (either (a) (b)) = "[" a "," b "]"
%%%format (either a b) = "\alt{" a "}{" b "}"
%%format (mean (f)) = "\mean{" f "}"
%%format (ceiling (f)) = "\mean{" f "}"
%%format (mblock (a) (b) (c) (d)) = "\mblock{" a "}{" b "}{" c "}{" d "}"
%%format (pcata f)   = "\scata{" f "}"
%%format ++ = "\mbox{+\hskip-1ex+}"
%%format ++* = "\mbox{+\,+}"
%%format .! = "\kcomp"
%%format kcomp f g = f "\kcomp " g
%%format .!. = "\kcomp_D"
%%format .!! = "\mathbin\odot"
%%format .* = "\times"
%%format .** = "\times"
%%format .*** = "\times"
%%format :||: = "\mathbin{\#}"
%%format union (a) (b) = a "\cup " b
%%%format == = "\mbox{=}"
%%format >< = "\mathbin{\mbox{$>$\hskip-1.7pt$<$}}"
%%format Cp.cond p a b = "\mcond{" p "}{" a "}{" b "}"
%%format condc p a b = "\mcond{" p "}{" a "}{" b "}"
%%format Dist = "\fun D "
%%format Pow = "\fun P "
%%format LT   = "\fun L "
%%format fmapF = "\fun F "
%%format fmapT = "\fun T "
%%format HEither (a) (b) = "Either\ " a "\ " b
%%format Left = "i_1 "
%%format Left = "i_1"
%%format Maybe = "\fun M "
%%format bb    = "\fun B "
%%format ffbb    = "\fun F_{\fun B} "
%%format Nil = "1"
%%format ProbRep = "\mathsf P "
%%format Right = "i_2 "
%%format assocl = "\conv{" assocr "}"
%%format assocr = "\mathsf{a}"
%%format cata (f)   = "\scata{" f "}"
%%format coassocr = "\mathsf a_+"
%%%format curry f = "\trans{" f "}"
%%format dr = "\mathsf{dr}"
%%format eplus a b = "{" a "}\boxplus{" b "}"
%%format eplusD a b = "{" a "}\boxplus_D{" b "}"
%%format ff = "\fun F "
%%format ffmap = "\fun F "
%%format fmapM = "\fun M "
%%format fmapn = "\fun M_F"
%%format i1   = "i_1"
%%format i2    = "i_2"
%%format kkr a b = "{" a "}\kkr{" b "}"
%%format lstr = "\tau_l "
%%format hlstr = "\tau_l^D "
%%format hrstr = "\tau_r^D "
%%format mapD = "\fun D "
%%format mapDM = "\fun D \fun M "
%%format mfibl' = " fib "
%%format mfold = "\mathbf{fold}"
%%format mfor = "\mathbf{for}"
%%format msql = " sq "
%%format mult = "\mu"
%%format mu = "\mu"
%%format multDM = "\mu_{\fun D\fun M}"
%%format p1 = "\p 1"
%%format p2 = "\p 2"
%%format pfeedb p = p "^\Lsh\ "
%%format pcomp (p) (q) = p "\comp " q
%%format seqcD (p) (q) = p "\mathbin{\textbf;_D}" q
%%format phi = "\phi"
%%format pkr (a) (b) = "{" a "}\kr{" b "}"
%%format pmeither (a) (b) = "[" a "|" b "]"
%%format potimes (m) (n) = m "\otimes " n
%%format power n m = "{" n "}^{" m "}"
%%format return = "\eta "
%%format rstr = "\tau_r "
%%format succ = " \succ "
%%format sum2 p q = p "\oplus" q
%%format sum3 p q r = p "\oplus" q "\oplus" r
%%format sum4 p q r s = p "\oplus" q "\oplus" r "\oplus" s
%%format unzipF = " unzip_{\fun F}"
%%format wrap p f g = "{" p "}_{\{" f "\mathbin\to " g "\}}"
%%format xl = "\mathsf{xl}"
%%format lft = "\mathsf{lft}"
%%format rgt = "\mathsf{rgt}"
%%format klPow (r) = "\mean{" r "}"
%%format klDist (d) = "\mean{" d "}"
%%format xr = "\mathsf{xr}"
%%format cozip = "\vartriangle"
%%format cozip = "\Delta"
%%%--Alloy
\def\msplit#1#2{\left[\begin{array}{c}#1\\\hline#2\end{array}\right]} % Split
\def\meither#1#2{\left[\begin{array}{c|c}{#1}&{#2}\end{array}\right]} % either
\def\flt#1{{#1}^\flat}
\def\shp#1{{#1}^\sharp}
%%format (shp (x))  = "{" x "}^{\#}"
%%format cat c = "\cat{" c "}"
\def\cat#1{{\mathfrak #1}}
%%format (syq (r)(s)) = r " \mathbin{\chi}" s
\def\vect#1{\mathsf{vec}\, #1}              % vec A
%def\vectk#1#2{\mathsf{vec}_{#1}\, #2}              % vec A
\def\vectk#1#2{\lceil #2 \rceil_{#1}}
%def\unvectk#1#2{\textbf{unvec}_{#1}\, #2}              % vec A
\def\unvectk#1#2{{\lfloor #2 \rfloor}_{#1}}
%def\kr{\mathbin{\smalltriangledown}}
\def\kr{\mathbin{\hbox{\tiny${}^\triangledown$}}}
\def\Kr{\triangledown}
\def\ip#1#2{\mathopen{\langle}#1|#2\mathclose{\rangle}}
\def\matrix#1#2#3#4{\begin{bmatrix}#1&#2\\#3&#4\end{bmatrix}}
\def\aspas#1{``#1''}
\def\EXIT{ \bibliographystyle{plain} \bibliography{/Users/jno/share/texinputs/jno} \end{document}}
\def\choice#1{\mathbin{_{#1}\diamond}}
%%-------------
\def\supp#1{\mathopen{\lfloor}#1\mathclose{\rfloor}}
%%-------------
\def\start{&&}
\def\more{\\&&}
\def\emskip{\vskip 1em\noindent }
%%------------------------
\def\plus{\mathbin{\dagger}}
\def\ket#1{|#1\rangle }	
\def\implies{\mathbin{\Rightarrow}}
\def\cell#1#2#3{#1\ #2\ #3}
\def\simplediag#1#2#3#4#5#6#7#8{\xymatrix@C=0.9em@R=0.9em{ #1 \ar[dd]_{#5} & & #2 \ar[ll]_{#6} \ar[dd]^{#7} \\ & \subseteq \\ #4 & & #3 \ar[ll]^{#8} }}
\newenvironment{beqnarray}{\blue\vspace*{-1ex}\begin{eqnarray}}{\end{eqnarray}\black\vspace*{-1ex}\hskip-1pt\vskip-0.9em\relax}
\newenvironment{beqnarray*}{\blue\vspace*{-1ex}\begin{eqnarray*}}{\end{eqnarray*}\black\vspace*{-1ex}\hskip-1pt\vskip-0.9em\relax}
%%format rR "{R}"
%%format vP "P "
%%format vQ "Q "
%%format vG "G "
%%format simeq (m) (n) = m "\wider\simeq " n
\def\cospan#1#2#3#4#5{ \xymatrix{ #1 \ar[r]^{#2} & #3 & #5 \ar[l]_-{#4} } }
\def\myspan#1#2#3#4#5{ \xymatrix{ #1 & #3 \ar[l]_{#2} \ar[r]^-{#4} & #5 } }
\def\arIso#1#2#3#4{\arLaw{#1}{#2}{#3}{#4}\iso}
\def\arLaw#1#2#3#4#5{
\xymatrix{
        #1      \ar@/^1pc/[rr]^-{#4} &
        #5 &
        #2      \ar@/^1pc/[ll]^-{#3}
}}
\def\chatGPT{\href{https://openai.com/blog/chatgpt/}{\textsc{chatGPT}}}
\def\rcbnb#1#2#3#4{\def\nothing{}\def\range{#3}#1 \ #2 \ \ifx\range\nothing::\else: \ #3 :\fi \ #4}
%---- exceptions -----
%---- other ----------
\def\kr{\mathbin{\hbox{\tiny${}^\vartriangle$}}}
\def\Kr{\vartriangle}
\def\thinnedby{\mathbin{\downharpoonleft}}
%----------------------------------------------------------------------------
\usepackage{fleqn}
\usepackage[utf8x]{inputenc}
\usepackage{wrapfig}
%------ using amssymb,amsmath -----------------------------------------------
\usepackage{amssymb,amsmath}
%newcommand{\deffVdm}{\triangleq}
%------ using natbib --------------------------------------------------------
%\usepackage{natbib}
%\def\bibname{References}
%%bibpunct[,]{(}{)}{;}{a}{,}{,}
%\bibpunct[,]{[}{]}{,}{n}{,}{,}
%%bibliographystyle{plainnat}
%\bibliographystyle{elsarticle-num-names}
%%bibliographystyle{splncsnat}
%\def\citeyearpar#1{\cite{#1}} % redefining
\newcommand\bibsection{\section*{References}}
%------ using hyperref ------------------------------------------------------
\usepackage{hyperref}
%------ xy ------------------------------------------------------------------
\usepackage[all]{xy}
\def\larrow#1#2#3{\xymatrix{ #3 & #1 \ar[l]_-{#2} }}
\def\rarrow#1#2#3{\xymatrix{ #1 \ar[r]^-{#2} & #3 }}
\def\bdarrow#1#2#3#4{\xymatrix{#1\ar@<.5ex>[r]^{#2}&#4\ar@<.5ex>[l]^{#3}}}
\let\fdep=\larrow
\let\lhoare=\larrow
\let\rhoare=\rarrow
\let\longlfdep=\longlarrow
\def\arLaw#1#2#3#4#5{
\xymatrix{
        #1      \ar@/^1pc/[rr]^-{#4} &
        #5 &
        #2      \ar@/^1pc/[ll]^-{#3}
}}
\def\arIso#1#2#3#4{\arLaw{#1}{#2}{#3}{#4}\iso}
%------ local macros --------------------------------------------------------
\def\eqnnewpagex{\end{eqnarray}\newpage~\vskip-2em\begin{eqnarray}\nonumber}
\def\secref#1{Sect.~\ref{#1}}
\def\quotes#1{``#1''}
\def\htmladdnormallink#1#2{#1}
\def\fst{\mathit{fst}}
\def\snd{\mathit{snd}}
\def\implied{\mathbin\Leftarrow}
\def\fork{\mathbin{\hbox{\tiny${}^\vartriangle$}}}
\def\choice#1{\mathbin{_{#1}\diamond}}
\def\bang{{!}}
\def\uncurry #1{\widehat{#1}}
\def\mcond#1#2#3{#1 \rightarrow #2\ ,\ #3}
\def\etaT{\eta_{\fun T}}
\def\muT{\mu_{\fun T}}
\def\etaF{\eta_{\fun F}}
\def\muF{\mu_{\fun F}}
\def\klei#1{\overline{#1}}
\def\flt#1{{#1}^\flat}
\def\bibliometrics#1#2{\relax} % #2 to swallow full stop :-)
\def\enset#1{\mathopen{ \{ }#1\mathclose{ \} }}
\def\mblock#1#2#3#4{\left[\begin{array}{c|c}#1&#2\\\hline#3&#4\end{array}\right]}
%------ redefined --------------------------
\def\equiv{\Leftrightarrow}
\def\B{\mathbb{B}}
\def\quanta#1{\mathopen{\langle\!|}#1\mathclose{|\!\rangle}}
%-------------------------------------------

\begin{document}

\begin{abstract}
For the average programmer, \emph{adjunctions} are (if at all known!) more
respected than loved. At best, they are regarded as an algebraic device of theoretical interest
only, not useful in common practice. This paper is aimed at showing the
opposite: that adjunctions underlie most of the work we do as programmers,
in particular those using the functional paradigm.

However, functions alone are not sufficient to express the whole spectrum of programming,
with its dichotomy between \emph{specifications} --- \emph{what} is (often vaguely) required ---
and \emph{implementations} --- \emph{how} what is required is (hopefully well) implemented.
For this, one needs to extend functions to \emph{relations}.

Motivated by the pioneering work of Ralf Hinze on "adjoint (un)folds", this paper shows how 
the core of the so-called (relational) Algebra of Programming 
% for programming by calculation
arises from adjunctions. Moreover, it also shows how to calculate recursive
programs from specifications expressed by Galois connections --- a special kind of adjunction.

Because Galois connections are easier to understand than adjunctions in general,
the paper adopts a tutorial style, starting from the former and leading to the latter
(a path usually not followed in the literature). The main aim is to reconcile the
functional programming community with a concept that is central to software design
as a whole, but rarely accepted as such.

\end{abstract}

\begin{keyword}
%
	Algebra of programming
\sep
	Programming from specifications
\sep
	Adjunctions
%
\end{keyword}

\maketitle

%epigraph{I recall seeing a package to make quotes}{Snowball}
\vskip2em ~ \hfill
\begin{minipage}{.60\textwidth}\footnotesize\em
``(...) and Jim Thatcher proposed the name \emph{ADJ} as a (terrible) pun on the title of the book that we had planned to write (...) [recalling] that \emph{adjointness} is a very important concept in category theory (...)"
\vskip 1.5ex \em
--- Joseph A. Goguen, \emph{Memories of ADJ}, EATCS nr. 36, 1989
\end{minipage}

\section{Context}
The notion of an \emph{algebraic data type} is central to the theoretical
advances in computer science of the 1980s --- a ``vintage decade" that turned
\emph{program semantics} into a branch of scientific knowledge \cite{BG82,BL84},
and the trend in which the WADT series of workshops arose. In particular, the 'ADJ
group' promoted what can be regarded as the first effective use of category
theory in computer science, centered upon notions such as \emph{initiality},
\emph{freeness} and 
\emph{institution} \cite{BG82,GB92}.

The categorial concept of an \emph{adjunction} \cite{Ma71} underlies all such techniques
and is so important that the ADJ group decided to carve it in their own acronym,
as quoted above. However, for the average programmer \emph{adjunctions}
are (if at all known) regarded, at best, as working at
the meta-level only \cite{GB92}. In fact, explicit use of {adjunctions}
as an instrumental device for abstract reasoning in programming is relatively
rare. Less rare is the use of Galois connections (a special case of adjunction)
to structure relational algebra techniques \cite{BB04,Ba04a}, but even so the
topic is not mainstream.

This contribution to the WADT series tries to show how relevant adjunctions are in
explaining many things we do as programmers. In a tutorial flavour,  it will try to
show how practical adjunctions are by revealing their ``chemistry in action''.

It is common practice to introduce the adjunction concept first, and only then
refer to what is regarded as a modest instance: the Galois connection (GC).
That is, general concept first, instances later.
Below we go in the opposite direction, which is easier to grasp: GCs are presented
first, together with a set of examples and applications. Only after these are understood 
and appreciated does one step into full generality.

\section{Galois connections}
Things in everyday life often come ``in pairs", as dichotomies such as
e.g.\ \emph{ good/bad, action/reaction, the left/the right, lower/upper, {easy}/{hard}}
and so on.
In a sense, each pair defines itself: one element of the pair exists...\ because
the other also exists, and is its \emph{opposite} (i.e.\ \emph{antithesis}).
Despite the circularity, common everyday language survives over such dualities.
%

\paragraph{Perfect antithesis}
The perfect antithesis (opposition, inversion) is the \emph{bijection} or \emph{isomorphism}.
For instance, \emph{multiplication} and \emph{division} are inverses of each other in the positive reals:
\ensuremath{\frac{\Varid{x}}{\Varid{y}} \times \Varid{y}\mathrel{=}\Varid{x}} and \ensuremath{\frac{\Varid{x} \times \Varid{y}}{\Varid{y}}\mathrel{=}\Varid{x}}. That is, there is no loss of information when dividing or multiplying. In general,
\ensuremath{\Varid{f}} and \ensuremath{\Varid{g}} such that
\begin{eqnarray}
        \arIso{\ensuremath{\Conid{B}}}{\ensuremath{\Conid{A}}}{\ensuremath{\Varid{f}}}{\ensuremath{\Varid{g}}}
&&
\ensuremath{\begin{lcbr}\Varid{f}\;(\Varid{g}\;\Varid{b})\mathrel{=}\Varid{b}\\\Varid{g}\;(\Varid{f}\;\Varid{a})\mathrel{=}\Varid{a}\end{lcbr}}
	\label{eq:230206a}
\end{eqnarray}
hold are termed \emph{isomorphisms} and regarded as \emph{lossless} transformations.
% (Also ``energy preserving" \fbox{FALTA}.)

\paragraph{Imperfect antithesis}
However, data transformations in practice are \emph{lossy}, e.g.
\begin{eqnarray*}
\xymatrix@C=2em@R=3em{
	\mbox{\includegraphics[width=2.70em]{K6-T1-jpg}}
		\ar@/^1.2pc/[rr]^-{\ensuremath{\Varid{jpg2pdf}}}
&
	\not\cong
&
	\mbox{\includegraphics[width=2.20em]{pdf.png}}
		\ar@/^1.2pc/[ll]^-{\ensuremath{\Varid{pdf2jpg}}}
}
&&
\arrayin{
	&\ensuremath{\Varid{jpg2pdf} \comp \Varid{pdf2jpg}} \not= \ensuremath{{id}}&
\\
	&\ensuremath{\Varid{pdf2jpg} \comp \Varid{jpg2pdf}} \not= \ensuremath{{id}}&
}
\end{eqnarray*}
even though our eyes can hardly spot the difference in most cases.

It is often the case that loss of information in such imperfect inversions
can be expressed in this way,
\begin{eqnarray}
\ensuremath{\begin{lcbr}\Varid{f}\;(\Varid{g}\;\Varid{b})\leq \Varid{b}\\\Varid{a}\sqsubseteq \Varid{g}\;(\Varid{f}\;\Varid{a})\end{lcbr}}
	\label{eq:220625a}
\end{eqnarray}
telling ``how bad" each \emph{``round trip"} is. This relies on
under and over \emph{approximations} captured by two \emph{preorders},
\begin{eqnarray*}
        \arLaw{\ensuremath{(\leq )}}{\ensuremath{(\sqsubseteq )}}{\ensuremath{\Varid{f}}}{\ensuremath{\Varid{g}}}{}
\end{eqnarray*}
%
\begin{wrapfigure}[7]{r}{12.5em}
\vskip -2em \includegraphics[width=0.35\textwidth]{hasse.png}
\end{wrapfigure}
%
where \ensuremath{\Varid{f}} and \ensuremath{\Varid{g}} are assumed  monotonic.

\paragraph{Handling approximations}
Let us write the arrow \ensuremath{\rarrow{\Varid{x}}{(\leq )}{\Varid{y}}} (resp.\ \ensuremath{\rarrow{\Varid{x}}{(\sqsubseteq )}{\Varid{y}}})
to denote \ensuremath{\Varid{x}\leq \Varid{y}} (resp.\ \ensuremath{\Varid{x}\sqsubseteq \Varid{y}}) in (\ref{eq:220625a}). We shall drop
the ordering symbols, e.g.\ simply writing \ensuremath{\rarrow{\Varid{x}}{}{\Varid{y}}}, wherever these are clear from the context, as
in the Hasse diagram aside. This arrow-notation will enable us to express
our reasoning {graphically}, as in the following diagram:
\begin{eqnarray}
\vcenter{\mbox{
\begin{picture}(200,112)(0,0)
\unitlength=0.4mm
%thicklines
\let\framebox=\makebox
%
\put(10,80){\framebox(10,10){\ensuremath{(\sqsubseteq )}}}
\put(10,10){\framebox(10,10){\ensuremath{\Varid{a}}}}
\put(10,50){\framebox(10,10){\ensuremath{\Varid{g}\;\Varid{x}}}}
\put(15,20){\vector(0,1){30}}
%
\put(24,85){\vector(1,0){22}}
\put(30,85){\framebox(10,10){\ensuremath{\Varid{f}}}}
\put(50,80){\framebox(10,10){\ensuremath{(\leq )}}}
\put(50,10){\framebox(10,10){ \ensuremath{\Varid{f}\;\Varid{a}}}}
\put(55,20){\vector(0,1){28}}
\put(40,50){\framebox(30,10){ \ensuremath{\Varid{f}\;(\Varid{g}\;\Varid{x})}}}
%
\put(90,50){\framebox(10,10){\ensuremath{\Varid{x}}}}
\put(72,55){\vector(1,0){18}}
\put(60,20){\vector(1,1){30}}
%
\put(64,85){\vector(1,0){55}}
\put(90,85){\framebox(10,10){\ensuremath{\Varid{g}}}}
%
\put(125,80){\framebox(10,10){\ensuremath{(\sqsubseteq )}}}
\put(80,10){\framebox(30,10){\ensuremath{\Varid{g}\;(\Varid{f}\;\Varid{a})}}}
\put(95,20){\vector(1,1){30}}
\put(125,50){\framebox(10,10){\ensuremath{\Varid{g}\;\Varid{x}}}}

\put(125,10){\framebox(10,10){\ensuremath{\Varid{a}}}}
\put(125,15){\vector(-1,0){15}}

\put(130,20){\vector(0,1){30}}
\end{picture}
}} \rule{ 9em}{0pt} %% why need for this?
	\label{eq:221027b}
\end{eqnarray}

Let us ``parse'' this diagram without rushing: arrow \ensuremath{\Varid{a}\to \Varid{g}\;\Varid{x}} means \ensuremath{\Varid{a}\sqsubseteq \Varid{g}\;\Varid{x}}.
By monotonicity we get \ensuremath{\Varid{f}\;\Varid{a}\leq \Varid{f}\;(\Varid{g}\;\Varid{x})}, i.e.\  arrow \ensuremath{\Varid{f}\;\Varid{a}\to \Varid{f}\;(\Varid{g}\;\Varid{x})}. From (\ref{eq:220625a}) we
get \ensuremath{\Varid{f}\;(\Varid{g}\;\Varid{x})\to \Varid{x}} and, by transitivity (``composition'' of these two
arrows) we get \ensuremath{\Varid{f}\;\Varid{a}\to \Varid{x}}. We are done with the first ``triangle".

The triangle on the right starts with \ensuremath{\Varid{g}\;(\Varid{f}\;\Varid{a})\to \Varid{g}\;\Varid{x}}, which follows
by monotonicity from \ensuremath{\Varid{f}\;\Varid{a}\to \Varid{x}} in the first one. Again from (\ref{eq:220625a})
and transitivity we get \ensuremath{\Varid{a}\to \Varid{g}\;\Varid{x}} where we started from. Summing up:
\begin{eqnarray*}
\xarrayin{
	\ensuremath{\Varid{a}\sqsubseteq \Varid{g}\;\Varid{x}} & \ensuremath{\Rightarrow } & \ensuremath{\Varid{f}\;\Varid{a}\leq \Varid{x}} & \ensuremath{\Rightarrow } & \ensuremath{\Varid{a}\sqsubseteq \Varid{g}\;\Varid{x}}
}
\end{eqnarray*}
By circular implication, the equivalence
\begin{eqnarray}
	\ensuremath{\Varid{f}\;\Varid{a}\leq \Varid{x}} & \ensuremath{~\Leftrightarrow~} & \ensuremath{\Varid{a}\sqsubseteq \Varid{g}\;\Varid{x}}
	\label{eq:230305b}
\end{eqnarray}
holds for any \ensuremath{\Varid{a}} and \ensuremath{\Varid{x}}, and we say that \ensuremath{\Varid{f}} and \ensuremath{\Varid{g}} are \emph{Galois connected},
writing \ensuremath{\Varid{f}\mathbin\dashv \Varid{g}} to declare so.
Terminology: \ensuremath{\Varid{f}} is said to be the \emph{lower} (a.k.a.\ \emph{left}) adjoint
of the connection and \ensuremath{\Varid{g}} the \emph{upper} (a.k.a.\ \emph{right}) adjoint. The
intuition behind this terminology is captured by the superlatives in the
following interpretation of (\ref{eq:230305b}):
\begin{itemize}
\item	\ensuremath{\Varid{f}\;\Varid{a}} --- \emph{lowest} \ensuremath{\Varid{x}} such that \ensuremath{\Varid{a}\sqsubseteq \Varid{g}\;\Varid{x}}
\item	\ensuremath{\Varid{g}\;\Varid{x}} --- \emph{greatest} \ensuremath{\Varid{a}} such that \ensuremath{\Varid{f}\;\Varid{a}\leq \Varid{x}}.
\end{itemize}
Did we write \emph{``superlatives"}? Note that we have plenty of these in \emph{software
requirements}, e.g.
\begin{itemize}
\item ... the \emph{largest} prefix of \ensuremath{\Varid{x}} with at most \ensuremath{\Varid{n}} elements (i.e.\ the meaning of function \ensuremath{\mathsf{take}\;\Varid{n}\;\Varid{x}} in Haskell)
\item ... the \emph{largest} number that multiplied by \ensuremath{\Varid{y}} is at most \ensuremath{\Varid{x}} (i.e.\ the meaning of integer division \ensuremath{{\Varid{x}}\div{\Varid{y}}}).
\end{itemize}
Back to the perfect/imperfect dichotomies above, compare {numeric division} in the reals (\ensuremath{\R}), for \ensuremath{\Varid{y}\not=\mathrm{0}},
\begin{eqnarray*}
	\ensuremath{\Varid{a} \times \Varid{y}\mathrel{=}\Varid{x}} & \ensuremath{~\Leftrightarrow~} & \ensuremath{\Varid{a}\mathrel{=}\Varid{x}\mathbin{/}\Varid{y}}
\end{eqnarray*}
--- an \emph{isomorphism} --- with (whole) division in the natural numbers (\ensuremath{\N_0}),
\begin{eqnarray}
	\ensuremath{\Varid{a} \times \Varid{y}\leq \Varid{x}} & \ensuremath{~\Leftrightarrow~} & \ensuremath{\Varid{a}\leq {\Varid{x}}\div{\Varid{y}}}
	\label{eq:221026b}
\end{eqnarray}
--- a Galois \emph{connection}: \ensuremath{( \times \Varid{y})\mathbin\dashv (\div \Varid{y})}.

\section{The easy and the hard}
It is the experience of every child in school that \ensuremath{\Varid{x}\div \Varid{y}} is much harder to calculate by hand than \ensuremath{\Varid{x} \times \Varid{y}}.
Indeed, division is perhaps the very first ``hard" problem (algorithm) that children encounter in their basic maths education.
Interestingly, \ensuremath{( \times \Varid{y})\mathbin\dashv (\div \Varid{y})} bears a simple message:
\begin{quote}
\emph{hard} \ensuremath{(\div \Varid{y})} is explained by \emph{easy} \ensuremath{( \times \Varid{y})}.
\end{quote}
This pattern extends to program specifications, recall 
\begin{quote}
\ensuremath{\mathsf{take}\;\Varid{n}\;\Varid{xs}} should yield the \emph{longest} possible \emph{prefix} of \ensuremath{\Varid{xs}} not exceeding \ensuremath{\Varid{n}} in \emph{length}
\end{quote}
from above.
The corresponding \emph{formal specification},
\begin{eqnarray}
	\ensuremath{\underbrace{\mathsf{length}\;\Varid{ys}\leq \Varid{n}\mathrel{\wedge}\Varid{ys}\sqsubseteq \Varid{xs}}_{\Varid{easy}}} \wider{\wider\equiv} \ensuremath{\underbrace{\Varid{ys}\sqsubseteq \mathsf{take}\;\Varid{n}\;\Varid{xs}}_{\Varid{hard}}}
	\label{eq:220629a}
	\label{eq:100101a'}
\end{eqnarray}
is another GC, where \ensuremath{(\sqsubseteq )} is the list-prefix partial ordering. Many other examples can be found in programming, for
instance:
\begin{itemize}
\item	The function \ensuremath{\Varid{takeWhile}\;\Varid{p}\;\Varid{xs}} should yield the \emph{longest prefix} of \ensuremath{\Varid{xs}} whose elements all satisfy predicate \ensuremath{\Varid{p}}.
\item	The function \ensuremath{\mathsf{filter}\;\Varid{p}\;\Varid{xs}} should yield the \emph{longest sublist} of $ xs$ all elements of which satisfy predicate $ p$.
\end{itemize}

\section{Indirect equality}
Back to \ensuremath{( \times \Varid{y})\mathbin\dashv (\div \Varid{y})}, can the well-known \emph{implementation} of whole division
\begin{eqnarray}
\ensuremath{{\Varid{x}}\div{\Varid{y}}\mathrel{=}\mathbf{if}\;\Varid{x}\geq \Varid{y}\;\mathbf{then}\;\mathrm{1}\mathbin{+}{({\Varid{x}}\ominus{\Varid{y}})}\div{\Varid{y}}\;\mathbf{else}\;\mathrm{0}}
	\label{eq:230109a}
\end{eqnarray}
be calculated from \emph{specification} (\ref{eq:221026b})?
Note that, because subtraction in \ensuremath{\N_0} is not invertible, one needs to resort
to ``truncated minus'' \ensuremath{{\Varid{x}}\ominus{\Varid{y}}} which, as one might suspect, is an adjoint
of another GC in \ensuremath{\N_0}:
\begin{eqnarray}
\ensuremath{{\Varid{a}}\ominus{\Varid{b}}\leq \Varid{x}~\Leftrightarrow~\Varid{a}\leq \Varid{x}\mathbin{+}\Varid{b}}
\end{eqnarray}

To address the question, one needs yet another brick in the wall: the principle of \emph{indirect equality}, valid for any partial order \cite{Ba04a}:
\begin{eqnarray}
	\ensuremath{\Varid{a}\mathrel{=}\Varid{b}} & \ensuremath{~\Leftrightarrow~} & \ensuremath{\rcb{\forall}{\Varid{z}}{}{\Varid{z}\leq \Varid{a}~\Leftrightarrow~\Varid{z}\leq \Varid{b}}}
	\label{eq:230109b}
\end{eqnarray}
%
This principle of \emph{indirect equality} blends nicely with GCs, as the following calculation sketch suggests:
\begin{eqnarray*}
\start
	\ensuremath{\Varid{z}\leq \Varid{g}\;\Varid{a}}
%
\just\equiv{... }
%
	\dots \mbox{(go to the \emph{easy} side, do things there and come back})
%
\just\equiv{... }
%
	\ensuremath{\Varid{z}\leq \ldots\Varid{g}\ldots\Varid{a'}\ldots}
%
\just{::}{ indirect equality }
%
	\ensuremath{\Varid{g}\;\Varid{a}\mathrel{=}\ldots\Varid{g}\ldots\Varid{a'}\ldots}
%
\end{eqnarray*}
Note how a difficult \ensuremath{\Varid{g}} can in principle be calculated by \emph{going to the \emph{easy} side of the specification GC and coming back}.

As a simple example of using (\ref{eq:230109b}), let us calculate \ensuremath{{\Varid{x}}\div{\Varid{y}}}
(\ref{eq:221026b}) in case \ensuremath{\Varid{x}\geq \Varid{y}} holds:
\begin{eqnarray*}
\start
	\ensuremath{\Varid{z}\leq \Varid{x}\div \Varid{y}}
%
%cjust\equiv{}
%
%	|z >< y <= x|
%
\just\equiv{ \ensuremath{( \times \Varid{y})\mathbin\dashv (\div \Varid{y})} and \ensuremath{({\Varid{x}}\ominus{\Varid{y}})\mathbin{+}\Varid{y}\mathrel{=}\Varid{x}} for \ensuremath{\Varid{x}\geq \Varid{y}}}
%
	\ensuremath{\Varid{z} \times \Varid{y}\leq ({\Varid{x}}\ominus{\Varid{y}})\mathbin{+}\Varid{y}}
%
\just\equiv{ \ensuremath{({}\ominus{\Varid{y}})\mathbin\dashv (\mathbin{+}\Varid{y})} }
%
	\ensuremath{{(\Varid{z} \times \Varid{y})}\ominus{\Varid{y}}\leq {\Varid{x}}\ominus{\Varid{y}}}
%
\just\equiv{ factoring out \ensuremath{\Varid{y}} works also for \ensuremath{{}\ominus{}}}
%
	\ensuremath{({\Varid{z}}\ominus{\mathrm{1}}) \times \Varid{y}\leq {\Varid{x}}\ominus{\Varid{y}}}
%
\just\equiv{ chain the two \emph{GC}s }
%
%	|minus z 1 <= div ((minus x y)) y|
%
%cjust\equiv{}
%
	\ensuremath{\Varid{z}\leq \mathrm{1}\mathbin{+}{({\Varid{x}}\ominus{\Varid{y}})}\div{\Varid{y}}}
%
\just{::}{recursive branch of (\ref{eq:230109a}) calculated thanks to indirect equality (\ref{eq:230109b}) }
%
	\ensuremath{{\Varid{x}}\div{\Varid{y}}\mathrel{=}\mathrm{1}\mathbin{+}{({\Varid{x}}\ominus{\Varid{y}})}\div{\Varid{y}}}
%
\qed
\end{eqnarray*}
The other case (\ensuremath{\Varid{x}\mathbin{<}\Varid{y}}) also stems from (\ref{eq:221026b}):
\begin{eqnarray*}
\start
\ensuremath{\Varid{x}\mathbin{<}\Varid{y}}
\just\equiv{trivial}
\ensuremath{\neg \;(\Varid{y}\leq \Varid{x})}
\just\equiv{ \ref{eq:221026b}, for \ensuremath{\Varid{a}\mathbin{:=}\mathrm{1}} }
\ensuremath{\mathrm{1}\mathbin{>}{\Varid{x}}\div{\Varid{y}}}
\just\equiv{trivial (in \ensuremath{\N_0})}
\ensuremath{{\Varid{x}}\div{\Varid{y}}\mathrel{=}\mathrm{0}}
\qed
\end{eqnarray*}
Altogether, we have calculated the recursive implementation (\ref{eq:230109a}) of \ensuremath{{\Varid{x}}\div{\Varid{y}}}  from its GC specification (\ref{eq:221026b}). 

\section{GCs as formal specifications} \label{seq:230303d}
Let us now try a similar exercise for \ensuremath{\mathsf{take}}, formally specified by (\ref{eq:220629a}).
This time, however, no known implementation is assumed.
Moreover, we wish to show how to draw properties from specification (\ref{eq:220629a})
\emph{before} implementing \ensuremath{\mathsf{take}}, i.e.\ \emph{without} knowing anything about its actual implementation.

For instance, what happens if we chain two \ensuremath{\mathsf{take}}s in a row, \ensuremath{(\mathsf{take}\;\Varid{m}) \comp (\mathsf{take}\;\Varid{n})}?
We \emph{calculate}:
\begin{eqnarray*}
\start
	\ensuremath{\Varid{ys}\sqsubseteq \mathsf{take}\;\Varid{m}\;(\mathsf{take}\;\Varid{n}\;\Varid{xs})}
%
\just\equiv{GC (\ref{eq:220629a}) }
%
	\ensuremath{\mathsf{length}\;\Varid{ys}\leq \Varid{m}\mathrel{\wedge}\Varid{ys}\sqsubseteq \mathsf{take}\;\Varid{n}\;\Varid{xs}}
%
\just\equiv{again GC (\ref{eq:220629a}) }
%
	\ensuremath{\mathsf{length}\;\Varid{ys}\leq \Varid{m}\mathrel{\wedge}\mathsf{length}\;\Varid{ys}\leq \Varid{n}\mathrel{\wedge}\Varid{ys}\sqsubseteq \Varid{xs}}
%
\just\equiv{min GC: \ensuremath{\Varid{a}\leq \Varid{x}\mathrel{\wedge}\Varid{a}\leq \Varid{y}~\Leftrightarrow~\Varid{a}\leq \Varid{x}\mathbin{`\Varid{min}`}\Varid{y}}}
%
	\ensuremath{\mathsf{length}\;\Varid{ys}\leq (\Varid{m}\mathbin{`\Varid{min}`}\Varid{n})\mathrel{\wedge}\Varid{ys}\sqsubseteq \Varid{xs}}
%
\just\equiv{again GC (\ref{eq:220629a}) }
%
	\ensuremath{\Varid{ys}\leq \mathsf{take}\;(\Varid{m}\mathbin{`\Varid{min}`}\Varid{n})\;\Varid{xs}}
%
\just{::}{ indirect equality (\ref{eq:230109b}) }
%
	\ensuremath{\mathsf{take}\;\Varid{m}\;(\mathsf{take}\;\Varid{n}\;\Varid{xs}))\mathrel{=}\mathsf{take}\;(\Varid{m}\mathbin{`\Varid{min}`}\Varid{n})\;\Varid{xs}}
%
\end{eqnarray*}
Note the fully \emph{deductive} calculation --- no recursion, no \emph{induction}.
There could be none, in fact, because we have no implementation of \ensuremath{\mathsf{take}} yet!
Calculating this is the subject of the reasoning that follows.

A quick inspection of (\ref{eq:220629a}) invites us to consider the cases \ensuremath{\Varid{n}\mathrel{=}\mathrm{0}} and \ensuremath{\Varid{xs}\mathrel{=}[\mskip1.5mu \mskip1.5mu]} because they trivialize the \emph{easy side} of the GC, as is easy to show. Case \ensuremath{\Varid{n}\mathrel{=}\mathrm{0}} first:
%
\begin{eqnarray*}
\start
	\ensuremath{\Varid{ys}\sqsubseteq \mathsf{take}\;\mathrm{0}\;\anonymous }
%
\just\equiv{ GC }
%
	\ensuremath{\mathsf{length}\;\Varid{ys}\leq \mathrm{0}\mathrel{\wedge}\Varid{ys}\sqsubseteq \anonymous }
%
\just\equiv{ \ensuremath{\mathsf{length}\;[\mskip1.5mu \mskip1.5mu]\leq \mathrm{0}~\Leftrightarrow~\Varid{ys}\mathrel{=}[\mskip1.5mu \mskip1.5mu]}}
%
	\ensuremath{\Varid{ys}\mathrel{=}[\mskip1.5mu \mskip1.5mu]}
%
\just\equiv{ antisymmetry of \ensuremath{(\sqsubseteq )}}
%
	\ensuremath{\Varid{ys}\sqsubseteq [\mskip1.5mu \mskip1.5mu]}
%
\just{::}{ indirect equality }
%
	\ensuremath{\mathsf{take}\;\mathrm{0}\;\anonymous \mathrel{=}[\mskip1.5mu \mskip1.5mu]}
%qed
\end{eqnarray*}
Now case \ensuremath{\Varid{xs}\mathrel{=}[\mskip1.5mu \mskip1.5mu]}:
\begin{eqnarray*}
\start
	\ensuremath{\Varid{ys}\sqsubseteq \mathsf{take}\;\anonymous \;[\mskip1.5mu \mskip1.5mu]}
%
\just\equiv{ GC }
%
	\ensuremath{\mathsf{length}\;\Varid{ys}\leq \anonymous \mathrel{\wedge}\Varid{ys}\sqsubseteq [\mskip1.5mu \mskip1.5mu]}
%
\just\equiv{ \ensuremath{\Varid{ys}\sqsubseteq [\mskip1.5mu \mskip1.5mu]~\Leftrightarrow~\Varid{ys}\mathrel{=}[\mskip1.5mu \mskip1.5mu]} }
%
	\ensuremath{\Varid{ys}\sqsubseteq [\mskip1.5mu \mskip1.5mu]}
%
\just{::}{ indirect equality }
%
	\ensuremath{\mathsf{take}\;\anonymous \;[\mskip1.5mu \mskip1.5mu]\mathrel{=}[\mskip1.5mu \mskip1.5mu]}
%qed
\end{eqnarray*}
Thus we get the base cases:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathsf{take}\;\mathrm{0}\;\anonymous {}\<[12]%
\>[12]{}\mathrel{=}[\mskip1.5mu \mskip1.5mu]{}\<[E]%
\\
\>[B]{}\mathsf{take}\;\anonymous \;[\mskip1.5mu \mskip1.5mu]{}\<[12]%
\>[12]{}\mathrel{=}[\mskip1.5mu \mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

By pattern matching, the remaining case is \ensuremath{\mathsf{take}\;(\Varid{n}\mathbin{+}\mathrm{1})\;(\Varid{h}\mathbin{:}\Varid{xs})}.
The following fact about list-prefixing,
\begin{eqnarray}
\start
	\ensuremath{\Varid{s}\sqsubseteq \Varid{f}\;(\Varid{h}\mathbin{:}\Varid{t})} \wider\equiv
	s = \ensuremath{[\mskip1.5mu \mskip1.5mu]} \wider\lor \rcb\exists {s'}{s = (h:s')}{\ensuremath{\Varid{s'}\sqsubseteq \Varid{t}}}
	\label{eq:100101c}
\end{eqnarray}
will be required. This property is quite obvious but... where does it come from?\footnote{
The question also applies to \ensuremath{\Varid{ys}\sqsubseteq [\mskip1.5mu \mskip1.5mu]~\Leftrightarrow~\Varid{ys}\mathrel{=}[\mskip1.5mu \mskip1.5mu]} which was taken for granted above.
}
Let us accept it from the moment, leaving the answer to the question to
section \ref{sec:230305d} later on. Once again, we calculate:
%
\begin{eqnarray*}
\start
\ensuremath{\Varid{ys}\sqsubseteq \mathsf{take}\;(\Varid{n}\mathbin{+}\mathrm{1})\;(\Varid{h}\mathbin{:}\Varid{xs})}
\just\equiv{ GC (\ref{eq:100101a'}) ; prefix (\ref{eq:100101c}) }
\ensuremath{\mathsf{length}\;\Varid{ys}\leq \Varid{n}\mathbin{+}\mathrm{1}\mathrel{\wedge}(\Varid{ys}\mathrel{=}[\mskip1.5mu \mskip1.5mu]\mathrel{\vee}\rcb{\exists }{\Varid{ys'}}{\Varid{ys}\mathrel{=}(\Varid{h}\mathbin{:}\Varid{ys'})}{\Varid{ys'}\sqsubseteq \Varid{xs}})}
\just\equiv{ distribution ; \ensuremath{\mathsf{length}\;[\mskip1.5mu \mskip1.5mu]\mathrel{=}\mathrm{0}\leq \Varid{n}\mathbin{+}\mathrm{1}} }
\ensuremath{\Varid{ys}\mathrel{=}[\mskip1.5mu \mskip1.5mu]\mathrel{\vee}\rcb{\exists }{\Varid{ys'}}{\Varid{ys}\mathrel{=}(\Varid{h}\mathbin{:}\Varid{ys'})}{\mathsf{length}\;\Varid{ys}\leq \Varid{n}\mathbin{+}\mathrm{1}\mathrel{\wedge}\Varid{ys'}\sqsubseteq \Varid{xs}}}
\just\equiv{ \ensuremath{\mathsf{length}\;(\Varid{h}\mathbin{:}\Varid{t})\mathrel{=}\mathrm{1}\mathbin{+}\mathsf{length}\;\Varid{t}} }
\ensuremath{\Varid{ys}\mathrel{=}[\mskip1.5mu \mskip1.5mu]\mathrel{\vee}\rcb{\exists }{\Varid{ys'}}{\Varid{ys}\mathrel{=}(\Varid{h}\mathbin{:}\Varid{ys'})}{\mathsf{length}\;\Varid{ys'}\leq \Varid{n}\mathrel{\wedge}\Varid{ys'}\sqsubseteq \Varid{xs}}}
\just\equiv{ GC (\ref{eq:100101a'}) }
\ensuremath{\Varid{ys}\mathrel{=}[\mskip1.5mu \mskip1.5mu]\mathrel{\vee}\rcb{\exists }{\Varid{ys'}}{\Varid{ys}\mathrel{=}(\Varid{h}\mathbin{:}\Varid{ys'})}{\Varid{ys'}\sqsubseteq \mathsf{take}\;\Varid{n}\;\Varid{xs}}}
\just\equiv{ fact (\ref{eq:100101c}) }
%
	\ensuremath{\Varid{ys}\sqsubseteq \Varid{h}\mathbin{:}\mathsf{take}\;\Varid{n}\;\Varid{xs}}
%
\just{::}{indirect equality over list prefixing \ensuremath{(\sqsubseteq )} }
%
	\ensuremath{\mathsf{take}\;(\Varid{n}\mathbin{+}\mathrm{1})\;(\Varid{h}\mathbin{:}\Varid{xs})\mathrel{=}\Varid{h}\mathbin{:}\mathsf{take}\;\Varid{n}\;\Varid{xs}}
%
\end{eqnarray*}
By putting everything together we have an implementation of \ensuremath{\mathsf{take}}, indeed
the standard one in Haskell:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathsf{take}\;\mathrm{0}\;\anonymous {}\<[18]%
\>[18]{}\mathrel{=}[\mskip1.5mu \mskip1.5mu]{}\<[E]%
\\
\>[B]{}\mathsf{take}\;\anonymous \;[\mskip1.5mu \mskip1.5mu]{}\<[18]%
\>[18]{}\mathrel{=}[\mskip1.5mu \mskip1.5mu]{}\<[E]%
\\
\>[B]{}\mathsf{take}\;(\Varid{n}\mathbin{+}\mathrm{1})\;(\Varid{h}\mathbin{:}\Varid{xs})\mathrel{=}\Varid{h}\mathbin{:}\mathsf{take}\;\Varid{n}\;\Varid{xs}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

In summary, by expressing the formal specification of a particular (e.g.\ recursive) function
in the form of a GC, one not only can prove properties but also calculate
an implementation (program) without performing inductive proofs.
However, the final implementation is inductive. So, the question arises:
\begin{quote}
	\emph{Where does this induction come from?}
\end{quote}
The answer is not immediate and calls for the generalization from GCs to adjunctions.

\section{From GCs to adjunctions} \label{sec:230302a}
Recall our arrow notation \ensuremath{\rarrow{\Varid{a}}{(\leq )}{\Varid{b}}} for \ensuremath{\Varid{a}\leq \Varid{b}} in  (\ref{eq:221027b}).
In the ``set of pairs" interpretation of a binary relation, one might write
\begin{quote}
\ensuremath{(\leq )\;(\Varid{a},\Varid{b})\mathrel{=}\{\mskip1.5mu (\Varid{a},\Varid{b})\mskip1.5mu\}}
\end{quote}
meaning that the evidence that we have that \ensuremath{\Varid{a}\leq \Varid{b}} holds is \ensuremath{\{\mskip1.5mu (\Varid{a},\Varid{b})\mskip1.5mu\}} --- the singleton set made of exactly the pair \ensuremath{(\Varid{a},\Varid{b})\;\mathbin\in \;(\leq )}.

Now compare
\ensuremath{(\leq )\;(\Varid{a},\Varid{b})\mathrel{=}\{\mskip1.5mu (\Varid{a},\Varid{b})\mskip1.5mu\}}
with something like (broadening scope):
\begin{quote}
\ensuremath{\cat{C}\;(\Varid{a},\Varid{b})\mathrel{=}\{\mskip1.5mu \mbox{ ``the things that relate $a$ to $b$ in some context $\cat{C}$' }\mskip1.5mu\}}
\end{quote}
So, every such ``thing'' \ensuremath{\Varid{m}\;\mathbin\in \;\cat{C}\;(\Varid{a},\Varid{b})} acts as a \emph{witness} of the
\ensuremath{\cat{C}}-relationship between \ensuremath{\Varid{a}} and \ensuremath{\Varid{b}}. Moreover, assuming \ensuremath{\cat{C}} (whatever this is), \ensuremath{\Varid{m}\;\mathbin\in \;\cat{C}\;(\Varid{a},\Varid{b})} can be written \ensuremath{\Varid{m}\mathbin{:}\Varid{a}\to \Varid{b}}, recovering the arrow notation used before.
(Notation \ensuremath{\Varid{m}\mathbin{:}\Varid{a}\to \Varid{b}} can also be read as telling that \ensuremath{\Varid{m}} is of \emph{type} \ensuremath{\Varid{a}\to \Varid{b}}, a view that matches with some examples below.)

We thus land into a \emph{category} --- \ensuremath{\cat{C}} --- where \ensuremath{\Varid{a}} and \ensuremath{\Varid{b}} are \emph{objects} and \ensuremath{\Varid{m}} is said to be a \emph{morphism}. In general, there will be more than one morphism between \ensuremath{\Varid{a}} and \ensuremath{\Varid{b}}, thus the need to name them. The set \ensuremath{\cat{C}\;(\Varid{a},\Varid{b})} of all such morphisms is called a \emph{homset}. 

Categories are an extremely versatile concept, as the following instances of categories show,
\begin{quote}
\ensuremath{\cat{C}\;(\Varid{a},\Varid{b})\mathrel{=}\{\mskip1.5mu \mbox{ 'matrices with $ a$-many columns and $ b$-many rows' }\mskip1.5mu\}}
\end{quote}
or
\begin{quote}
\ensuremath{\cat{C}\;(\Varid{a},\Varid{b})\mathrel{=}\{\mskip1.5mu \mbox{ 'Haskell functions from type $ a$ to type $ b$' }\mskip1.5mu\}}
\end{quote}
or
\begin{quote}
\ensuremath{\cat{C}\;(\Varid{a},\Varid{b})\mathrel{=}\{\mskip1.5mu \mbox{ 'binary relations in ${ a}\times{ b}$' }\mskip1.5mu\}}
\end{quote}
among many others relevant to maths and programming.

\begin{figure}
\centering\footnotesize
\begin{tabular}{l|l}
\bf Preorder & \bf Category
\\\hline
   Object pair & Morphism
\\ Reflexivity & Identity
\\ Transitivity & Composition
\\ Monotonic function & Functor
\\ Equivalence & Isomorphism
\\ Pointwise ordering & Natural transformation
\\ Closure & Monad
\\ Galois connection & Adjunction
\\ Indirect equality & Yoneda lemma
\end{tabular}
\caption{From preorders to categories\label{fig:221027a}}
\end{figure}

Compared to the preorders they generalize, categories purport a ``dramatic"
increase in expressiveness (Fig.\ \ref{fig:221027a}).
For instance, \ensuremath{\Varid{a}\leq \Varid{a}} always holds in a preorder (\emph{reflexivity}), that
is, homset \ensuremath{(\leq )\;(\Varid{a},\Varid{a})} is non-empty. The categorial extension of reflexivity
to an arbitrary category \ensuremath{\cat{C}} also means that \ensuremath{\cat{C}\;(\Varid{a},\Varid{a})} is non-empty because
it always includes a special morphism, the so-called \emph{identity} morphism
\ensuremath{{id}}. This is written \ensuremath{{id}\mathbin{:}\Varid{a}\to \Varid{a}} wherever \ensuremath{\cat{C}} is implicit from the context.
For instance, in the category \ensuremath{\cat{S}} of sets (objects) and functions between sets
(morphisms), \ensuremath{{id}\;\Varid{x}\mathrel{=}\Varid{x}} is the identity function.

In turn, preorder transitivity, \ensuremath{\Varid{a}\leq \Varid{b}\mathrel{\wedge}\Varid{b}\leq \Varid{c}\Rightarrow \Varid{a}\leq \Varid{c}}, generalizes to morphism \emph{composition}:
\ensuremath{\Varid{m}\;\mathbin\in \;\cat{C}\;(\Varid{a},\Varid{b})} and \ensuremath{\Varid{n}\;\mathbin\in \;\cat{C}\;(\Varid{b},\Varid{c})} generate \ensuremath{\Varid{n} \comp \Varid{m}} in \ensuremath{\cat{C}\;(\Varid{a},\Varid{c})}, called the composition
of \ensuremath{\Varid{n}} and \ensuremath{\Varid{m}}, which is such that \ensuremath{\Varid{m} \comp {id}\mathrel{=}{id} \comp \Varid{m}\mathrel{=}\Varid{m}}.

What is the meaning
of generalizing (\ref{eq:221027b}) from preorders \ensuremath{(\leq )} and \ensuremath{(\sqsubseteq )} to two
categories \ensuremath{\cat{S}} and \ensuremath{\cat{D}}? Recall our starting point,
\begin{eqnarray*}
\ensuremath{\begin{lcbr}\Varid{f}\;(\Varid{g}\;\Varid{x})\leq \Varid{x}\\\Varid{a}\sqsubseteq \Varid{g}\;(\Varid{f}\;\Varid{a})\end{lcbr}}
\end{eqnarray*}
which meanwhile was written thus:
\begin{eqnarray*}
\ensuremath{\begin{lcbr}\Varid{f}\;(\Varid{g}\;\Varid{x})\to \Varid{x}\\\Varid{a}\leftarrow \Varid{g}\;(\Varid{f}\;\Varid{a})\end{lcbr}}
\end{eqnarray*}
According to the correspondence of Fig. \ref{fig:221027a}, monotonic functions \ensuremath{\Varid{f}} and \ensuremath{\Varid{g}} give place to \emph{functors} \ensuremath{\fun F } and \ensuremath{\fun G }, respectively:\footnote{Recall that functors are available in Haskell via
\ensuremath{\Varid{fmap}}, exported by the \ensuremath{\Conid{Functor}} class. As is well known, \ensuremath{\fun F \;{id}\mathrel{=}{id}} and \ensuremath{\fun F \;(\Varid{f} \comp \Varid{g})\mathrel{=}(\fun F \;\Varid{f}) \comp (\fun F \;\Varid{g})}.
}
\begin{eqnarray}
\ensuremath{\begin{lcbr}\rarrow{\fun F \;(\fun G \;\Conid{X})}{\epsilon }{\Conid{X}}\\\larrow{\fun G \;(\fun F \;\Conid{A})}{\eta }{\Conid{A}}\end{lcbr}}
\end{eqnarray}
The ``core" morphisms \ensuremath{\epsilon } and \ensuremath{\eta } will be explained later. For the
moment, our aim is to ``replay" (\ref{eq:221027b}), now in the categorial setting:

\begin{eqnarray}
\hskip -4.5em \vcenter\mbox{
\begin{picture}(230,105)(-10,-00)
\unitlength=0.4mm
%thicklines
\let\framebox=\makebox
%
\put(10,80){\framebox(10,10){ \ensuremath{\cat{D}}}}
\put(10,10){\framebox(10,10){\ensuremath{\Conid{A}}}}
\put(10,50){\framebox(10,10){\ensuremath{\fun G \;\Conid{X}}}}
\put(15,20){\vector(0,1){30}}
\put( 3,30){\framebox(10,10){\ensuremath{\Varid{k}}}}
%
\put(24,85){\vector(1,0){22}}
\put(30,85){\framebox(10,10){\ensuremath{\fun F }}}
\put(50,80){\framebox(10,10){ \ensuremath{\cat{C}}}}
\put(50,10){\framebox(10,10){ \ensuremath{\fun F \;\Conid{A}}}}
\put(55,20){\vector(0,1){28}}
\put(38,30){\framebox(10,10){\ensuremath{\fun F \;\Varid{k}}}}
\put(40,50){\framebox(30,10){ \ensuremath{\fun F \;(\fun G \;\Conid{X})}}}
%
\put(90,50){\framebox(10,10){\ensuremath{\Conid{X}}}}
\put(75,55){\vector(1,0){17}}
\put(80,55){\framebox(10,10){\ensuremath{\epsilon }}}
%
\put(60,20){\vector(1,1){30}}
\put(93,30){\framebox(10,10){\ensuremath{\lfloor \Varid{k}\rfloor\mathrel{=}\Varid{f}}}}
%
\put(64,85){\vector(1,0){92}}
\put(90,85){\framebox(10,10){\ensuremath{\fun G }}}
%
\put(160,80){\framebox(10,10){ \ensuremath{\cat{D}}}}
\put(115,10){\framebox(30,10){\ensuremath{\fun G \;(\fun F \;\Conid{A})}}}
%put(125,20){\vector(1,1){30}}
\put(127,22){\line(1,1){ 9}}
\put(146,41){\vector(1,1){10}}
\put(135,31){\framebox(10,10){\ensuremath{\fun G \;\Varid{f}}}}
\put(160,50){\framebox(10,10){\ensuremath{\fun G \;\Conid{X}}}}
%
\put(160,10){\framebox(10,10){\ensuremath{\Conid{A}}}}
\put(162,15){\vector(-1,0){15}}
\put(150,00){\framebox(10,10){\ensuremath{\eta }}}
%
\put(165,20){\vector(0,1){30}}
\put(170,30){\framebox(10,10){\ensuremath{\lceil \Varid{f}\rceil}}}
%
%put(186,30){\framebox(10,10){|= k|}}
\end{picture}
}
	\label{eq:230209d}
\end{eqnarray}
Starting from some \ensuremath{\rarrow{\Conid{A}}{\Varid{k}}{\fun G \;\Conid{X}}} we obtain \ensuremath{\Varid{f}\mathrel{=}\epsilon  \comp \fun F \;\Varid{k}\mathrel{=}\lfloor \Varid{k}\rfloor},
granted by functor \ensuremath{\fun F } (triangle on the left). Picking \ensuremath{\Varid{f}} in turn, functor
\ensuremath{\fun G } grants \ensuremath{\lceil \Varid{f}\rceil\mathrel{=}\fun G \;\Varid{f} \comp \eta }, that is, \ensuremath{\lceil \Varid{f}\rceil\mathrel{=}\lceil \lfloor \Varid{k}\rfloor\rceil}. In
case \ensuremath{\lceil \Varid{f}\rceil\mathrel{=}\Varid{k}}, \ensuremath{\Varid{f}} and \ensuremath{\Varid{k}} are in a 1-to-1 correspondence and we have
the isomorphism
\begin{eqnarray}
\rule{6em}{0pt}	\ensuremath{\cat{C}\;(\fun F \;\Conid{A},\Conid{X})} & \ensuremath{\cong} & \ensuremath{\cat{D}\;(\Conid{A},\fun G \;\Conid{X})}
\label{eq:221118a}
\end{eqnarray}
clearly generalizing (\ref{eq:230305b}). 
In this case we say that we have an \emph{adjunction} and that
\ensuremath{\fun F } and \ensuremath{\fun G } are \emph{adjoint functors}, writing \ensuremath{\fun F \mathbin\dashv \fun G } as before.
\ensuremath{\fun F } is called the \emph{left adjoint} functor and
\ensuremath{\fun G }           the \emph{right adjoint} functor.

\section{Adjunctions}
Another way to express (\ref{eq:221118a}) is given below (\ref{eq:170429c}), where
the two adjoint functors \ensuremath{\fun F \mathbin{:}\cat{D}\to \cat{C}} and \ensuremath{\fun G \mathbin{:}\cat{C}\to \cat{D}} are renamed to
\ensuremath{\fun L \mathbin{:}\cat{D}\to \cat{C}} and \ensuremath{\fun R \mathbin{:}\cat{C}\to \cat{D}}, respectively,
to better match with the \emph{left} and \emph{right} qualifiers above:
\begin{eqnarray}
	\myxym{
		\ensuremath{\cat{C}}
			&
			&
			\ensuremath{\cat{D}}
			\\
			\ensuremath{\fun L \;\Conid{A}\to \Conid{X}}
			\ar@/^1pc/[rr]^{\ensuremath{\lceil \anonymous \rceil}}
		&
			\iso
			&
			\ensuremath{\Conid{A}\to \fun R \;\Conid{X}}
			\ar@/^1pc/[ll]^{\ensuremath{\lfloor \anonymous \rfloor}}
	}
\label{eq:170429c}
\end{eqnarray}
It also features the two isomorphism witnesses between the two homsets, where
\ensuremath{\lceil \Varid{f}\rceil} is called the \emph{\ensuremath{\fun R }-transpose} of \ensuremath{\Varid{f}}
and  \ensuremath{\lfloor \Varid{g}\rfloor} the \emph{\ensuremath{\fun L }-transpose} of \ensuremath{\Varid{g}}.
This isomorphism can be expressed in the standard way,
\begin{eqnarray}
	\ensuremath{\Varid{k}\mathrel{=}\lceil \Varid{f}\rceil} & \ensuremath{~\Leftrightarrow~} & \ensuremath{\lfloor \Varid{k}\rfloor\mathrel{=}\Varid{f}}
\label{eq:221118b}
\end{eqnarray}
capturing how one transpose is the opposite of the other. Clearly,
\begin{eqnarray}
\ensuremath{\begin{lcbr}\lfloor \lceil \Varid{f}\rceil\rfloor\mathrel{=}\Varid{f}\\\lceil \lfloor \Varid{k}\rfloor\rceil\mathrel{=}\Varid{k}\end{lcbr}}
\end{eqnarray}
and one is back to perfect antithesis (\ref{eq:230206a}), but in a much richer
setting, as is explained next.

From (\ref{eq:230209d}) we know that \ensuremath{\lfloor \Varid{k}\rfloor\mathrel{=}\epsilon  \comp \fun F \;\Varid{k}}. So we can inline this in (\ref{eq:221118b}) and
draw a diagram to depict what is going on:
%|B | parametric on |X|
%\emskip |B = fR X| for some |larrow CC fR DC|:
\begin{eqnarray}
&& \rule{2em}{0pt}
\myxym{
	\ensuremath{\cat{D}}
		\ar@/_0.9pc/[rr]_-{\ensuremath{\fun L }}
&
		\top
&
	\ensuremath{\cat{C}}
		\ar@/_0.9pc/[ll]_-{\ensuremath{\fun R }}
}
\nonumber
\\
		\ensuremath{\Varid{k}\mathrel{=}\lceil \Varid{f}\rceil}
		\wider\equiv
		\ensuremath{\underbrace{\epsilon  \comp \fun L \;\Varid{k}}_{\lfloor \Varid{k}\rfloor}\mathrel{=}\Varid{f}}
		& \rule{1em}{0pt}&
		\myxym{
			\ensuremath{\fun R \;\Conid{X}}
				&
				\ensuremath{\fun L \;(\fun R \;\Conid{X})}
				\ar[r]^{\ensuremath{\epsilon }}
			&
				X
				\\
				A
				\ar[u]^{\ensuremath{\Varid{k}\mathrel{=}\lceil \Varid{f}\rceil}}
			&
				\ensuremath{\fun L \;\Conid{A}}
				\ar[u]^{\ensuremath{\fun L \;\Varid{k}}}
			\ar[ru]_{f}
		}
\label{eq:221120a}
\end{eqnarray}
Thus we see how the adjunction \ensuremath{\fun L \mathbin\dashv \fun R } embodies a \emph{universal property} that tells that
\ensuremath{\lceil \Varid{f}\rceil} is the \emph{unique solution} of the equation \ensuremath{\epsilon  \comp \fun L \;\Varid{k}\mathrel{=}\Varid{f}} on \ensuremath{\Varid{k}}, for a given \ensuremath{\Varid{f}}.
Very soon we shall see 
how productive (\ref{eq:221120a}) is. For the moment, we just inspect what happens for \ensuremath{\Varid{k}\mathrel{=}{id}}. Since \ensuremath{\fun L \;{id}\mathrel{=}{id}} and \ensuremath{\epsilon  \comp {id}\mathrel{=}\epsilon }, we get \ensuremath{{id}\mathrel{=}\lceil \epsilon \rceil}, equivalent to 
\begin{eqnarray}
\ensuremath{\epsilon \mathrel{=}\lfloor {id}\rfloor}
\end{eqnarray}
by (\ref{eq:221118b}), leading to the definition of \ensuremath{\epsilon }.
Terminology: \ensuremath{\epsilon } is called the \emph{co-unit} of the adjunction.

\paragraph{Dual formulation}
The term \emph{co-unit} suggests that there might be a \emph{unit} somewhere in the construction
--- and indeed there is. Above we inlined \ensuremath{\lfloor \Varid{k}\rfloor\mathrel{=}\epsilon  \comp \fun L \;\Varid{k}} in (\ref{eq:221118b}).
But we could do otherwise, inlining the other definition \ensuremath{\lceil \Varid{k}\rceil\mathrel{=}\fun R \;\Varid{k} \comp \eta }. This gives
us a dual formulation of the adjunction,
\begin{eqnarray}
	k = \ensuremath{\lfloor \Varid{f}\rfloor} \wider\equiv \ensuremath{\underbrace{\fun R \;\Varid{k} \comp \eta }_{\lceil \Varid{k}\rceil}\mathrel{=}\Varid{f}}
& ~~~~ &
        \myxym{
	\ensuremath{\fun L \;\Conid{B}}
		\ar[d]_{\ensuremath{\Varid{k}\mathrel{=}\lfloor \Varid{f}\rfloor}}
&
	\ensuremath{\fun R \;(\fun L \;\Conid{B})}
		\ar[d]_{\ensuremath{\fun R \;\Varid{k}}}
&
	B
		\ar[l]_{\ensuremath{\eta }}
		\ar[ld]^{f}
\\
	C
&
	\ensuremath{\fun R \;\Conid{C}}
}
	\label{eq:230206b}
\end{eqnarray}
--- compare with (\ref{eq:221120a}) --- now telling that
\ensuremath{\lfloor \Varid{f}\rfloor} is the unique solution to equation \ensuremath{\fun R \;\Varid{k} \comp \eta \mathrel{=}\Varid{f}}.
Terminology: \ensuremath{\eta \mathrel{=}\lceil {id}\rceil} is called the \emph{unit} of the adjunction.

\section{Examples}
Before exploring the rich theory that arises from (\ref{eq:221120a},\ref{eq:230206b})
above, let us give some adjunction examples. Because we wish to focus on adjunctions
that are relevant to programming, the examples are less general then they
could be. Thus we stay within the category \ensuremath{\cat{S}} of sets and functions in the
examples that follow.

\paragraph{(Covariant) exponentials: \ensuremath{(\anonymous  \times \Conid{K})\mathbin\dashv ({\anonymous }^{\Conid{K}})}}
This is perhaps the most famous adjunction, holding between category \ensuremath{\cat{S}} and itself:
\begin{eqnarray*}
\xymatrix{
	\ensuremath{\Conid{A} \times \Conid{K}\to \Conid{X}}
 		\ar@/^1pc/[rr]^{\ensuremath{\mathbf{curry}\hskip 1pt {}}}
&
        \iso
&
	\ensuremath{\Conid{A}\to {\Conid{X}}^{\Conid{K}}}
 		\ar@/^1pc/[ll]^{\ensuremath{\mathbf{uncurry}\ {}}}
}
& \mbox{where} &
\ensuremath{\begin{lcbr}\mathbf{curry}\hskip 1pt {\Varid{f}}\;\Varid{a}\;\Varid{b}\mathrel{=}\Varid{f}\;(\Varid{a},\Varid{b})\\\mathbf{uncurry}\ {\Varid{g}}\;(\Varid{a},\Varid{b})\mathrel{=}\Varid{g}\;\Varid{a}\;\Varid{b}\end{lcbr}}
\end{eqnarray*}
This instantiates (\ref{eq:221120a}) for
\begin{eqnarray}
	\ensuremath{\begin{lcbr}\fun L \;\Conid{X}\mathrel{=}\Conid{X} \times \Conid{K}\\\fun R \;\Conid{X}\mathrel{=}{\Conid{X}}^{\Conid{K}}\\\epsilon \mathrel{=}\mathsf{ev}\end{lcbr}}
&&
	\ensuremath{\begin{lcbr}\lceil \Varid{f}\rceil\mathrel{=}\mathbf{curry}\hskip 1pt {\Varid{f}}\\\lfloor \Varid{f}\rfloor\mathrel{=}\mathbf{uncurry}\ {\Varid{f}}\end{lcbr}}
	\label{eq:230208h}
\end{eqnarray}
where \ensuremath{\Conid{X} \times \Conid{K}} denotes the Cartesian product of sets \ensuremath{\Conid{X}} and \ensuremath{\Conid{K}}, \ensuremath{{\Conid{X}}^{\Conid{K}}} denotes
the set of all functions of type \ensuremath{\Conid{K}\to \Conid{X}} and \ensuremath{\mathsf{ev}\;(\Varid{f},\Varid{k})\mathrel{=}\Varid{f}\;\Varid{k}}. Universal
property (\ref{eq:221120a}) and its diagram become
\begin{eqnarray*}
	\ensuremath{\Varid{k}\mathrel{=}\mathbf{curry}\hskip 1pt {\Varid{f}}}
	\wider\equiv
	\ensuremath{\underbrace{\mathsf{ev} \comp (\Varid{k} \times {id})}_{\mathbf{uncurry}\ {\Varid{k}}}\mathrel{=}\Varid{f}}
& &
        \myxym{
	\ensuremath{\cat{S}}
		\ar@/_0.9pc/[r]_-{\ensuremath{(\anonymous  \times \Conid{K})}}
&
	\ensuremath{\cat{S}}
		\ar@/_0.9pc/[l]_-{\ensuremath{{\anonymous }^{\Conid{K}}}}
\\
	\ensuremath{{\Conid{B}}^{\Conid{K}}}
&
	\ensuremath{{\Conid{B}}^{\Conid{K}} \times \Conid{K}}
		\ar[r]^{\ensuremath{\mathsf{ev}}}
&
	B
\\
	A
		\ar[u]^{\ensuremath{\Varid{k}\mathrel{=}\mathbf{curry}\hskip 1pt {\Varid{f}}}}
&
	\ensuremath{\Conid{A} \times \Conid{K}}
	\ar[u]^{\ensuremath{\Varid{k} \times {id}}}
	\ar[ru]_{f}
}
\end{eqnarray*}
in this adjunction. 

Associated with the Cartesian product \ensuremath{\Conid{X} \times \Conid{Y}} of two sets \ensuremath{\Conid{X}} and \ensuremath{\Conid{Y}} we have the two \emph{projections} 
\ensuremath{\p1\mathbin{:}\Conid{X} \times \Conid{Y}\to \Conid{X}} and \ensuremath{\p2\mathbin{:}\Conid{X} \times \Conid{Y}\to \Conid{Y}} which are such that \ensuremath{\p1\;(\Varid{x},\Varid{y})\mathrel{=}\Varid{x}}
and \ensuremath{\p2\;(\Varid{x},\Varid{y})\mathrel{=}\Varid{y}}. These projections are the essence of the adjunction that
follows, which captures the categorial view of \emph{pairing}.

\paragraph{Pairing: \ensuremath{\Delta \mathbin\dashv ( \times )}} In this adjunction we have
\begin{eqnarray}
	\ensuremath{\begin{lcbr}\fun L \;\Conid{X}\mathrel{=}\Delta \;\Conid{X}\mathrel{=}(\Conid{X},\Conid{X})\\\fun R \;(\Conid{X},\Conid{Y})\mathrel{=}\Conid{X} \times \Conid{Y}\\\epsilon \mathrel{=}(\p1,\p2)\end{lcbr}}
&&
	\ensuremath{\begin{lcbr}\lceil (\Varid{f},\Varid{g})\rceil\mathrel{=}\conj{\Varid{f}}{\Varid{g}}\\\lfloor \Varid{k}\rfloor\mathrel{=}(\p1 \comp \Varid{k},\p2 \comp \Varid{k})\end{lcbr}}
	\label{eq:230208d}
\end{eqnarray}
where \ensuremath{\conj{\Varid{f}}{\Varid{g}}\;\Varid{x}\mathrel{=}(\Varid{f}\;\Varid{x},\Varid{g}\;\Varid{x})} pairs up the results of two functions \ensuremath{\Varid{f}} and \ensuremath{\Varid{g}} applied
to the same input.

Note how the product in left adjoint of the previous adjunction now participates in the right
adjoint of this one, but in a more general way: it takes a pair of sets and builds their
Cartesian product.

What is the new left adjoint? It is the functor that duplicates sets, \ensuremath{\fun L \;\Conid{X}\mathrel{=}(\Conid{X},\Conid{X})}. This
means that its target category is \ensuremath{{\cat{S}}^{\mathrm{2}}}, the category of pairs of both sets and functions.
Composition in \ensuremath{{\cat{S}}^{\mathrm{2}}} is the expected \ensuremath{(\Varid{f},\Varid{g}) \comp (\Varid{h},\Varid{k})\mathrel{=}(\Varid{f} \comp \Varid{h},\Varid{g} \comp \Varid{k})}.
Using this composition rule when instantiating (\ref{eq:221120a}) for this adjunction,
we get the universal property of pairing:
\begin{eqnarray*}
\hskip -3em
\xarrayin{
	\ensuremath{\Varid{k}\mathrel{=}\conj{\Varid{f}}{\Varid{g}}}  \equiv \ensuremath{\begin{lcbr}\p1 \comp \Varid{k}\mathrel{=}\Varid{f}\\\p2 \comp \Varid{k}\mathrel{=}\Varid{g}\end{lcbr}}
}
%
\myxym{
	\ensuremath{\cat{S}}
		\ar@/_0.9pc/[r]_-{\ensuremath{\Delta }}
&
	\ensuremath{{\cat{S}}^{\mathrm{2}}}
		\ar@/_0.9pc/[l]_-{\ensuremath{( \times )}}
\\
\ensuremath{\Conid{B} \times \Conid{A}}
&
\ensuremath{(\Conid{B} \times \Conid{A},\Conid{B} \times \Conid{A})}
	\ar[r]^-{\ensuremath{(\p1,\p2)}}
&
(B,A)
\\
C
	\ar[u]^{\ensuremath{\Varid{k}\mathrel{=}\conj{\Varid{f}}{\Varid{g}}}}
&
\ensuremath{(\Conid{C},\Conid{C})}
	\ar[u]^{\ensuremath{(\Varid{k},\Varid{k})}}
	\ar[ru]_{\ensuremath{(\Varid{f},\Varid{g})}}
}
	%label{eq:200206a}
\end{eqnarray*}

Above we have seen how components of adjoint functors can shift roles, leading to new adjunctions.
Is there any adjunction in which the duplication functor \ensuremath{\Delta }, which above plays the
left adjoint role, becomes right adjoint? Yes, see our third example below.

\paragraph{Co-pairing: \ensuremath{(\mathbin{+})\mathbin\dashv \Delta }} The previous adjunction \ensuremath{\Delta \mathbin\dashv ( \times )}
gave us an explanation of what it means to run two functions at the same time,
in \emph{parallel}, for the same input. Shifting \ensuremath{\Delta } to the right of
the \ensuremath{\mathbin\dashv } symbol will provide an explanation for the dual idea of running
two functions not in parallel, but in \emph{alternation}:
\begin{eqnarray}
	\ensuremath{\begin{lcbr}\fun L \;(\Conid{X},\Conid{Y})\mathrel{=}\Conid{X}\mathbin{+}\Conid{Y}\\\fun R \;\Conid{X}\mathrel{=}\Delta \;\Conid{X}\mathrel{=}(\Conid{X},\Conid{X})\\\epsilon \mathrel{=}\nabla \mathrel{=}\alt{{id}}{{id}}\end{lcbr}}
&&
	\ensuremath{\begin{lcbr}\lceil \Varid{k}\rceil\mathrel{=}(\Varid{k} \comp i_1,\Varid{k} \comp i_2)\\\lfloor (\Varid{f},\Varid{g})\rfloor\mathrel{=}\alt{\Varid{f}}{\Varid{g}}\end{lcbr}}
	\label{eq:230207a}
\end{eqnarray}
The corresponding left adjoint builds the disjoint union \ensuremath{\Conid{X}\mathbin{+}\Conid{Y}} of a pair of sets \ensuremath{(\Conid{X},\Conid{Y})}
inhabited with \ensuremath{\Conid{X}} and \ensuremath{\Conid{Y}} data via two range-disjoint injections \ensuremath{i_1\mathbin{:}\Conid{X}\to \Conid{X}\mathbin{+}\Conid{Y}}
and \ensuremath{i_2\mathbin{:}\Conid{Y}\to \Conid{X}\mathbin{+}\Conid{Y}}. So the equation \ensuremath{i_1\;\Varid{x}\mathrel{=}i_2\;\Varid{y}} has no solution in \ensuremath{\Conid{X}\mathbin{+}\Conid{Y}} and thus
any function of type \ensuremath{\Conid{X}\mathbin{+}\Conid{Y}\to \Conid{Z}} is made of two independent components,
one of type \ensuremath{\Conid{X}\to \Conid{Z}} and the other of type \ensuremath{\Conid{Y}\to \Conid{Z}}, which run in \emph{alternation}
depending on which side of the sum the input is. Such an alternation is denoted
by \ensuremath{\alt{\Varid{f}}{\Varid{g}}} and, in symbols rather than words, we have
\ensuremath{\alt{\Varid{f}}{\Varid{g}} \comp i_1\mathrel{=}\Varid{f}} and \ensuremath{\alt{\Varid{f}}{\Varid{g}} \comp i_2\mathrel{=}\Varid{g}}.

Instantiating (\ref{eq:221120a}) with (\ref{eq:230207a}) we get the universal property of alternation: 
\begin{eqnarray}
\hskip -3em
\xarrayin{
	\ensuremath{\begin{lcbr}\Varid{f}\mathrel{=}\Varid{k} \comp i_1\\\Varid{g}\mathrel{=}\Varid{k} \comp i_2\end{lcbr}}
	\equiv \ensuremath{\Varid{k}\mathrel{=}\alt{\Varid{f}}{\Varid{g}}}
}
\vcenter{\xymatrix@C3.5ex{
	\ensuremath{{\cat{S}}^{\mathrm{2}}}
		\ar@/_0.9pc/[rr]_-{\ensuremath{(\mathbin{+})}}
&&
	\ensuremath{\cat{S}}
		\ar@/_0.9pc/[ll]_-{\ensuremath{\Delta }}
\\
	\ensuremath{(\Conid{A},\Conid{A})}
&&
	\ensuremath{\Conid{A}\mathbin{+}\Conid{A}}
	\ar[r]^-{\ensuremath{\nabla }}
&
	\ensuremath{\Conid{A}}
\\
	\ensuremath{(\Conid{C},\Conid{D})}
	\ar[u]^{\ensuremath{(\Varid{f},\Varid{g})\mathrel{=}(\Varid{k} \comp i_1,\Varid{k} \comp i_2)}}
&&
	\ensuremath{\Conid{C}\mathbin{+}\Conid{D}}
	\ar[u]^{\ensuremath{\Varid{f}\mathbin{+}\Varid{g}}}
	\ar[ru]_{\ensuremath{\Varid{k}}}
}}
	\label{eq:200206a}
\end{eqnarray}

The adjunctions given so far involve the category of sets and (total) functions that
provide a basis for so-called \emph{strong} \cite{Tu95} functional programming.
For instance, alternation gives rise to conditional computations \cite{BM97}
and so on.

More examples of adjunctions could
be given in this setting, see e.g.\ \cite{Hi13}.
We prefer to give a final example that does not fit (directly) in functional
programming practice, but is essential to reasoning about functional programs.
It links \ensuremath{\cat{S}} to another category which extends it: its objects are the same
(sets) but the morphisms become binary relations instead of functions. This
category of relations will be denoted by \ensuremath{\cat{R}} and its composition corresponds to
relational chaining.

\paragraph{Power transpose: \ensuremath{\fun J \mathbin\dashv \fun P }} This adjunction captures the view that every 
binary relation \ensuremath{\Conid{R}\mathbin{:}\Conid{A}\to \Conid{B}} (a morphism in \ensuremath{\cat{R}}) can be expressed by a set-valued
function \ensuremath{\Lambda{\Conid{R}}\mathbin{:}\Conid{A}\to \fun P \;\Conid{B}} (a morphism in \ensuremath{\cat{S}}), defined by:\footnote{
Note that we write \ensuremath{\Varid{b}\;\Conid{R}\;\Varid{a}} to express \ensuremath{(\Varid{b},\Varid{a})\;\mathbin\in \;\Conid{R}}, keeping with the tradition of using
infix notation in relational facts, e.g.\ \ensuremath{\Varid{a}\leq \Varid{b}} instead of \ensuremath{(\Varid{a},\Varid{b})\;\mathbin\in \;(\leq )} and so on.
In this vein, relation composition is expressed by \ensuremath{\Varid{b}\;(\Conid{S} \comp \Conid{R})\;\Varid{a}~\Leftrightarrow~\rcb{\exists }{\Varid{c}}{}{\Varid{b}\;\Conid{S}\;\Varid{c}\mathrel{\wedge}\Varid{c}\;\Conid{R}\;\Varid{a}}}.
}
\begin{eqnarray}
	\ensuremath{\Lambda{\Conid{R}}\;\Varid{a}\mathrel{=}\{\mskip1.5mu \Varid{b}\mid \Varid{b}\;\Conid{R}\;\Varid{a}\mskip1.5mu\}}
	\label{eq:pT}
\end{eqnarray}
Thus \ensuremath{\Varid{b}\;\mathbin\in \;\Lambda{\Conid{R}}\;\Varid{a}~\Leftrightarrow~\Varid{b}\;\Conid{R}\;\Varid{a}},
which in relational pointwise notation (the ``internal language" of \ensuremath{\cat{R}}) is written
\ensuremath{\mathbin\in  \comp \Lambda{\Conid{R}}\mathrel{=}\Conid{R}}, where \ensuremath{\mathbin\in \mathbin{:}\Conid{A}\leftarrow \fun P \;\Conid{A}} is the set \emph{membership} relation.
Thus membership ``cancels`` the power-transpose \ensuremath{\Lambda{\cdot }}:
\begin{eqnarray}
	\myxym{
		\ensuremath{\cat{R}}
			&
			&
		\ensuremath{\cat{S}}
			\\
			\ensuremath{\Conid{A}\to \Conid{X}}
			\ar@/^0.9pc/[rr]^{\ensuremath{\Lambda{\cdot }}}
		&
			\iso
			&
			\ensuremath{\Conid{A}\to \fun P \;\Conid{X}}
			\ar@/^0.9pc/[ll]^{\ensuremath{(\mathbin\in  \comp )}}
	}
%label{eq:170429c}
\end{eqnarray}
We write \ensuremath{\Conid{A}} for \ensuremath{\fun L \;\Conid{A}} because the lower adjoint is the identity on objects. It just converts 
a function in \ensuremath{\cat{S}} to the corresponding relation in \ensuremath{\cat{R}}\footnote{
Interestingly, the usual presentation \ensuremath{\Varid{y}\mathrel{=}\Varid{f}\;(\Varid{x})} of functions in maths
textbooks is relational, not strictly functional.}, cf:
%|DC := SC| (sets + functions) and |CC := RC| (sets + relations)
\begin{eqnarray}
\xarrayin{
	\ensuremath{\begin{lcbr}\fun J \;\Conid{X}\mathrel{=}\Conid{X}\\\Varid{y}\;(\fun J \;\Varid{k})\;\Varid{x}~\Leftrightarrow~\Varid{y}\mathrel{=}\Varid{k}\;\Varid{x}\\\fun R \;\Conid{X}\mathrel{=}\fun P \;\Conid{X}\mathrel{=}\{\mskip1.5mu \Conid{S}\mid \Conid{S} \subseteq \Conid{X}\mskip1.5mu\}\end{lcbr}}
&&
	\ensuremath{\begin{lcbr}\epsilon \mathrel{=}(\mathbin\in )\\\lceil \Conid{R}\rceil\mathrel{=}\Lambda{\Conid{R}}\\\Varid{y}\;\lfloor \Varid{k}\rfloor\;\Varid{x}\mathrel{=}\Varid{y}\;\mathbin\in \;(\Varid{k}\;\Varid{x})\end{lcbr}}
}
	\label{eq:230209a}
\end{eqnarray}
Altogether, the adjunction expresses the universal property of power-transposition:
\begin{eqnarray}
	\ensuremath{\Varid{k}\mathrel{=}\Lambda{\Conid{R}}}
	\wider\equiv
	\ensuremath{\underbrace{\mathbin\in  \comp \Varid{k}}_{\lfloor \Varid{k}\rfloor}\mathrel{=}\Conid{R}}
& \rule{1em}{0pt}&
        \myxym{
	\ensuremath{\cat{S}}
		\ar@/_0.8pc/[r]_-{\ensuremath{\fun J }}
&
	\ensuremath{\cat{R}}
		\ar@/_0.8pc/[l]_-{\ensuremath{\fun P }}
\\
	\ensuremath{\fun P \;\Conid{B}}
&
	\ensuremath{\fun P \;\Conid{B}}
		\ar[r]^{\ensuremath{\mathbin\in }}
&
	B
\\
	A
		\ar[u]^{\ensuremath{\Varid{k}\mathrel{=}\Lambda{\Conid{R}}}}
&
	\ensuremath{\Conid{A}}
	\ar[u]^{\ensuremath{\fun J \;\Varid{k}}}
	\ar[ru]_{R}
}
	\label{eq:230301c}
\end{eqnarray}
This adjunction will prove specially useful later on where dealing with recursion 
in presence of inductive data types.

\section{Properties}
The main advantage of a unifying concept such as that of an adjunction is that one
can express the rich theory of (\ref{eq:221120a},\ref{eq:230206b}) only once, covering
all the particular instances by construction. Several properties that are easy to derive
as corollaries of (\ref{eq:221120a},\ref{eq:230206b}) are given in the appendix.
The terminology is inspired by \cite{BM97}, among other references that
use similar names, see e.g.\ \cite{Ol05}.

To illustrate their application, let us see how the actions of the functors
involved in an adjunction can be recovered from the adjunction itself, laws
(\ref{eq:230208c}) and (\ref{eq:230208b}). Taking \ensuremath{\Delta \mathbin\dashv ( \times )} as example,
let us use (\ref{eq:230208c}), \ensuremath{\fun R \;\Varid{h}\mathrel{=}\lceil \Varid{h} \comp \epsilon \rceil}, to find a definition for
\ensuremath{\Varid{f} \times \Varid{g}}, which is \ensuremath{\fun R \;(\Varid{f},\Varid{g})}. Since \ensuremath{\epsilon \mathrel{=}(\p1,\p2)}, then \ensuremath{(\Varid{f},\Varid{g}) \comp \epsilon \mathrel{=}(\Varid{f} \comp \p1,\Varid{g} \comp \p2)}.
Since \ensuremath{\lceil (\Varid{x},\Varid{y})\rceil\mathrel{=}\conj{\Varid{x}}{\Varid{y}}}, we finally get
\begin{eqnarray}
	\ensuremath{\Varid{f} \times \Varid{g}\mathrel{=}\conj{\Varid{f} \comp \p1}{\Varid{g} \comp \p2}}
\end{eqnarray}
Similarly, for \ensuremath{\fun J \mathbin\dashv \fun P }, by (\ref{eq:230208c}) we get 
\begin{eqnarray}
	\ensuremath{\fun P \;\Conid{R}\mathrel{=}\Lambda{(\Conid{R} \comp (\mathbin\in ))}}
	\label{eq:230310a}
\end{eqnarray}
that is,  \ensuremath{\fun P \;\Conid{R}\;\Conid{X}\mathrel{=}\{\mskip1.5mu \Varid{b}\mid \Varid{b}\;\Conid{R}\;\Varid{a}\mathrel{\wedge}\Varid{a}\;\mathbin\in \;\Conid{X}\mskip1.5mu\}}.\footnote{Note that \ensuremath{\fun P } is not a relational functor (in \ensuremath{\cat{R}}) but rather another way of expressing relations by functions in \ensuremath{\cat{S}}. It is often referred to as the \emph{existential image functor} \cite{BM97}. Interestingly, (\ref{eq:230310a}) captures the way the
so-called \emph{navigation style} of Alloy \cite{Jac12} works, enabling an (essentially) functional
execution of its relational core.}

Now let us calculate \ensuremath{\Varid{f}\mathbin{+}\Varid{g}} as in the left-adjoint of \ensuremath{(\mathbin{+})\mathbin\dashv \Delta } (\ref{eq:230207a}) using
(\ref{eq:230208b}), \ensuremath{\fun L \;\Varid{g}\mathrel{=}\lfloor \eta  \comp \Varid{g}\rfloor}. In the same way as above,
\ensuremath{\Varid{f}\mathbin{+}\Varid{g}\mathrel{=}\fun L \;(\Varid{f},\Varid{g})\mathrel{=}\lfloor \eta  \comp (\Varid{f},\Varid{g})\rfloor}. Since \ensuremath{\eta \mathrel{=}\lceil {id}\rceil} (\ref{eq:230208e}),
i.e.\ \ensuremath{\eta \mathrel{=}(i_1,i_2)} by (\ref{eq:230207a}), we get \ensuremath{\Varid{f}\mathbin{+}\Varid{g}\mathrel{=}\lfloor i_1 \comp \Varid{f},i_2 \comp \Varid{g}\rfloor}
and finally:
\begin{eqnarray}
	\ensuremath{\Varid{f}\mathbin{+}\Varid{g}\mathrel{=}\alt{i_1 \comp \Varid{f}}{i_2 \comp \Varid{g}}}
\end{eqnarray}

All such properties and those of the appendix involve only one adjunction at a time.
Perhaps more interesting are those that arise
by composing adjunctions, to be seen shortly.
Before this, we address a topic that is very relevant to programming and bears a strong
link to adjunctions.

\section{Monads}

The categorial view of functional programming had a big ``push forward" when the concept of a 
\emph{monad} was incorporated in languages such as e.g.\ Haskell, making it possible to have purely 
functional implementations of computations that were regarded as non-functional before \cite{GH11}.

It turns out that monads arise from adjunctions.
Put simply, for every adjunction \ensuremath{\fun L \mathbin\dashv \fun R }, the composition \ensuremath{\fun M \mathrel{=}\fun R  \comp \fun L }
is a monad, meaning that \ensuremath{\fun M } comes equipped with natural transformations \ensuremath{\eta } and \ensuremath{\mu},
as in
\begin{eqnarray*}
	\ensuremath{\xymatrix{\Conid{A}\ar[r]^{\eta } & \fun M \Conid{A} & \fun M ^2 \Conid{A} \ar[l]_{\mu}}}
\end{eqnarray*}
such that
\begin{eqnarray}
\start
	\ensuremath{\mu \comp \eta \mathrel{=}{id}\mathrel{=}\mu \comp \fun M \;\eta }
	\label{eq:mon-mul}
\more
	\ensuremath{\mu \comp \mu\mathrel{=}\mu \comp \fun M \;\mu}
	\label{eq:mon-unit}
\end{eqnarray}
hold. The so-called \emph{multiplication} (\ensuremath{\mu}) and \emph{unit} (\ensuremath{\eta }) of monad \ensuremath{\fun M } arise as follows:
\begin{eqnarray}
\start
	\ensuremath{\eta \mathrel{=}\lceil {id}\rceil}
	\label{eq:230301a}
\more
	\ensuremath{\mu\mathrel{=}\fun R \;\epsilon }
	\label{eq:230301b}
\end{eqnarray}
%
Proofs that (\ref{eq:mon-mul},\ref{eq:mon-unit})
arise from definitions (\ref{eq:230301a},\ref{eq:230301b})
and adjunction properties can be found in the appendix.

As an example, recall adjunction \ensuremath{\fun J \mathbin\dashv \fun P } (\ref{eq:230209a}).
Because \ensuremath{\fun J } is the identity on objects, it turns out that \ensuremath{\fun P }, the powerset functor,
is a monad.
By (\ref{eq:230301a}) and (\ref{eq:pT}), its unit is \ensuremath{\eta \;\Varid{a}\mathrel{=}\{\mskip1.5mu \Varid{a}\mskip1.5mu\}}
By (\ref{eq:230301a}) and (\ref{eq:230208c}), its multiplication \ensuremath{\mu\mathrel{=}\Lambda{(\mathbin\in ) \comp (\mathbin\in )}}
is distributed union,
\begin{eqnarray*}
\ensuremath{\mu\;\Conid{S}\mathrel{=}\{\mskip1.5mu \Varid{a}\mid \rcb{\exists }{\Varid{x}}{\Varid{a}\;\mathbin\in \;\Varid{x}}{\Varid{x}\;\mathbin\in \;\Conid{S}}\mskip1.5mu\}}
\end{eqnarray*}
where \ensuremath{\Conid{S}} is a set of sets.

In the interest of programming, one may wonder whether, in this powerset adjunction 
\ensuremath{\fun J \mathbin\dashv \fun P } (\ref{eq:230301c}), one can interpret relational expressions in \ensuremath{\cat{R}} by set-valued
functions \ensuremath{\cat{S}}. In particular, one may be interested in implementing relational composition
\ensuremath{\Conid{R} \comp \Conid{S}} by somewhow running their set-valued function counterparts \ensuremath{\Lambda{\Conid{R}}} and \ensuremath{\Lambda{\Conid{S}}} as
functional programs.

This is possible\footnote{This is the way relational specifications are handled
in \cite{BM97}, for instance.} as an instance of so-called \emph{monadic}
(or \emph{Kleisli}) composition, defined for any adjunction \ensuremath{\fun L \mathbin\dashv \fun R } as follows,
\begin{eqnarray}
\start \ensuremath{\Varid{f}\kcomp\Varid{g}\mathrel{=}\mu \comp \fun M \;\Varid{f} \comp \Varid{g}}
	\label{eq:230301d}
\end{eqnarray}
where \ensuremath{\fun M \mathrel{=}\fun L  \comp \fun R }. One has
\begin{eqnarray}
\start	\ensuremath{\lceil \Varid{f} \comp \Varid{g}\rceil\mathrel{=}\lceil \Varid{f}\rceil\kcomp\lceil \Varid{g}\rceil}
	\label{eq:230301e}
\end{eqnarray}
as proved in the appendix.

As a well-known example, Kleisli composition enables one to sequence state-based
computations in a purely functional, elegant way using the so-called \emph{state
monad} which arises from the \ensuremath{(\anonymous  \times \Conid{K})\mathbin\dashv ({\anonymous }^{\Conid{K}})} adjunction (\ref{eq:230208h}).

\section{Composing adjunctions}
Above we saw the example of a functor (\ensuremath{\Delta }) being at the same
time a left adjoint and a right adjoint of a different adjunction. Let us
study the situation in which two such adjunctions are chained: \ensuremath{\fun L \mathbin\dashv \fun M \mathbin\dashv \fun R }.

A quick inspection of how a morphism \ensuremath{\rarrow{\fun L \;\Conid{A}}{\Varid{k}}{\fun R \;\Conid{B}}}
can be transformed unveils the composite adjunction \ensuremath{(\fun M \;\fun L )\mathbin\dashv (\fun M \;\fun R )}:\footnote{
In the sequel we adopt the usual shortcut for functor composition,
e.g.\ \ensuremath{\fun M \;\fun L } instead of \ensuremath{\fun M  \comp \fun L } and so on.}
\begin{eqnarray*}
\start
	\ensuremath{\fun M \;\fun L \;\Conid{A}\to \Conid{B}}
%
\just\iso{ \ensuremath{\fun M \mathbin\dashv \fun R } }
%
	\ensuremath{\fun L \;\Conid{A}\to \fun R \;\Conid{B}}
%
\just\iso{ \ensuremath{\fun L \mathbin\dashv \fun M } }
%
	\ensuremath{\Conid{A}\to \fun M \;\fun R \;\Conid{B}}
%
\end{eqnarray*}
Given \ensuremath{\rarrow{\fun L \;\Conid{A}}{\Varid{k}}{\fun R \;\Conid{B}}},
\ensuremath{\Varid{k}\mathrel{=}\lceil \Varid{f}\rceil_{\fun R }} holds for exactly one \ensuremath{\rarrow{\fun M \;\fun L \;\Conid{A}}{\Varid{f}}{\Conid{B}}}.
On the other hand, \ensuremath{\Varid{k}\mathrel{=}\lfloor \Varid{g}\rfloor_{\fun L }} holds for exactly one \ensuremath{\rarrow{\Conid{A}}{\Varid{g}}{\fun M \;\fun R \;\Conid{B}}}.
So the \emph{exchange law}
\begin{eqnarray}
	\ensuremath{\lceil \Varid{f}\rceil_{\fun R }\mathrel{=}\lfloor \Varid{g}\rfloor_{\fun L }}
\end{eqnarray}
holds for such
	\ensuremath{\rarrow{\fun M \;\fun L \;\Conid{A}}{\Varid{f}}{\Conid{B}}}
and
	\ensuremath{\rarrow{\Conid{A}}{\Varid{g}}{\fun M \;\fun R \;\Conid{B}}}.

\paragraph{The product-coproduct ``mix"}
Let us see an instance of this exchange rule, that which emerges from
composing \ensuremath{(\mathbin{+})\mathbin\dashv \Delta \mathbin\dashv ( \times )} and is dear to algebra of programming practitioners
\cite{BM97}: in this case,
\ensuremath{\rarrow{\fun M \;\fun L \;\Conid{A}}{\Varid{f}}{\Conid{B}}} is of type \ensuremath{\Delta \;(\mathbin{+})\;(\Conid{A},\Conid{C})\to (\Conid{B},\Conid{D})}, % |rarrow (vDelta (+) (A,C)) () ((B,D))|,
\begin{eqnarray*}
	\ensuremath{\Varid{f}\mathrel{=}\rarrow{(\Conid{A}\mathbin{+}\Conid{C},\Conid{A}\mathbin{+}\Conid{C})}{(\Varid{m},\Varid{n})}{(\Conid{B},\Conid{D})}}
\end{eqnarray*}
and \ensuremath{\rarrow{\Conid{A}}{\Varid{g}}{\fun M \;\fun R \;\Conid{B}}} is of type \ensuremath{(\Conid{A},\Conid{C})\to \Delta \;( \times )\;(\Conid{B},\Conid{D})}:
\begin{eqnarray}
	\ensuremath{\Varid{g}\mathrel{=}\rarrow{(\Conid{A},\Conid{C})}{(\Varid{i},\Varid{j})}{(\Conid{B} \times \Conid{D},\Conid{B} \times \Conid{D})}}
	\label{eq:230207b}
\end{eqnarray}
So,
	\ensuremath{\lceil \Varid{f}\rceil_{\fun R }\mathrel{=}\lfloor \Varid{g}\rfloor_{\fun L }}
  becomes
	\ensuremath{\conj{\Varid{m}}{\Varid{n}}\mathrel{=}\alt{\Varid{i}}{\Varid{j}}},
which we want to solve next.
%paragraph{Solving |split m n = either i j|}
Looking at (\ref{eq:230207b}), we have \ensuremath{\Varid{i}\mathrel{=}\conj{\Varid{h}}{\Varid{k}}} and \ensuremath{\Varid{j}\mathrel{=}\conj{\Varid{p}}{\Varid{q}}} for some \ensuremath{\Varid{h},\Varid{k},\Varid{p},\Varid{q}}.
Then:
\begin{eqnarray*}
\start
	\ensuremath{\conj{\Varid{m}}{\Varid{n}}\mathrel{=}\alt{\conj{\Varid{h}}{\Varid{k}}}{\conj{\Varid{p}}{\Varid{q}}}}
%
\just\equiv{ \ensuremath{(\mathbin{+})\mathbin\dashv \Delta } }
%
	\ensuremath{\begin{lcbr}(\Varid{m},\Varid{n}) \comp (i_1,i_1)\mathrel{=}(\Varid{h},\Varid{k})\\(\Varid{m},\Varid{n}) \comp (i_2,i_2)\mathrel{=}(\Varid{p},\Varid{q})\end{lcbr}}
%
\just\equiv{ re-arranging }
%
	\ensuremath{\begin{lcbr}(\Varid{m},\Varid{m}) \comp (i_1,i_2)\mathrel{=}(\Varid{h},\Varid{p})\\(\Varid{n},\Varid{n}) \comp (i_1,i_2)\mathrel{=}(\Varid{k},\Varid{q})\end{lcbr}}
	\eqnnewpage
%
\just\equiv{ \ensuremath{\Delta \mathbin\dashv ( \times )} }
%
	\ensuremath{\begin{lcbr}\Varid{m}\mathrel{=}\alt{\Varid{h}}{\Varid{p}}\\\Varid{n}\mathrel{=}\alt{\Varid{k}}{\Varid{q}}\end{lcbr}}
\end{eqnarray*}

\begin{wrapfigure}[8]{l}{12.5em}
\(
\xymatrix{
	A
		\ar[r]^{i_1}
		\ar[d]_{\ensuremath{\Varid{h}}}
		\ar[drr]_{\ensuremath{\Varid{p}}}
&
	A+C
&
	C
		\ar[dll]_{\ensuremath{\Varid{k}}}
		\ar[d]^{\ensuremath{\Varid{q}}}
		\ar[l]_{i_2}
\\
	B
&
	B\times D
		\ar[l]^{\p1}
		\ar[r]_{\p2}
&
	D
}
\)
\end{wrapfigure}
The composite adjunction \ensuremath{(\mathbin{+})\mathbin\dashv \Delta \mathbin\dashv ( \times )} therefore yields the
well-known \emph{exchange law} useful in handling functions that input
sums and output products:
\begin{eqnarray}
	\ensuremath{\conj{\alt{\Varid{h}}{\Varid{p}}}{\alt{\Varid{k}}{\Varid{q}}}\mathrel{=}\alt{\conj{\Varid{h}}{\Varid{k}}}{\conj{\Varid{p}}{\Varid{q}}}}
	\label{eq:exLaw}
\end{eqnarray}
As will be seen later, this law will play an important role when dealing with mutual recursion.

\paragraph{\ensuremath{(\mathbin{+})\mathbin\dashv \Delta } meets \ensuremath{\fun L \mathbin\dashv \fun R }}
As we have seen, adjunction (\ref{eq:200206a}) brings with it
the possibility of expressing alternative computations. One wonders whether such 
possibility can be extended ``across'' other adjunctions via the composition
\begin{eqnarray*}
\myxym{
	\ensuremath{{\cat{S}}^{\mathrm{2}}}
		\ar@/_1.0pc/[r]_-{\ensuremath{(\mathbin{+})}}
&
	\ensuremath{\cat{S}}
		\ar@/_1.0pc/[l]_-{\ensuremath{\Delta }}
		\ar@/_1.0pc/[r]_-{\ensuremath{\fun L }}
&
	\ensuremath{\cat{C}}
		\ar@/_1.0pc/[l]_-{\ensuremath{\fun R }}
}
& 
	\hbox{that is}
&
\vcenter{\xymatrix@C=3.5ex{
	\ensuremath{(\fun R \;\Conid{A},\fun R \;\Conid{A})}
&&
	\ensuremath{\fun R \;\Conid{A}\mathbin{+}\fun R \;\Conid{A}}
	\ar[r]^-{\ensuremath{\nabla }}
&
	\ensuremath{\fun R \;\Conid{A}}
\\
	\ensuremath{(\Conid{C},\Conid{D})}
	\ar[u]^{\ensuremath{(\lceil \Varid{f}\rceil,\lceil \Varid{g}\rceil)}}
&&
	\ensuremath{\Conid{C}\mathbin{+}\Conid{D}}
	\ar[u]^{\ensuremath{\lceil \Varid{f}\rceil\mathbin{+}\lceil \Varid{g}\rceil}}
	\ar[ru]_{\ensuremath{\lceil \Varid{k}\rceil}}
}}
\end{eqnarray*}
meaning:
\begin{eqnarray}
	\ensuremath{\begin{lcbr}\lceil \Varid{f}\rceil\mathrel{=}\lceil \Varid{k}\rceil \comp i_1\\\lceil \Varid{g}\rceil\mathrel{=}\lceil \Varid{k}\rceil \comp i_2\end{lcbr}}
&
	\equiv
&
	\ensuremath{\lceil \Varid{k}\rceil\mathrel{=}\alt{\lceil \Varid{f}\rceil}{\lceil \Varid{g}\rceil}}
	\label{eq:230302c}
\end{eqnarray}
Clearly, the right side of (\ref{eq:230302c}) can be written \ensuremath{\Varid{k}\mathrel{=}\lfloor \alt{\lceil \Varid{f}\rceil}{\lceil \Varid{g}\rceil}\rfloor}.
Concerning the left side:  
\begin{eqnarray*}
\start%
	\ensuremath{\begin{lcbr}\lceil \Varid{k}\rceil \comp i_1\mathrel{=}\lceil \Varid{f}\rceil\\\lceil \Varid{k}\rceil \comp i_2\mathrel{=}\lceil \Varid{g}\rceil\end{lcbr}}
%
\just\equiv{ fusion (\ref{eq:200204b}) and isomorphism (\ref{eq:230208a}) (twice) }
%
	\ensuremath{\begin{lcbr}\Varid{k} \comp \fun L \;i_1\mathrel{=}\Varid{f}\\\Varid{k} \comp \fun L \;i_2\mathrel{=}\Varid{g}\end{lcbr}}
\end{eqnarray*}
In summary, (\ref{eq:230302c}) re-writes to the universal property
\begin{eqnarray}
	\ensuremath{\Varid{k}\mathrel{=}\lfloor \alt{\lceil \Varid{f}\rceil}{\lceil \Varid{g}\rceil}\rfloor}
&
	\equiv
&
	\ensuremath{\begin{lcbr}\Varid{k} \comp \fun L \;i_1\mathrel{=}\Varid{f}\\\Varid{k} \comp \fun L \;i_2\mathrel{=}\Varid{g}\end{lcbr}}
	\label{eq:230303a}
\end{eqnarray}
that is, we have coproducts in \ensuremath{\cat{C}} induced by the lower adjoint \ensuremath{\fun L }.

\paragraph{Relational coproducts} Let us inspect (\ref{eq:230303a}) 
for \ensuremath{\fun L \mathbin\dashv \fun R \mathbin{:=}\fun J \mathbin\dashv \fun P } (\ref{eq:230209a}).
In this case, \ensuremath{\lfloor \Varid{k}\rfloor\mathrel{=}(\mathbin\in ) \comp \Varid{k}} and \ensuremath{\fun L \;i_1\mathrel{=}\fun J \;i_1} is injection \ensuremath{i_1} regarded
as a relation, \ensuremath{\Varid{y}\;i_1\;\Varid{x}~\Leftrightarrow~\Varid{y}\mathrel{=}i_1\;\Varid{x}}, which is usually written \ensuremath{i_1} (similarly for \ensuremath{i_2}):
\begin{eqnarray}
	\ensuremath{\Conid{X}\mathrel{=}\underbrace{(\mathbin\in ) \comp \alt{\Lambda{\Conid{R}}}{\Lambda{\Conid{S}}}}_{\alt{\Conid{R}}{\Conid{S}}}}
&
	\equiv
&
	\ensuremath{\begin{lcbr}\Conid{X} \comp i_1\mathrel{=}\Conid{R}\\\Conid{X} \comp i_2\mathrel{=}\Conid{S}\end{lcbr}}
	\label{eq:230305a}
\end{eqnarray}
Thus relational coproducts are born, in which \emph{alternation} is still denoted by \ensuremath{\alt{\Conid{R}}{\Conid{S}}},
as in the functional case, since types always tell us whether we are in \ensuremath{\cat{S}} or \ensuremath{\cat{R}}.

As another example, this time concerning \ensuremath{(\anonymous  \times \Conid{K})\mathbin\dashv ({\anonymous }^{\Conid{K}})} (\ref{eq:230208h}), we get
\begin{eqnarray*}
	\ensuremath{\Varid{k}\mathrel{=}\mathbf{uncurry}\ {\alt{\mathbf{curry}\hskip 1pt {\Varid{f}}}{\mathbf{curry}\hskip 1pt {\Varid{g}}}}}
&
	\equiv
&
	\ensuremath{\begin{lcbr}\Varid{k} \comp (i_1 \times {id})\mathrel{=}\Varid{f}\\\Varid{k} \comp (i_2 \times {id})\mathrel{=}\Varid{g}\end{lcbr}}
\end{eqnarray*}
and so on for other \ensuremath{\fun L \mathbin\dashv \fun R }.

\section{More about \ensuremath{\cat{R}}}
We have just seen that the category of relations \ensuremath{\cat{R}} has coproducts.
In fact, it has a much richer structure which stems from the powerset construction in \ensuremath{\cat{S}}
(\ref{eq:230209a}). The fact that powersets are ordered by set inclusion induces a
partial order on relations in \ensuremath{\cat{R}} easy to define:\footnote{The fact that we use the same symbol
to order relations and order powersets should not be a problem, as types disambiguate its use.}
\begin{eqnarray}
\start
	\ensuremath{\Conid{R}\; \subseteq \;\Conid{S}} \wider\equiv \ensuremath{\rcb{\forall}{\Varid{a}}{}{{(\Lambda{\Conid{R}}\;\Varid{a})}\subseteq{(\Lambda{\Conid{S}}\;\Varid{a})}}}
	\label{eq:230303e}
%
\end{eqnarray}
Put in another way, every homset \ensuremath{\cat{R}\;(\Conid{A},\Conid{B})} is partially ordered and we say
that \ensuremath{\cat{R}} is \emph{order-enriched}.

This enrichment is actually ``richer": (\ref{eq:230303e})
carries with it a complete Boolean algebra and therefore relation union (\ensuremath{{\Conid{R}}\mathbin\cup{\Conid{S}}}) and intersection
(\ensuremath{{\Conid{R}}\mathbin\cap{\Conid{S}}}) are defined within the same homset \ensuremath{\cat{R}\;(\Conid{A},\Conid{B})} by construction, whose least element is
usually denoted by \ensuremath{\bot } and the largest by \ensuremath{\top }.

The other interesting structural property is
that homsets \ensuremath{\cat{R}\;(\Conid{A},\Conid{B})} and \ensuremath{\cat{R}\;(\Conid{B},\Conid{A})} are isomorphic, that is, \ensuremath{\cat{R}} is \emph{self dual}.
For each \ensuremath{\Conid{R}\;\mathbin\in \;\cat{R}\;(\Conid{A},\Conid{B})}, the corresponding relation in \ensuremath{\cat{R}\;(\Conid{B},\Conid{A})} is denoted by
\ensuremath{\conv{\Conid{R}}} (the \emph{converse} of \ensuremath{\Conid{R}}) and we have:\footnote{ Self-duality in \ensuremath{\cat{R}} arise from isomorphism \ensuremath{\fun P \;\Conid{X}\cong{\mathrm{2}}^{\Conid{X}}} (``sets are predicates'') in \ensuremath{\cat{S}}.  By this and uncurrying, \ensuremath{\Conid{A}\to \fun P \;\Conid{B}\cong{\mathrm{2}}^{\Conid{A} \times \Conid{B}}}.  Since \ensuremath{\Conid{A} \times \Conid{B}\cong\Conid{B} \times \Conid{A}}, we can go in reverse order obtaining \ensuremath{\Conid{B}\to \fun P \;\Conid{A}}, etc.}
\begin{eqnarray*}
\ensuremath{\Varid{b}\;\Conid{R}\;\Varid{a}~\Leftrightarrow~\Varid{a}\;\conv{\Conid{R}}\;\Varid{b}}
\end{eqnarray*}
This is a major advantage of \ensuremath{\cat{R}} when compared to \ensuremath{\cat{S}}, where only isomorphisms can be
reversed. Moreover, it turns out that converses of functions play a major role in \ensuremath{\cat{R}}.
In particular, the useful rule
\begin{eqnarray}
	\ensuremath{\Varid{b}\;(\conv{\Varid{f}} \comp \Conid{R} \comp \Varid{g})\;\Varid{a}}
&
\equiv
&
	\ensuremath{(\Varid{f}\;\Varid{b})\;\Conid{R}\;(\Varid{g}\;\Varid{a})}
	\label{eq:040120c} %-- guardanapo
\end{eqnarray}
holds, for suitably typed functions \ensuremath{\Varid{f}} and \ensuremath{\Varid{g}} and relation \ensuremath{\Conid{R}}.\footnote{Following
a widely adopted convention \cite{BM97} to save text, we denote ``relations
that are functions" by lowercase letters.}
The use of this rule can be appreciated by applying it to both sides a Galois connection,
recall (\ref{eq:230305b}):
term \ensuremath{\Varid{f}\;\Varid{a}\leq \Varid{x}} becomes \ensuremath{\Varid{a}\;(\conv{\Varid{f}} \comp (\leq ))\;\Varid{x}} and
term \ensuremath{\Varid{a}\sqsubseteq \Varid{g}\;\Varid{x}} becomes \ensuremath{\Varid{a}\;((\sqsubseteq ) \comp \Varid{g})\;\Varid{b}}.
That is, the logical equivalence of a GC (\ref{eq:230305b}) becomes the relational \emph{equality}:
\begin{eqnarray}
\start	\ensuremath{\conv{\Varid{f}} \comp (\leq )\mathrel{=}(\sqsubseteq ) \comp \Varid{g}}
	\label{eq:040122b}
\end{eqnarray}

This version of (\ref{eq:230305b}) is said to be \emph{pointfree} in the sense that is dispenses
with variables, or \emph{points}, \ensuremath{\Varid{a}} and \ensuremath{\Varid{x}}.\footnote{
This is the way (in \ensuremath{\cat{R}}) Galois connections are handled in e.g.\ \cite{BB04,MO11}.}
The question arises: how does one describe the preorders \ensuremath{(\leq )} and \ensuremath{(\sqsubseteq )}
at such a \emph{pointfree} level? This is related to a previous question:
how does a recursive program like e.g.\ \ensuremath{\mathsf{take}} gets generated from an equality
like (\ref{eq:040122b})?
With no further delay we need to bring recursion into our framework of reasoning. 

\section{Recursion comes in}

\begin{wrapfigure}[7]{r}{12.5em}
\(
\xymatrix{
	\ensuremath{\Varid{a}}
 		\ar[d]_{\ensuremath{\Varid{f}}}
&
	\ensuremath{\Conid{A}}
 		\ar[d]_{\ensuremath{\Varid{f}}}
&
	\ensuremath{\fun F \;\Conid{A}}
 		\ar[l]_{\ensuremath{\Varid{a}}}
 		\ar[d]^{\ensuremath{\fun F \;\Varid{f}}}
\\
	\ensuremath{\Varid{b}}
&
	\ensuremath{\Conid{B}}
&
	\ensuremath{\fun F \;\Conid{B}}
 		\ar[l]^{\ensuremath{\Varid{b}}}
}
\)
\end{wrapfigure}
For a given functor \ensuremath{\fun F }, any morphism \ensuremath{\larrow{\fun F \;\Conid{A}}{\Varid{a}}{\Conid{A}}} is said to be a \ensuremath{\fun F }-algebra,
where \ensuremath{\Conid{A}} is said to be the \emph{carrier} of the algebra.
\ensuremath{\fun F }-algebras form a category provided its morphisms \ensuremath{\rarrow{\Varid{a}}{\Varid{f}}{\Varid{b}}} satisfy a particular property,
\begin{eqnarray}
	\ensuremath{\Varid{f} \comp \Varid{a}\mathrel{=}\Varid{b} \comp \fun F \;\Varid{f}}
	\label{eq:230207c}
\end{eqnarray}
captured in the diagram aside. This states that \ensuremath{\Conid{A}}-objects are mapped to \ensuremath{\Conid{B}}-objects in a structural way:\footnote{Morphisms with this structure are usually referred to as \emph{homomorphisms}.}
Think for instance of \ensuremath{\Conid{A}\mathrel{=}\Conid{B}\mathrel{=}\N_0} being the natural numbers,
\ensuremath{\fun F \;\Conid{X}\mathrel{=}\Conid{X} \times \Conid{X}}, \ensuremath{\Varid{a}\;(\Varid{n},\Varid{m})\mathrel{=}\Varid{n}\mathbin{+}\Varid{m}}, \ensuremath{\Varid{b}\;(\Varid{x},\Varid{y})\mathrel{=}\Varid{x} \times \Varid{y}} and \ensuremath{\Varid{f}\;\Varid{x}\mathrel{=}{\Varid{c}}^{\Varid{x}}}, for some
fixed \ensuremath{\Varid{c}}. Then (\ref{eq:230207c}) becomes \ensuremath{\Varid{f}\;(\Varid{a}\;(\Varid{n},\Varid{m})\mathrel{=}\Varid{b}\;(\Varid{f}\;\Varid{n},\Varid{f}\;\Varid{m})}, then 
\ensuremath{\Varid{f}\;(\Varid{n}\mathbin{+}\Varid{m})\mathrel{=}(\Varid{f}\;\Varid{n}) \times (\Varid{f}\;\Varid{m})} and finally \ensuremath{{\Varid{c}}^{\Varid{n}\mathbin{+}\Varid{m}}\mathrel{=}{\Varid{c}}^{\Varid{n}} \times {\Varid{c}}^{\Varid{m}}}, 
which is true. Thus \ensuremath{\rarrow{(\mathbin{+})}{{\Varid{c}}^{\anonymous }}{( \times )}} is a \ensuremath{\fun F }-homomorphism.

Some situations arise in which \ensuremath{\Varid{a}} is such that, for every \ensuremath{\Varid{b}}, \ensuremath{\Varid{f}} is unique.
In such cases, \ensuremath{\Varid{a}} is an isomorphism\footnote{This is known as the \emph{Lambek lemma}
\cite{BM97}.}, that is, there exists some morphism \ensuremath{\conv{\Varid{a}}} such that
\ensuremath{\conv{\Varid{a}} \comp \Varid{a}\mathrel{=}{id}} and \ensuremath{\Varid{a} \comp \conv{\Varid{a}}\mathrel{=}{id}}. Such algebras \ensuremath{\Varid{a}} are said to be \emph{initial}
and usually denoted by \ensuremath{\mathsf{in}_{\fun T}}, assuming their carrier set denoted by \ensuremath{\fun T }, i.e.\
\ensuremath{\rarrow{\fun F \;\fun T }{\mathsf{in}_{\fun T}}{\fun T }}. The uniqueness of \ensuremath{\Varid{f}} wrt.\ \ensuremath{\Varid{b}} is written \ensuremath{\Varid{f}\mathrel{=}\llparenthesis\,\Varid{b}\,\rrparenthesis} and
we have the universal property: 
\begin{eqnarray*}
	\ensuremath{\Varid{k}\mathrel{=}\llparenthesis\,\Varid{b}\,\rrparenthesis~\Leftrightarrow~\Varid{k} \comp \mathsf{in}_{\fun T}\mathrel{=}\Varid{b} \comp \fun F \;\Varid{k}}
\end{eqnarray*}
Due to the tight relationship between \ensuremath{\fun T }, \ensuremath{\mathsf{in}_{\fun T}} and \ensuremath{\fun F }, it is common to write 
\ensuremath{\muF } instead of \ensuremath{\fun T }:
% Initial algebra |larrow (fF muF) inT muF| such that morphism |rarrow inT (cata a) a| is unique:
\begin{eqnarray}
	\ensuremath{\Varid{k}\mathrel{=}\llparenthesis\,\Varid{b}\,\rrparenthesis~\Leftrightarrow~\Varid{k} \comp \mathsf{in}_{\fun T}\mathrel{=}\Varid{b} \comp \fun F \;\Varid{k}}
~~~~  \vcenter{\xymatrix@C=1em{
	\ensuremath{\muF }
 		\ar[d]_{\ensuremath{\Varid{k}\mathrel{=}\llparenthesis\,\Varid{b}\,\rrparenthesis}}
&
	\ensuremath{\muF }
 		\ar@/^0.9pc/[rr]^{\ensuremath{\conv{\mathsf{in}_{\fun T}}}}
 		\ar[d]_{\ensuremath{\Varid{k}}}
&
        \iso
&
	\ensuremath{\fun F \;\muF }
 		\ar@/^0.9pc/[ll]^{\ensuremath{\mathsf{in}_{\fun T}}}
 		\ar[d]^{\ensuremath{\fun F \;\Varid{k}}}
\\
	B
&
	\ensuremath{\Conid{B}}
&&
	\ensuremath{\fun F \;\Conid{B}}
 		\ar@/^1pc/[ll]^{\ensuremath{\Varid{b}}}
}}
	\label{eq:cataUniv}
\end{eqnarray}
In words, \ensuremath{\llparenthesis\,\Varid{b}\,\rrparenthesis} is referred to as \emph{the}\footnote{Definite article because it is unique.}
\emph{catamorphism} induced by algebra \ensuremath{\Varid{b}}. Clearly, it is a generic, recursive
construct expressing the transformation of \ensuremath{\muF } into \ensuremath{\Conid{B}} in a ``recursive-descent''
manner dictated by functor \ensuremath{\fun F }.

A very simple example of catamorphism is the ``for-loop" combinator
defined by
\begin{eqnarray}
	\ensuremath{\for{\Varid{b}}{\Varid{i}}\mathrel{=}\llparenthesis\,\alt{\kons{\Varid{i}}}{\Varid{b}}\,\rrparenthesis}
	\label{eq:230207d}
\end{eqnarray}
in which \ensuremath{\fun F \;\Conid{X}\mathrel{=}\mathrm{1}\mathbin{+}\Conid{X}} and \ensuremath{\muF \mathrel{=}\N_0}. In this case,
\begin{eqnarray}
\start \ensuremath{\mathsf{in}_{\fun T}\mathrel{=}\alt{\mathsf{zero}}{\mathsf{succ}}}
	\label{eq:230306a}
\end{eqnarray}
is the so-called \emph{Peano algebra} which builds natural nunmbers,
where \ensuremath{\rarrow{\mathrm{1}}{\mathsf{zero}}{\N_0}\mathrel{=}\kons{\mathrm{0}}} generates \ensuremath{\mathrm{0}} and \ensuremath{\rarrow{\N_0}{\mathsf{succ}}{\N_0}}, the successor function
\ensuremath{\mathsf{succ}\;\Varid{n}\mathrel{=}\Varid{n}\mathbin{+}\mathrm{1}}, generates all other numbers. By \ensuremath{\rarrow{\mathrm{1}}{\kons{\Varid{k}}}{\Conid{X}}} we mean the constant function
\ensuremath{\kons{\Varid{k}}\;\anonymous \mathrel{=}\Varid{k}}, where \ensuremath{\mathrm{1}} is the singleton object.

By unfolding (\ref{eq:230207d}) through (\ref{eq:cataUniv}) one derives
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\for{\Varid{b}}{\Varid{i}}\;\mathrm{0}\mathrel{=}\Varid{i}{}\<[E]%
\\
\>[B]{}\for{\Varid{b}}{\Varid{i}}\;(\Varid{n}\mathbin{+}\mathrm{1})\mathrel{=}\Varid{b}\;(\for{\Varid{b}}{\Varid{i}}\;\Varid{n}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
clearly showing that \ensuremath{\Varid{b}} is the loop-body and \ensuremath{\Varid{i}} is the loop-initialization.\footnote{
In spite of its elementary nature, the for-loop combinator is very useful in
programming, see e.g.\ \cite{Da23,Ol20}.
%
%Example (Church numerals): |church n f b = for f b n|.
%
%Church numerals $church : Nat \rightarrow {(B^B)}^{(B^B)}$, $church\ n\ f = f^n$
%That is, |church| is the for-loop |church n f b = for f b n| i.e the Peano-cata
%\begin{code}
%church = cata(either czero csucc) where 
%   czero = const id
%   csucc g f = f . (g f)
%\end{code}
%where 
%$id$ is the Church zero
%\\
%$csucc : {(B^B)}^{(B^B)} \rightarrow {(B^B)}^{(B^B)}$ is the Church successor.
}

Due to its genericity, the catamorphism concept has proved very useful in
studying functional recursion. Similarly to \cite{Hi13}, but extending this
work towards the relational setting, the remainder of this paper addresses
the ``chemistry`` between adjunctions and catamorphisms.

\paragraph{\ensuremath{\llparenthesis\,\anonymous \,\rrparenthesis} meets \ensuremath{\fun L \mathbin\dashv \fun R }}
As a first step in the investigation of such ``chemistry",
we set ourselves the task of solving the equation:
	\ensuremath{\lceil \Varid{f}\rceil\mathrel{=}\llparenthesis\,\lceil \Varid{h}\rceil\,\rrparenthesis},
where \ensuremath{\lceil \anonymous \rceil} is the \ensuremath{\fun R }-transpose of some adjunction \ensuremath{\fun L \mathbin\dashv \fun R }.
\begin{eqnarray*}
\start
	\ensuremath{\lceil \Varid{f}\rceil\mathrel{=}\llparenthesis\,\lceil \Varid{h}\rceil\,\rrparenthesis}
%
\just\equiv{ cata-universal (\ref{eq:cataUniv}) } %  (\ref{eq:cataUniv})
%
	\ensuremath{\lceil \Varid{f}\rceil \comp \mathsf{in}_{\fun T}\mathrel{=}\lceil \Varid{h}\rceil \comp \fun F \;\lceil \Varid{f}\rceil}
%
\just\equiv{ fusion (\ref{eq:200204b}) twice }
%
	\ensuremath{\lceil \Varid{f} \comp \fun L \;\mathsf{in}_{\fun T}\rceil\mathrel{=}\lceil \Varid{h} \comp \fun L \;\fun F \;\lceil \Varid{f}\rceil\rceil}
%
\just\equiv{ isomorphism \ensuremath{\lceil \anonymous \rceil} (\ref{eq:230208a}) }
%
	\ensuremath{\Varid{f} \comp \fun L \;\mathsf{in}_{\fun T}\mathrel{=}\Varid{h} \comp \fun L \;\fun F \;\lceil \Varid{f}\rceil}
%
\end{eqnarray*}
Altogether:
\begin{eqnarray}
	\ensuremath{\Varid{f} \comp \fun L \;\mathsf{in}_{\fun T}\mathrel{=}\Varid{h} \comp \fun L \;\fun F \;\lceil \Varid{f}\rceil}
&\wider\equiv&
	\ensuremath{\lceil \Varid{f}\rceil\mathrel{=}\llparenthesis\,\lceil \Varid{h}\rceil\,\rrparenthesis}
	\label{eq:210111a}
\end{eqnarray}
cf.\ the diagrams:
\begin{eqnarray*}
\begin{array}{ccc}
	\ensuremath{\cat{C}}
&
&
	\ensuremath{\cat{D}}
\\
\xymatrix{
	\ensuremath{\fun L \;\muF }
 		\ar@/^0.9pc/[rr]^{\ensuremath{\conv{\fun L \;\mathsf{in}_{\fun T}}}}
 		\ar[d]_{\ensuremath{\Varid{f}}}
&
        \iso
&
	\ensuremath{\fun L \;\fun F \;\muF }
 		\ar@/^0.9pc/[ll]^{\ensuremath{\fun L \;\mathsf{in}_{\fun T}}}
 		\ar[d]^{\ensuremath{\fun L \;\fun F \;\lceil \Varid{f}\rceil}}
\\
	\ensuremath{\Conid{A}}
&&
	\ensuremath{\fun L \;\fun F \;\fun R \;\Conid{A}}
 		\ar@/^1pc/[ll]^{\ensuremath{\Varid{h}}}
}
& ~~~~~~~ &
\xymatrix{
	\ensuremath{\muF }
 		\ar@/^1pc/[rr]^{\ensuremath{\conv{\mathsf{in}_{\fun T}}}}
 		\ar[d]_{\ensuremath{\lceil \Varid{f}\rceil}}
&
        \iso
&
	\ensuremath{\fun F \;\muF }
 		\ar@/^1pc/[ll]^{\ensuremath{\mathsf{in}_{\fun T}}}
 		\ar[d]^{\ensuremath{\fun F \;\lceil \Varid{f}\rceil}}
\\
	\ensuremath{\fun R \;\Conid{A}}
&&
	\ensuremath{\fun F \;\fun R \;\Conid{A}}
 		\ar@/^1pc/[ll]^{\ensuremath{\lceil \Varid{h}\rceil}}
}
\end{array}
\end{eqnarray*}
Although we have not succeded in getting rid of \ensuremath{\lceil \anonymous \rceil} from the left side of (\ref{eq:210111a}), this result already offers us something useful, as the following example shows.

Let us see how \ensuremath{\llparenthesis\,\anonymous \,\rrparenthesis} meets \ensuremath{\Delta \mathbin\dashv ( \times )}, the pairing adjunction where, recall:
\begin{eqnarray*}
\start	\ensuremath{\fun L \;\Varid{f}\mathrel{=}\Delta \;\Varid{f}\mathrel{=}(\Varid{f},\Varid{f})}
\more	\ensuremath{\epsilon \mathrel{=}(\p1,\p2)}
\more	\ensuremath{\lceil (\Varid{f},\Varid{g})\rceil\mathrel{=}\conj{\Varid{f}}{\Varid{g}}}
\end{eqnarray*}
In this case, the left-hand side of (\ref{eq:210111a}) becomes: 
\begin{eqnarray*}
\start
	\ensuremath{(\Varid{f},\Varid{g}) \comp \fun L \;\mathsf{in}_{\fun T}\mathrel{=}(\Varid{h},\Varid{k}) \comp \fun L \;(\fun F \;\lceil (\Varid{f},\Varid{g})\rceil)}
%
\just\equiv{ \ensuremath{\fun L \;\Varid{f}\mathrel{=}(\Varid{f},\Varid{f})} ; \ensuremath{\lceil (\Varid{f},\Varid{g})\rceil\mathrel{=}\conj{\Varid{f}}{\Varid{g}}} }
%
	\ensuremath{(\Varid{f},\Varid{g}) \comp (\mathsf{in}_{\fun T},\mathsf{in}_{\fun T})\mathrel{=}(\Varid{h},\Varid{k}) \comp (\fun F \;\conj{\Varid{f}}{\Varid{g}},\fun F \;\conj{\Varid{f}}{\Varid{g}})}
%
\just\equiv{ composition and equality of pairs of functions }
%
	\ensuremath{\begin{lcbr}\Varid{f} \comp \mathsf{in}_{\fun T}\mathrel{=}\Varid{h} \comp \fun F \;\conj{\Varid{f}}{\Varid{g}}\\\Varid{g} \comp \mathsf{in}_{\fun T}\mathrel{=}\Varid{k} \comp \fun F \;\conj{\Varid{f}}{\Varid{g}}\end{lcbr}}
\end{eqnarray*}
Concerning the right-hand side:
\begin{eqnarray*}
\start
	\ensuremath{\lceil (\Varid{f},\Varid{g})\rceil\mathrel{=}\llparenthesis\,\lceil (\Varid{h},\Varid{k})\rceil\,\rrparenthesis}
%
\just\equiv{ \ensuremath{\lceil (\Varid{f},\Varid{g})\rceil\mathrel{=}\conj{\Varid{f}}{\Varid{g}}} twice }
%
	\ensuremath{\conj{\Varid{f}}{\Varid{g}}\mathrel{=}\llparenthesis\,\conj{\Varid{h}}{\Varid{k}}\,\rrparenthesis}
\end{eqnarray*}
Putting both sides together we get the so-called \emph{mutual recursion} law:
\begin{eqnarray}
	\ensuremath{\conj{\Varid{f}}{\Varid{g}}\mathrel{=}\llparenthesis\,\conj{\Varid{h}}{\Varid{k}}\,\rrparenthesis}
	& \equiv &
	\ensuremath{\begin{lcbr}\Varid{f} \comp \mathsf{in}_{\fun T}\mathrel{=}\Varid{h} \comp \fun F \;\conj{\Varid{f}}{\Varid{g}}\\\Varid{g} \comp \mathsf{in}_{\fun T}\mathrel{=}\Varid{k} \comp \fun F \;\conj{\Varid{f}}{\Varid{g}}\end{lcbr}}
\label{eq:fokkinga}
\end{eqnarray}

This first outcome of the interplay between recursion and adjunctions is
very useful in programming, because it can be used to trim the complexity
of some dynamic programming (DP) problems by calculation. In particular,
it can be used to convert complex multiple recursion into Peano-recursion,
i.e., for-loops (\ref{eq:230207d}).

Many examples of application of (\ref{eq:fokkinga}) could be given, see e.g.\
\cite{Ol05}.\footnote{Examples in \cite{Ol05} include the derivation of efficient implementations 
of \ensuremath{\R}-valued functions from their Taylor series expansion into mutually recursive functions that
are ``packed together'' via (\ref{eq:fokkinga}).}
Perhaps the most famous (and shortest to explain) is the Fibonacci
series, a classic in \emph{DP}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{fib}\;\mathrm{0}\mathrel{=}\mathrm{1}{}\<[E]%
\\
\>[B]{}\Varid{fib}\;\mathrm{1}\mathrel{=}\mathrm{1}{}\<[E]%
\\
\>[B]{}\Varid{fib}\;(\Varid{n}\mathbin{+}\mathrm{2})\mathrel{=}\Varid{fib}\;(\Varid{n}\mathbin{+}\mathrm{1})\mathbin{+}\Varid{fib}\;\Varid{n}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
By defining \ensuremath{\Varid{f}\;\Varid{n}\mathrel{=}\Varid{fib}\;(\Varid{n}\mathbin{+}\mathrm{1})} and expanding it through the Peano-algebra, one gets,
\begin{eqnarray*}
\start\hskip -2em
\ensuremath{\begin{lcbr}\Varid{f}\;\mathrm{0}\mathrel{=}\mathrm{1}\\\Varid{f}\;(\Varid{n}\mathbin{+}\mathrm{1})\mathrel{=}\Varid{f}\;\Varid{n}\mathbin{+}\Varid{fib}\;\Varid{n}\end{lcbr}}
\more\hskip -2em
\ensuremath{\begin{lcbr}\Varid{fib}\;\mathrm{0}\mathrel{=}\mathrm{1}\\\Varid{fib}\;(\Varid{n}\mathbin{+}\mathrm{1})\mathrel{=}\Varid{f}\;\Varid{n}\end{lcbr}}
\end{eqnarray*}
that is:
\begin{eqnarray*}
\ensuremath{\begin{lcbr}\Varid{f} \comp \alt{\mathsf{zero}}{\mathsf{succ}}\mathrel{=}\alt{\kons{\mathrm{1}}}{\mathsf{add}} \comp \conj{\Varid{f}}{\Varid{fib}}\\\Varid{fib} \comp \alt{\mathsf{zero}}{\mathsf{succ}}\mathrel{=}\alt{\kons{\mathrm{1}}}{\p1} \comp \conj{\Varid{f}}{\Varid{fib}}\end{lcbr}}
\end{eqnarray*}
By (\ref{eq:fokkinga}) and the \emph{exchange law} (\ref{eq:exLaw}), this leads to:
\begin{eqnarray*}
\ensuremath{\conj{\Varid{f}}{\Varid{fib}}} &=& \scata{\ensuremath{\alt{\kons{(\mathrm{1},\mathrm{1})}}{\conj{\mathsf{add}}{\p1}}}}
\end{eqnarray*}
that is (in Haskell syntax):
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{fib}\mathrel{=}\p2 \comp \for{\Varid{loop}}{(\mathrm{1},\mathrm{1})}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{loop}\;(\Varid{x},\Varid{y})\mathrel{=}(\Varid{x}\mathbin{+}\Varid{y},\Varid{x}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
In retrospect, note how the main ingredients of the calculation above rely on adjunctions: law 
(\ref{eq:fokkinga}), which instantiates (\ref{eq:210111a}) for \ensuremath{\Delta \mathbin\dashv ( \times )}, and
law (\ref{eq:exLaw}), which arises from \ensuremath{(\mathbin{+})\mathbin\dashv \Delta \mathbin\dashv ( \times )}.

\section{Towards adjoint-recursion} \label{sec:230308a}
%Further chemistry with recursion
The relevance of (\ref{eq:210111a}) is, as already seen in (\ref{eq:fokkinga}),
the possibility of ``converting" a non-standard recursive construct (\ensuremath{\Varid{f}}) into a catamorphism
by right-adjoint transposition.
Because \ensuremath{\mathsf{in}_{\fun T}} is an isomorphism, \ensuremath{\Varid{f}} could be written instead as
	\ensuremath{\Varid{f}\mathrel{=}\Varid{h} \comp \fun L \;\fun F \;\lceil \Varid{f}\rceil \comp \fun L \;\conv{\mathsf{in}_{\fun T}}}.
Our next aim is to have it written in typical \emph{hylomorphism} (divide \& conquer) format
\cite{BM97}, 
\begin{quote}
	\ensuremath{\Varid{f}\mathrel{=}\Varid{c} \comp \fun H \;\Varid{f} \comp \Varid{d}}
\end{quote}
for some recursive pattern \ensuremath{\fun H }, ``divide`` step \ensuremath{\Varid{d}} and ``conquer`` step \ensuremath{\Varid{c}}.

For this, we need to get rid of \ensuremath{\lceil \Varid{f}\rceil} in the recursive call 
\ensuremath{\Varid{h} \comp \fun L \;\fun F \;\lceil \Varid{f}\rceil \comp \fun L \;\conv{\mathsf{in}_{\fun T}}}.
The resource we have for this is the \emph{cancellation}
law (\ref{eq:200204d}), \ensuremath{\epsilon  \comp \fun L \;\lceil \Varid{f}\rceil\mathrel{=}\Varid{f}}.
However, \ensuremath{\fun L } in \ensuremath{\fun L \;\fun F \;\lceil \Varid{f}\rceil} is in the wrong position and needs to commute with \ensuremath{\fun F }.
So we need a \emph{distributive} law \ensuremath{\fun L \;\fun F \to \fun F \;\fun L } or, more generally, a \emph{natural transformation}
\begin{eqnarray}
	\ensuremath{\phi \mathbin{:}\fun L \;\fun F \to \fun G \;\fun L }
	\label{eq:230209b}
\end{eqnarray}
enabling such a commutation over some \ensuremath{\fun G }. Still, for \ensuremath{\epsilon  \comp \fun L \;\lceil \Varid{f}\rceil\mathrel{=}\Varid{f}} to be of use, we % Because we have |fG fL| and not exactly |fL|,
need \ensuremath{\fun G \;\epsilon } somewhere in the pipeline.
We thus refine
	\ensuremath{\Varid{h}\mathbin{:=}\Varid{h} \comp \fun G \;\epsilon  \comp \phi }
in (\ref{eq:210111a}) and carry on:
\begin{eqnarray*}
\start
	\ensuremath{\lceil \Varid{f}\rceil\mathrel{=}\llparenthesis\,\lceil \Varid{h} \comp \fun G \;\epsilon  \comp \phi \rceil\,\rrparenthesis}
%
\just\equiv{ (\ref{eq:210111a}) }
%
	\ensuremath{\Varid{f} \comp \fun L \;\mathsf{in}_{\fun T}\mathrel{=}\Varid{h} \comp \fun G \;\epsilon  \comp \phi  \comp \fun L \;\fun F \;\lceil \Varid{f}\rceil}
%
\just\equiv{ natural-\ensuremath{\phi }: \ensuremath{\phi  \comp \fun L \;\fun F \;\Varid{f}\mathrel{=}\fun G \;\fun L \;\Varid{f} \comp \phi } } % 200204c
%
	\ensuremath{\Varid{f} \comp \fun L \;\mathsf{in}_{\fun T}\mathrel{=}\Varid{h} \comp \fun G \;\epsilon  \comp \fun G \;\fun L \;\lceil \Varid{f}\rceil \comp \phi }
%
\just\equiv{ functor \ensuremath{\fun G }; cancellation \ensuremath{\epsilon  \comp \fun L \;\lceil \Varid{f}\rceil\mathrel{=}\Varid{f}} (\ref{eq:200204d}) }
%
	\ensuremath{\Varid{f} \comp \fun L \;\mathsf{in}_{\fun T}\mathrel{=}\Varid{h} \comp \fun G \;\Varid{f} \comp \phi }
%qed
\end{eqnarray*}
We thus reach 
\begin{eqnarray}
	\underbrace{\ensuremath{\Varid{f} \comp (\fun L \;\mathsf{in}_{\fun T})\mathrel{=}\Varid{h} \comp \fun G \;\Varid{f} \comp \phi }}_{\mbox{\ensuremath{\fun G }-hylomorphism}}
&
	\equiv
&
	\underbrace{\ensuremath{\lceil \Varid{f}\rceil\mathrel{=}\llparenthesis\,\lceil \Varid{h} \comp \fun G \;\epsilon  \comp \phi \rceil\,\rrparenthesis}}_{\mbox{adjoint \ensuremath{\fun F }-catamorphism}}
	\label{eq:200204f}
\end{eqnarray}
where natural transformation \ensuremath{\phi \mathbin{:}\fun L \;\fun F \to \fun G \;\fun F } captures the necessary
switch of recursion-pattern between the \ensuremath{\fun G }-\emph{hylomorphism} \ensuremath{\Varid{f}} and
the \ensuremath{\fun F }-catamorphism \ensuremath{\lceil \Varid{f}\rceil}, through \ensuremath{\fun L }. Note that, in general, they
sit in different categories. The \ensuremath{\fun G }-hylo (in say \ensuremath{\cat{C}}) is depicted in a diagram by:
\begin{eqnarray*}
\xymatrix{
	\ensuremath{\fun L \;\muF }
		\ar[d]_{\ensuremath{\Varid{f}}}
&
&
	\ensuremath{\fun G \;\fun L \;\muF }
		\ar[d]_{\ensuremath{\fun G \;\Varid{f}}}
&
	\ensuremath{\fun L \;\fun F \;\muF }
		\ar@/_1.5pc/[lll]_-{\ensuremath{\fun L \;\mathsf{in}_{\fun T}}}
		\ar[l]^{\ensuremath{\phi }}
\\
	\ensuremath{\Conid{A}}
&
&
	\ensuremath{\fun G \;\Conid{A}}
		\ar[ll]_{\ensuremath{\Varid{h}}}
}
\end{eqnarray*}
The diagram of its adjoint \ensuremath{\fun F }-cata (in say \ensuremath{\cat{D}}) is:
\begin{eqnarray*}
\myxym{
	\ensuremath{\muF }
		\ar[d]_{\ensuremath{\lceil \Varid{f}\rceil}}
&
&
&
	\ensuremath{\fun F \;\muF }
		\ar[lll]_{\ensuremath{\mathsf{in}_{\fun T}}}
		\ar[d]_{\ensuremath{\fun F \;\lceil \Varid{f}\rceil}}
\\
	\ensuremath{\fun R \;\Conid{A}}
&
&
&
	\ensuremath{\fun F \;\fun R \;\Conid{A}}
		\ar[lll]_{\ensuremath{\lceil \Varid{h} \comp \fun G \;\epsilon  \comp \phi \rceil}}
\\
	\ensuremath{\Conid{A}}
&
	\ensuremath{\fun G \;\Conid{A}}
		\ar[l]_{\ensuremath{\Varid{h}}}
&
	\ensuremath{\fun G \;\fun L \;\fun R \;\Conid{A}}
		\ar[l]_{\ensuremath{\fun G \;\epsilon }}
&
	\ensuremath{\fun L \;\fun F \;\fun R \;\Conid{A}}
		\ar[l]_{\ensuremath{\phi }}
}
\end{eqnarray*}
\emskip

We shall refer to (\ref{eq:200204f}) as the \emph{adjoint-cata} theorem.
Its main interest is that one can use the ``\emph{cata}-artilhery" that stems
from universal property (\ref{eq:cataUniv}) to reason about hylomorphism \ensuremath{\Varid{f}}
by converting \ensuremath{\Varid{f}} to \ensuremath{\lceil \Varid{f}\rceil}. But not necessarily: by (\ref{eq:221120a})
on the right side of (\ref{eq:200204f}), we get:
\begin{eqnarray}
	\underbrace{\ensuremath{\Varid{f} \comp (\fun L \;\mathsf{in}_{\fun T})\mathrel{=}\Varid{h} \comp \fun G \;\Varid{f} \comp \phi }}_{\mbox{\ensuremath{\fun G }-hylomorphism}}
&
	\wider\equiv
&
	\ensuremath{\Varid{f}\mathrel{=}\underbrace{\lfloor \llparenthesis\,\lceil \Varid{h} \comp \fun G \;\epsilon  \comp \phi \rceil\,\rrparenthesis\rfloor}_{\quanta{\Varid{h}}}}
	\label{eq:230305c}
\end{eqnarray}
giving birth to a new recursion combinator with \emph{universal property}:
\begin{eqnarray*}
	\ensuremath{\Varid{f}\mathrel{=}\quanta{\Varid{h}}}
&
	\wider\equiv
&
	\ensuremath{\Varid{f} \comp \fun L \;\mathsf{in}_{\fun T}\mathrel{=}\Varid{h} \comp \fun G \;\Varid{f} \comp \phi }
	%label{eq:230208g}
\end{eqnarray*}
In case \ensuremath{\phi } is invertible, i.e.\ an isomorphism, the above converts to
\begin{eqnarray}
	\ensuremath{\Varid{f}\mathrel{=}\quanta{\Varid{h}}}
&
	\wider\equiv
&
	\ensuremath{\Varid{f} \comp \underbrace{\fun L \;\mathsf{in}_{\fun T} \comp \conv{\phi }}_{\alpha }\mathrel{=}\Varid{h} \comp \fun G \;\Varid{f}}
	\label{eq:230208f} 
\end{eqnarray}
which shares the structure of (\ref{eq:cataUniv}), where we started from.
Indeed, for the trivial adjunction in which \ensuremath{\fun L } and \ensuremath{\fun R } are the identity
functors, \ensuremath{\phi \mathrel{=}{id}} and \ensuremath{\fun F \mathrel{=}\fun G }, \ensuremath{\quanta{\Varid{h}}} coincides with \ensuremath{\llparenthesis\,\Varid{h}\,\rrparenthesis}.
But, in general, (\ref{eq:230208f}) has a much wider scope as it enables us
to handle recursive structures (\ensuremath{\muF }) ``embraced" by some contex information
(\ensuremath{\fun L \;\muF }), a quite common situation in programming. 

For instance, \ensuremath{\Varid{f}} may be applied to a recursive structure \ensuremath{\Varid{x}} paired with some 
data \ensuremath{\Varid{k}}, \ensuremath{\Varid{f}\;(\Varid{x},\Varid{k})}. While this falls off the scope of (\ref{eq:cataUniv}), it is
handled by (\ref{eq:230305c}) for \ensuremath{\fun L \;\Conid{X}\mathrel{=}\Conid{X} \times \Conid{K}}, the lower adjoint
of the exponentials adjunction (\ref{eq:230208h}). This is precisely the situation
in a result known as the \emph{Structural Recursion Theorem} which is proved
in \cite{BM97} with no explicit connection to the underlying adjunction.\footnote{
See Theorem 3.1 in \cite{BM97}, which we can now regard as a corollary of (\ref{eq:230305c}).}

Clearly, (\ref{eq:230305c}) is much wider in scope. And, as it turns out,
it also covers another result in \cite{BM97} as special case, this time involving
the already mentioned category of relations \ensuremath{\cat{R}}. We address this the following section.

\section{Going relational}
Let us now inspect what (\ref{eq:230305c}) in presence of the power-transpose adjunction
\ensuremath{\fun J \mathbin\dashv \fun P } (\ref{eq:230209a}). Thanks to \ensuremath{\fun J } being the identify of objects, we may choose
\ensuremath{\fun G } (in \ensuremath{\cat{R}}) as defined by:
\begin{eqnarray}
	\ensuremath{\Varid{y}\;\fun G \;(\fun L \;\Varid{f})\;\Varid{x}~\Leftrightarrow~\Varid{y}\mathrel{=}\fun F \;\Varid{f}\;\Varid{x}}
	\label{eq:230209c}
\end{eqnarray}
In words, \ensuremath{\fun G } establishes a structural relationship between object structures \ensuremath{\Varid{x}} and \ensuremath{\Varid{y}},
via the relation \ensuremath{\fun L \;\Varid{f}}, iff \ensuremath{\Varid{y}} is the outcome of mapping \ensuremath{\Varid{f}} over \ensuremath{\Varid{x}} in \ensuremath{\cat{S}}.
That is, \ensuremath{\fun G } is the \emph{relator} \cite{R*92} that models \ensuremath{\fun F \;\Varid{f}} is \ensuremath{\cat{R}}. Moreover, (\ref{eq:230209c})
is nothing but (\ref{eq:230209b}) written pointwise, for \ensuremath{\phi \mathrel{=}{id}}. 

Given the close association of \ensuremath{\fun G } to \ensuremath{\fun F } expressed by (\ref{eq:230209c}), there is no harm
in writing only one such symbol (e.g.\ \ensuremath{\fun F }) knowing that \ensuremath{\fun F } in a relational context means
\ensuremath{\fun G }. Assuming this notation convention, and knowing that \ensuremath{\phi } ``is" the identity, 
(\ref{eq:200204f}) instantiates to 
\begin{eqnarray}
	\ensuremath{\Conid{X} \comp \mathsf{in}_{\fun T}\mathrel{=}\Conid{R} \comp \fun F \;\Conid{X}} & \ensuremath{~\Leftrightarrow~} & \ensuremath{\Lambda{\Conid{X}}\mathrel{=}\llparenthesis\,\Lambda{(\Conid{R} \comp \fun F \;\mathbin\in )}\,\rrparenthesis}
\end{eqnarray}
depicted by diagrams as follows:\footnote{Note that the left diagram lives in \ensuremath{\cat{R}} while the
right one lives in \ensuremath{\cat{S}}.}
\begin{eqnarray*}
\myxym{
	\ensuremath{\muF }
		\ar[d]_{\ensuremath{\Conid{X}}}
&
&
	\ensuremath{\fun F \;\muF }
		\ar[ll]_-{\ensuremath{\mathsf{in}_{\fun T}}}
		\ar[d]^{\ensuremath{\fun F \;\Conid{X}}}
\\
	\ensuremath{\Conid{A}}
&
&
	\ensuremath{\fun F \;\Conid{A}}
		\ar[ll]^{\ensuremath{\Conid{R}}}
}
&\ensuremath{~\Leftrightarrow~}& 
\myxym{
	\ensuremath{\muF }
		\ar[d]_{\ensuremath{\Lambda{\Conid{X}}}}
&
&
	\ensuremath{\fun F \;\muF }
		\ar[ll]_{\ensuremath{\mathsf{in}_{\fun T}}}
		\ar[d]^{\ensuremath{\fun F \;\Lambda{\Conid{X}}}}
\\
	\ensuremath{\fun P \;\Conid{A}}
&
&
	\ensuremath{\fun F \;\fun P \;\Conid{A}}
		\ar[ll]^{\ensuremath{\Lambda{(\Conid{R} \comp \fun F \;\epsilon  \comp \phi )}}}
}
\end{eqnarray*}
Finally, there is little harm in denoting the new combinator of (\ref{eq:230305c}) by
\ensuremath{\llparenthesis\,\Conid{R}\,\rrparenthesis} instead of \ensuremath{\quanta{\Conid{R}}}, giving birth to the \emph{relational catamorphism} 
combinator:
\begin{eqnarray}
	\ensuremath{\Conid{X} \comp \mathsf{in}_{\fun T}\mathrel{=}\Conid{R} \comp \fun F \;\Conid{X}} & \ensuremath{~\Leftrightarrow~} & \ensuremath{\Conid{X}\mathrel{=}\underbrace{\mathbin\in  \comp \llparenthesis\,\Lambda{(\Conid{R} \comp \fun F \;\mathbin\in )}\,\rrparenthesis}_{\llparenthesis\,\Conid{R}\,\rrparenthesis}}
	\label{eq:210108d}
\end{eqnarray}
Thus ``banana-brackets" are extended to \emph{relations}, giving birth to \emph{inductive relations}. Note that \ensuremath{\Conid{R}} is a \emph{relational} \ensuremath{\fun F }-algebra, which is checked in every recursive descent of \ensuremath{\llparenthesis\,\Conid{R}\,\rrparenthesis}
across the input data.

Before proceeding to examples, it should be mentioned that the equivalence
\begin{eqnarray}
	\ensuremath{\Conid{X}\mathrel{=}\llparenthesis\,\Conid{R}\,\rrparenthesis} & \equiv & \ensuremath{\Lambda{\Conid{X}}\mathrel{=}\llparenthesis\,\Lambda{(\Conid{R} \comp \fun F \;\mathbin\in )}\,\rrparenthesis}
	\label{eq:210115a}
\end{eqnarray}
--- which is another way of expressing (\ref{eq:210108d}) --- is known in the literature as the \emph{Eilenberg-Wright} Lemma \citep{BM97}.
So we have just shown that this lemma follows the more general ``adjoint-cata" theorem (\ref{eq:200204f})
via the \emph{power-transpose} adjunction \ensuremath{\fun J \mathbin\dashv \fun P }.

\paragraph{\ensuremath{\llparenthesis\,\anonymous \,\rrparenthesis}-reflection and more}
As a first introduction to reasoning about inductive relations in \ensuremath{\cat{R}}, let us see what we get from 
(\ref{eq:210108d}) when \ensuremath{\Conid{X}\mathrel{=}{id}}. Put in another way, we wish to solve \ensuremath{{id}\mathrel{=}\llparenthesis\,\Conid{R}\,\rrparenthesis} for \ensuremath{\Conid{R}}.
Since \ensuremath{\fun F \;{id}\mathrel{=}{id}}, (\ref{eq:210108d}) immediately gives us
	\ensuremath{\mathsf{in}_{\fun T}\mathrel{=}\Conid{R}~\Leftrightarrow~{id}\mathrel{=}\llparenthesis\,\Conid{R}\,\rrparenthesis},
meaning that the equation \ensuremath{{id}\mathrel{=}\llparenthesis\,\Conid{R}\,\rrparenthesis} has one sole solution, \ensuremath{\Conid{R}\mathrel{=}\mathsf{in}_{\fun T}}. Substituting, we get
\begin{eqnarray}
	\ensuremath{\llparenthesis\,\mathsf{in}_{\fun T}\,\rrparenthesis\mathrel{=}{id}}
\end{eqnarray}
known as the \emph{reflection} law \cite{BM97}.
In words, it means that recursively dismantelling a tree-structure into its
parts and assembling these back again yields the original tree-structure.

Taking the case of the Peano algebra \ensuremath{\mathsf{in}_{\fun T}\mathrel{=}\alt{\mathsf{zero}}{\mathsf{succ}}} (\ref{eq:230306a}) as example,
we get \ensuremath{\llparenthesis\,\alt{\mathsf{zero}}{\mathsf{succ}}\,\rrparenthesis\mathrel{=}\for{\mathsf{succ}}{\mathrm{0}}\mathrel{=}{id}}. Note that \ensuremath{\alt{\mathsf{zero}}{\mathsf{succ}}}
is a function, and so we actually do not need (\ref{eq:210108d}) for this, (\ref{eq:cataUniv})
where we started from is enough.

Now, since we can plug relations in (\ref{eq:210108d}),
how about going for something larger than \ensuremath{\alt{\mathsf{zero}}{\mathsf{succ}}}, for instance
\ensuremath{\llparenthesis\,\alt{\mathsf{zero}}{{\mathsf{zero}}\mathbin\cup{\mathsf{succ}}}\,\rrparenthesis}?
(Recall from (\ref{eq:230305a}) that relation union and alternatives involving relations are well-defined.)

Let us first of all see what kind of relation \ensuremath{\Conid{X}\mathrel{=}\llparenthesis\,\alt{\mathsf{zero}}{{\mathsf{zero}}\mathbin\cup{\mathsf{succ}}}\,\rrparenthesis} is,
governed by universal property (\ref{eq:210108d}):
\begin{eqnarray*}
\start
\ensuremath{\Conid{X}\mathrel{=}\llparenthesis\,\alt{\mathsf{zero}}{{\mathsf{zero}}\mathbin\cup{\mathsf{succ}}}\,\rrparenthesis}
\just\equiv{ (\ref{eq:210108d}) for \ensuremath{\fun F \;\Conid{X}\mathrel{=}{id}\mathbin{+}\Conid{X}} } 
\ensuremath{\Conid{X} \comp \alt{\mathsf{zero}}{\mathsf{succ}}\mathrel{=}\alt{\mathsf{zero}}{{\mathsf{zero}}\mathbin\cup{\mathsf{succ}}} \comp ({id}\mathbin{+}\Conid{X})}
\just\equiv{ \ensuremath{(\mathbin{+})\mathbin\dashv \Delta } in \ensuremath{\cat{R}}: fusion (\ref{eq:211026b}) and absorption (\ref{eq:230306b})  }
\ensuremath{\alt{\Conid{X} \comp \mathsf{zero}}{\Conid{X} \comp \mathsf{succ}}\mathrel{=}\alt{\mathsf{zero}}{({\mathsf{zero}}\mathbin\cup{\mathsf{succ}}) \comp \Conid{X}}}
\just\equiv{ \ensuremath{(\mathbin{+})\mathbin\dashv \Delta } in \ensuremath{\cat{R}}: isomorphism }
\ensuremath{\begin{lcbr}\Conid{X} \comp \mathsf{zero}\mathrel{=}\mathsf{zero}\\\Conid{X} \comp \mathsf{succ}\mathrel{=}({\mathsf{zero}}\mathbin\cup{\mathsf{succ}}) \comp \Conid{X}\end{lcbr}}
\just\equiv{go pointwise in \ensuremath{\cat{R}} via relation composition and (\ref{eq:040120c}), several times }
\ensuremath{\begin{lcbr}\Varid{n}\;\Conid{X}\;\mathrm{0}~\Leftrightarrow~\Varid{n}\mathrel{=}\mathrm{0}\\\Varid{m}\;\Conid{X}\;(\Varid{n}\mathbin{+}\mathrm{1})\mathrel{=}\rcb{\exists }{\Varid{k}}{\Varid{k}\;\Conid{X}\;\Varid{n}}{\Varid{m}\mathrel{=}\mathrm{0}\mathrel{\vee}\Varid{m}\mathrel{=}\Varid{k}\mathbin{+}\mathrm{1}}\end{lcbr}}
\just\equiv{ simplify }
\ensuremath{\begin{lcbr}\Varid{n}\;\Conid{X}\;\mathrm{0}~\Leftrightarrow~\Varid{n}\mathrel{=}\mathrm{0}\\\Varid{m}\;\Conid{X}\;(\Varid{n}\mathbin{+}\mathrm{1})~\Leftrightarrow~\Varid{m}\mathrel{=}\mathrm{0}\mathrel{\vee}(\Varid{m}\mathbin{-}\mathrm{1})\;\Conid{X}\;\Varid{n}\end{lcbr}}
\end{eqnarray*}

By inspection, it can be seen that \ensuremath{\Conid{X}} is the \emph{less-or-equal} relation in \ensuremath{\N_0}.
Indeed, by replacing \ensuremath{\Conid{X}} by \ensuremath{\leq } we get:
\begin{itemize}
\item	base clause --- \ensuremath{\Varid{n}\leq \mathrm{0}~\Leftrightarrow~\Varid{n}\mathrel{=}\mathrm{0}}, which means that \ensuremath{\mathrm{0}} is the infimum of the ordering.
\item inductive clause --- \ensuremath{\Varid{m}\leq \Varid{n}\mathbin{+}\mathrm{1}}, which means that either \ensuremath{\Varid{m}\mathrel{=}\mathrm{0}} (the infimum
of the ordering again) or, for \ensuremath{\Varid{m}\not=\mathrm{0}}, we have \ensuremath{\Varid{m}\leq \Varid{n}\mathbin{+}\mathrm{1}~\Leftrightarrow~\Varid{m}\mathbin{-}\mathrm{1}\leq \Varid{n}},
something we have seen many times in school algebra.
\end{itemize}
All in all, our calculations show that the \ensuremath{(\leq )} ordering on the natural numbers is an \emph{inductive relation}. Note, however, this is not a privilege of \ensuremath{(\leq )\mathbin{:}\N_0\to \N_0}, as we shall see next.

\section{Back to Galois connections} \label{sec:230305d}
%paragraph{Ordering finite lists}
Recall from section \ref{seq:230303d} that the prefix \ensuremath{(\sqsubseteq )} ordering over
finite lists was handled assuming basic ``axiom'' (\ref{eq:100101c}),
\begin{eqnarray*}
\start
	\ensuremath{\Varid{s}\sqsubseteq (\Varid{h}\mathbin{:}\Varid{t})} \wider\equiv
	s = \ensuremath{[\mskip1.5mu \mskip1.5mu]} \wider\lor \rcb\exists {s'}{s = (h:s')}{\ensuremath{\Varid{s'}\sqsubseteq \Varid{t}}}
\end{eqnarray*}
as well as the assumption that the empty sequence \ensuremath{[\mskip1.5mu \mskip1.5mu]} is the infimum of the ordering.
(Recall that these assumptions were needed when e.g.\ calculating \ensuremath{\mathsf{take}}
from its Galois connection specification.)

Let us work out (\ensuremath{\sqsubseteq }) in the same way as \ensuremath{(\leq )} above. There are two constructors of finite lists,
either \ensuremath{\mathsf{nil}\;\anonymous \mathrel{=}[\mskip1.5mu \mskip1.5mu]} generating the empty list; or \ensuremath{\mathsf{cons}\;(\Varid{a},\Varid{x})\mathrel{=}\Varid{a}\mathbin{:}\Varid{x}} generating a new list \ensuremath{\Varid{a}\mathbin{:}\Varid{x}}
from an existing one (\ensuremath{\Varid{x}}) by placing a new element (\ensuremath{\Varid{a}}) at the front of \ensuremath{\Varid{x}}.

Thus the initial algebra in this case is \ensuremath{\mathsf{in}_{\fun T}\mathrel{=}\alt{\mathsf{nil}}{\mathsf{cons}}}, giving way to catamorphisms
over a slightly more complex functor, \ensuremath{\fun F \;\Conid{R}\mathrel{=}{id}\mathbin{+}{id} \times \Conid{R}}, where 
\ensuremath{{id} \times \Conid{R}} has to do with the fact that \ensuremath{\mathsf{cons}} requires two arguments. 

The parallel between \ensuremath{\alt{\mathsf{zero}}{\mathsf{succ}}} and \ensuremath{\alt{\mathsf{nil}}{\mathsf{cons}}} is obvious,
and so we move straight to defining
\ensuremath{(\sqsubseteq )} as the \emph{inductive relation} (a.k.a.\ relational catamorphism): 
\begin{eqnarray}
\start	\ensuremath{(\sqsubseteq )\mathrel{=}\llparenthesis\,\alt{\mathsf{nil}}{{\mathsf{nil}}\mathbin\cup{\mathsf{cons}}}\,\rrparenthesis}
	\label{eq:230305e}
\end{eqnarray}
The reader can easily replay the calculation of \ensuremath{(\leq )} this time for (\ensuremath{\sqsubseteq }) and conclude that
``axioms" (\ref{eq:100101c}) and \ensuremath{[\mskip1.5mu \mskip1.5mu]\sqsubseteq \Varid{x}~\Leftrightarrow~\Varid{x}\mathrel{=}[\mskip1.5mu \mskip1.5mu]} are indeed the \emph{pointwise equivalent}
to defining the list-catamorphism (\ref{eq:230305e}) in \ensuremath{\cat{R}}. 

Eventually, we are in position to answer the main question in section \ref{seq:230303d},
raised by the calculation of recursive right-adjoints such as whole division and \ensuremath{\mathsf{take}}:
\begin{quote}\em
``Where does this induction come from?''
\end{quote}
It is now clear that what turns such adjoints into recursive (inductive) functions is the very
nature of the partial orderings that express them as ``best solutions", which are bound to be
inductive relations as dictated by the inductive structure of the underlying data.

Last but not least, there is yet another advantage:
in \ensuremath{\cat{R}} we can resort to the pointfree version of Galois connections
(\ref{eq:040122b}), where all the components of the connections are homogeneous --- all of them
are \emph{morphisms} of a (single) category, \ensuremath{\cat{R}} --- be them functions, orderings or other relations.
By catamorphism algebra, the reasonings
of section \ref{seq:230303d} can be performed at \emph{pointfree} level, in a more calculational
style, possibly assisted by GC-oriented proof assistants \cite{SO08}, see below.

\section{Related and current work}
In his landmark paper \cite{Hi13} on ``adjoint folds and unfolds", Ralf Hinze leaves the following suggestion:
\begin{quote}\em
(...) Finally, we have left the exploration of \textbf{relational} adjoint (un)folds to future work.
\end{quote}
Following this hint was the main motivation for the research reported in this paper.
The main outcome is a unified view of the relational algebra of programming,
in particular concerning results in the literature \cite{BM97} that now fit together as outcomes of the 
generic \emph{adjoint-cata} theorem of section \ref{sec:230308a}.

The paper is also aimed at framing, in a wider setting, 
the author's long standing interest in Galois connections as
a generic reasoning device \cite{SO08,MO11,Ol19}.
Previous work also includes the use of adjunctions in a categorial approach
to linear algebra \cite{MO13c} and in calculating tail-recursive programs
by ``left Peano recursion'' \cite{Ol20,Da23}.

Current work is going in two main directions. On the applications' side, trying to evaluate how
generic and useful the idea of deriving programs from Galois connections is
(recall section \ref{seq:230303d}) and whether this can be (semi)automated by tools
such as the Galculator \cite{SO08}. This would have the advantage over e.g.\ \cite{MO11}
of not requiring in-depth knowledge of the algebra of relational operators such as
e.g.\ \emph{shrinking}.

On the side of foundations of program semantics, we would like to explore the hint in \cite{Ol21}
of working out the relationship between \emph{denotational semantics} and \emph{structured operational semantics} (SOS, regarded as an inductive relation) \cite{Wi93} as an instance of the adjoint-cata theorem. This is expected to enable a calculational flavour in programming language semantics theory.

\section{Summary}

Science proceeds from the particular to the general. Scientific maturity
is achieved when convincing explanations are given around simple (but expressive)
concepts, generic enough to encompass an entire theoretical framework.
Simplicity and elegance in science enhance scientific communication, makes
concepts more understandable and knowledge more lasting.

Adjunctions are one such concept, expressive and general enough to capture
much of mathematics and theory of programming.

Throughout this work, the author learned to appreciate "adjoint folds" even more and to regard
\emph{adjunctions} as a very fertile device for explaining programming as a whole.
So important that \emph{teaching} them (inc.\ \emph{Galois connections}) should be mainstream.

May the tutorial flavour of the current paper contribute, however little, to this end.
If it ends up doing so, it was worth writing it.

\section*{Acknowledgments}

The author wishes to thank the organizers of WADT'22 for inviting him to give the
talk which led to this paper. His work is financed by National Funds through
the FCT - Funda\c c\~ao para a Ci\^encia e a Tecnologia, I.P. (Portuguese
Foundation for Science and Technology) within the project IBEX, with reference
PTDC/CCI-COM/4280/2021.

\appendix

\section{Properties of adjunctions and monads}

\paragraph{Corollaries of \ensuremath{\Varid{k}\mathrel{=}\lceil \Varid{f}\rceil~\Leftrightarrow~\epsilon  \comp \fun L \;\Varid{k}\mathrel{=}\Varid{f}} (\ref{eq:221120a})}
~
\emskip
\emph{reflection}:
\begin{eqnarray}
	\ensuremath{\lceil \epsilon \rceil\mathrel{=}{id}}
	\label{eq:211017b}
\end{eqnarray}
that is,
\begin{eqnarray}
	\ensuremath{\epsilon \mathrel{=}\lfloor {id}\rfloor}
\end{eqnarray}
\emph{cancellation}:
\begin{eqnarray}
	\ensuremath{\epsilon  \comp \fun L \;\lceil \Varid{f}\rceil\mathrel{=}\Varid{f}}
	\label{eq:200204d}
\end{eqnarray}
\emph{fusion}:
\begin{eqnarray}
	\ensuremath{\lceil \Varid{h}\rceil \comp \Varid{g}\mathrel{=}\lceil \Varid{h} \comp \fun L \;\Varid{g}\rceil}
	\label{eq:200204b}
\end{eqnarray}
\emph{absorption}:
\begin{eqnarray}
	\ensuremath{(\fun R \;\Varid{g}) \comp \lceil \Varid{h}\rceil\mathrel{=}\lceil \Varid{g} \comp \Varid{h}\rceil}
	\label{eq:211017a}
\end{eqnarray}
\emph{naturality}:
\begin{eqnarray}
	\ensuremath{\Varid{h} \comp \epsilon \mathrel{=}\epsilon  \comp \fun L \;(\fun R \;\Varid{h})}
	\label{eq:210128b}
\end{eqnarray}
\emph{closed definition}:
\begin{eqnarray}
	\ensuremath{\lfloor \Varid{k}\rfloor\mathrel{=}\epsilon  \comp (\fun L \;\Varid{k})}
\end{eqnarray}
\emph{functor}:
\begin{eqnarray}
	\ensuremath{\fun R \;\Varid{h}\mathrel{=}\lceil \Varid{h} \comp \epsilon \rceil}
	\label{eq:230208c}
\end{eqnarray}
\emph{isomorphism}:
\begin{eqnarray}
	\ensuremath{\lceil \Varid{f}\rceil\mathrel{=}\lceil \Varid{g}\rceil~\Leftrightarrow~\Varid{f}\mathrel{=}\Varid{g}}
	\label{eq:230208a}
\end{eqnarray}

\paragraph{Dual corollaries of \ensuremath{\Varid{k}\mathrel{=}\lfloor \Varid{f}\rfloor~\Leftrightarrow~\fun R \;\Varid{k} \comp \eta \mathrel{=}\Varid{f}} (\ref{eq:230206b})} 
~
\emskip
\emph{reflection}:
\begin{eqnarray}
	\ensuremath{\lfloor \eta \rfloor\mathrel{=}{id}}
\end{eqnarray}
that is,
\begin{eqnarray}
	\ensuremath{\eta \mathrel{=}\lceil {id}\rceil}
	\label{eq:230208e}
\end{eqnarray}
\emph{cancellation}:
\begin{eqnarray}
	\ensuremath{\fun R \;\lfloor \Varid{f}\rfloor \comp \eta \mathrel{=}\Varid{f}}
	\label{eq:211026a}
\end{eqnarray}
\emph{fusion}:
\begin{eqnarray}
	\ensuremath{\Varid{g} \comp \lfloor \Varid{h}\rfloor\mathrel{=}\lfloor \fun R \;\Varid{g} \comp \Varid{h}\rfloor}
	\label{eq:211026b}
\end{eqnarray}
\emph{absorption}:
\begin{eqnarray}
	\ensuremath{\lfloor \Varid{h}\rfloor \comp \fun L \;\Varid{g}\mathrel{=}\lfloor \Varid{h} \comp \Varid{g}\rfloor}
	\label{eq:230306b}
\end{eqnarray}
\emph{naturality}:
\begin{eqnarray}
	\ensuremath{\Varid{h} \comp \epsilon \mathrel{=}\epsilon  \comp \fun L \;(\fun R \;\Varid{h})}
\end{eqnarray}
\emph{closed definition}:
\begin{eqnarray}
	\ensuremath{\lceil \Varid{g}\rceil\mathrel{=}(\fun R \;\Varid{g}) \comp \eta }
	\label{eq:210127a}
\end{eqnarray}
\emph{functor}
\begin{eqnarray}
	\ensuremath{\fun L \;\Varid{g}\mathrel{=}\lfloor \eta  \comp \Varid{g}\rfloor}
	\label{eq:230208b}
\end{eqnarray}
\emph{cancellation (corollary)}:
\begin{eqnarray}
	\ensuremath{\epsilon  \comp \fun L \;\eta \mathrel{=}{id}}
	\label{eq:210127a}
\end{eqnarray}
%

\paragraph{Monads}
Proof of (\ref{eq:mon-mul}):
\begin{eqnarray*}
\start
	\ensuremath{\mu \comp \mu\mathrel{=}\mu \comp \fun M \;\mu}
%
\just\equiv{\ensuremath{\mu\mathrel{=}\fun R \;\epsilon } (\ref{eq:230301b}); functor \ensuremath{\fun R } }
%
	\ensuremath{\fun R \;(\epsilon  \comp \epsilon )\mathrel{=}(\fun R \;\epsilon ) \comp (\fun R \;(\fun L \;(\fun R \;\epsilon )))}
%
\just\equiv{functor \ensuremath{\fun R } }
%
	\ensuremath{\fun R \;(\epsilon  \comp \epsilon )\mathrel{=}\fun R \;(\epsilon  \comp \fun L \;(\fun R \;\epsilon ))}
%
\just\equiv{ natural-\ensuremath{\epsilon } (\ref{eq:210128b}) }
%
	\ensuremath{\fun R \;(\epsilon  \comp \epsilon )\mathrel{=}\fun R \;(\epsilon  \comp \epsilon )}
\qed
\end{eqnarray*}
Proof of (\ref{eq:mon-unit}):
\begin{eqnarray*}
\start
	\ensuremath{\mu \comp \eta \mathrel{=}{id}\mathrel{=}\mu \comp \fun M \;\eta }
%
\just\equiv{\ensuremath{\mu\mathrel{=}\fun R \;\epsilon }, \ensuremath{\eta \mathrel{=}\lceil {id}\rceil} etc}
%
	\ensuremath{\fun R \;\epsilon  \comp \lceil {id}\rceil\mathrel{=}{id}\mathrel{=}\fun R \;\epsilon  \comp (\fun R \;\fun L \;\eta )}
%
\just\equiv{absorption (\ref{eq:211017a}); functor \ensuremath{\fun R }  }
%
	\ensuremath{\lceil \epsilon \rceil\mathrel{=}{id}\mathrel{=}\fun R \;(\epsilon  \comp \fun L \;\eta )}
%
\just\equiv{ reflection (\ref{eq:211017b}); cancellation (\ref{eq:210127a}) }
%
	\ensuremath{\Varid{true}}
\qed
\end{eqnarray*}
Proof of (\ref{eq:230301e}): 
\begin{eqnarray*}
\start
	f \kcomp g
%
\just={ \ensuremath{\Varid{f}\kcomp\Varid{g}\mathrel{=}\mu \comp \fun M \;\Varid{f} \comp \Varid{g}}} %  (\ref{eq:001230a})
%
	µ \comp \ensuremath{\fun M \;\Varid{f}} \comp g
%
\just={ \ensuremath{\fun M \mathrel{=}\fun R \;\fun L }; \ensuremath{\mu\mathrel{=}\fun R \;\epsilon } }
%
	\ensuremath{\fun R \;\epsilon  \comp (\fun R \;(\fun L \;\Varid{f})) \comp \Varid{g}}
%
\just={ functor \ensuremath{\fun R } }
%
	\ensuremath{\fun R \;(\epsilon  \comp \fun L \;\Varid{f}) \comp \Varid{g}}
%
\just={ cancellation: \ensuremath{\epsilon  \comp \fun L \;\Varid{f}\mathrel{=}\lfloor \Varid{f}\rfloor}; \ensuremath{\Varid{g}\mathrel{=}\lceil \lfloor \Varid{g}\rfloor\rceil} }
%
	\ensuremath{\fun R \;\lfloor \Varid{f}\rfloor \comp \lceil \lfloor \Varid{g}\rfloor\rceil}
%
\just={ absorption: \ensuremath{(\fun R \;\Varid{g}) \comp \lceil \Varid{h}\rceil\mathrel{=}\lceil \Varid{g} \comp \Varid{h}\rceil} }
%
	\ensuremath{\lceil \lfloor \Varid{f}\rfloor \comp \lfloor \Varid{g}\rfloor\rceil}
\qed
\end{eqnarray*}

\EXIT

\begin{eqnarray}
\start
    \ensuremath{\Lambda{(\Conid{X} \comp \Conid{Y})}\mathrel{=}\Lambda{\Conid{X}}\kcomp \Lambda{\Conid{Y}}}
    \label{eq:210507b}
\more
    \ensuremath{\Lambda{{id}}\mathrel{=}\eta }
    \label{eq:210912a}
\more
    \ensuremath{\Lambda{\Varid{f}}\mathrel{=}\eta  \comp \Varid{f}}
    \label{eq:211228a}
\more
    \ensuremath{\Lambda{\bot }\mathrel{=}\kons{\Varid{mzero}}}
    \label{eq:210912b}
\more
    \ensuremath{\Lambda{({\Conid{Y}}\mathbin\cup{\Conid{X}})}\;\Varid{a}\mathrel{=}(\Varid{mplus}\;(\Lambda{\Conid{Y}}\;\Varid{a})\;(\Lambda{\Conid{X}}\;\Varid{a}))}
    \label{eq:210722a}
\more
    \ensuremath{\Lambda{({\Varid{f}}\mathbin\cup{\Varid{g}})}\;\Varid{a}\mathrel{=}\{\mskip1.5mu \Varid{f}\;\Varid{a},\Varid{g}\;\Varid{a}\mskip1.5mu\}}
\more
    \ensuremath{\Lambda{({\Conid{X}}\mathbin\cap{\Conid{Y}})}\;\Varid{a}\mathrel{=}\{\mskip1.5mu \Varid{b}\mid \Varid{b}\;\mathbin\in \;\Lambda{\Conid{X}}\;\Varid{a}\mathrel{\wedge}\Varid{b}\;\mathbin\in \;\Lambda{\Conid{Y}}\;\Varid{a}\mskip1.5mu\}}
    \label{eq:210723a}
\more
    \ensuremath{\Lambda{(\Conid{X}\mathbin{/}\Conid{Y})}\;\Varid{a}\mathrel{=}\{\mskip1.5mu \Varid{b}\mid \rcb{\forall}{\Varid{c}}{\Varid{c}\;\mathbin\in \;\Lambda{\conv{\Conid{Y}}}\;\Varid{a}}{\Varid{b}\;\mathbin\in \;\Lambda{\Conid{X}}\;\Varid{c}}\mskip1.5mu\}}
    \label{eq:210726a}
\more
    \ensuremath{\Lambda{(\Conid{X} \times \Conid{Y})}\;(\Varid{a},\Varid{b})\mathrel{=}\{\mskip1.5mu (\Varid{c},\Varid{d})\mid \Varid{c}\;\mathbin\in \;\Lambda{\Conid{X}}\;\Varid{a}\;\Varid{land}\;\Varid{d}\;\mathbin\in \;\Lambda{\Conid{X}}\;\Varid{b}\mskip1.5mu\}}
    \label{eq:211226a}
\end{eqnarray}


\section{Relational hylos and their adjoints}

Example: \textbf{list membership}

\begin{eqnarray*}
\ensuremath{\begin{lcbr}\Varid{a}\;\mathbin\epsilon \;[\mskip1.5mu \mskip1.5mu]\mathrel{=}\textsc{f}\\\Varid{a}\;\mathbin\epsilon \;(\Varid{h}\mathbin{:}\Varid{t})\mathrel{=}(\Varid{a}\mathrel{=}\Varid{h})\mathrel{\vee}\Varid{a}\;\mathbin\epsilon \;\Varid{t}\end{lcbr}}
\end{eqnarray*}
\emskip
is the relational \textbf{hylo}

\begin{eqnarray}
\ensuremath{\mathbin\epsilon \mathrel{=}\alt{\bot }{{\p1}\mathbin\cup{\mathbin\epsilon  \comp \p2}} \comp \conv{\mathsf{in}_{\fun T}}}
	\label{eq:211026c}
\end{eqnarray}
\vfill
\textbf{NB}: not the relational \textbf{cata} \ensuremath{\mathbin\epsilon \mathrel{=}\llparenthesis\,\alt{\bot }{{\p1}\mathbin\cup{\p2}}\,\rrparenthesis} that one might feel tempted to write... which is the empty relation!
%

\paragraph{Relational hylos and their adjoints}
Not a cata... But perhaps this hylo (\ref{eq:211026c}) has an \textbf{adjoint} cata? Yes, since
\begin{eqnarray*}
\ensuremath{\mathbin\epsilon \mathrel{=}\alt{\bot }{{\p1}\mathbin\cup{\mathbin\epsilon  \comp \p2}} \comp \conv{\mathsf{in}_{\fun T}}}
\end{eqnarray*}

unfolds into \emskip

\begin{quote}
\ensuremath{\mathbin\epsilon  \comp \mathsf{in}_{\fun T}\mathrel{=}\underbrace{\alt{\bot }{\alt{{id}}{{id}}}}_{\Conid{R}} \comp \underbrace{{id}\mathbin{+}({id}\mathbin{+}\mathbin\epsilon )}_{\fun G \;\mathbin\epsilon } \comp \underbrace{{id}\mathbin{+}({i_1 \comp \p1}\mathbin\cup{i_2 \comp \p2})}_{\Phi }}
\end{quote}
where the core of
\begin{eqnarray*}
	\ensuremath{\Phi \mathbin{:}\underbrace{\mathrm{1}\mathbin{+}\Conid{A} \times {\Conid{A}}^{*}}_{\fun F \;{\Conid{A}}^{*}}\to \underbrace{\mathrm{1}\mathbin{+}(\Conid{A}\mathbin{+}{\Conid{A}}^{*})}_{\fun G \;{\Conid{A}}^{*}}}
\end{eqnarray*}
\emskip
is the (disjoint) union of the two projections \ensuremath{{\p1}\mathbin\cup{\p2}}.
%

\paragraph{Relational hylos and their adjoints}
What is its adjoint? Not surprisingly:
\begin{eqnarray}
\start
	\ensuremath{\Lambda{\mathbin\epsilon }\mathrel{=}\llparenthesis\,\Lambda{\alt{\bot }{{\p1}\mathbin\cup{\mathbin\in  \comp \p2}}}\,\rrparenthesis}
	\nonumber
%
\just\equiv{ \ensuremath{\fun P }-transpose of coproducts (\ref{eq:210220c}) }
%
	\ensuremath{\Lambda{\mathbin\epsilon }\mathrel{=}\llparenthesis\,\alt{\Lambda{\bot }}{\Lambda{({\p1}\mathbin\cup{\mathbin\in  \comp \p2})}}\,\rrparenthesis}
	\nonumber
%
\just\equiv{ introduce \ensuremath{\mathsf{join}} etc (see below) }
%
	\ensuremath{\Lambda{\mathbin\epsilon }\mathrel{=}\llparenthesis\,\alt{\kons{\{\mskip1.5mu \mskip1.5mu\}}}{\mathsf{join}}\,\rrparenthesis}
	\nonumber
%
\just\equiv{ introduce \ensuremath{\mathsf{elems}} }
%
	\ensuremath{\Lambda{\mathbin\epsilon }\mathrel{=}\mathsf{elems}}
	\label{eq:210826a}
%
\end{eqnarray}
where 
\begin{eqnarray*}
	\ensuremath{\begin{lcbr}\mathsf{elems}\;[\mskip1.5mu \mskip1.5mu]\mathrel{=}\{\mskip1.5mu \mskip1.5mu\}\\\mathsf{elems}\;(\Varid{h}\mathbin{:}\Varid{t})\mathrel{=}\{\mskip1.5mu \Varid{h}\mskip1.5mu\}\cup \mathsf{elems}\;\Varid{t}\end{lcbr}}
\end{eqnarray*}

%

\paragraph{Relational hylos and their adjoints}

Details:

\begin{eqnarray*}
%
	\ensuremath{\mathsf{elems}\mathrel{=}\llparenthesis\,\alt{\kons{\{\mskip1.5mu \mskip1.5mu\}}}{\mathsf{join}}\,\rrparenthesis} 
&
	\equiv
&
	\ensuremath{\begin{lcbr}\mathsf{elems}\;[\mskip1.5mu \mskip1.5mu]\mathrel{=}\{\mskip1.5mu \mskip1.5mu\}\\\mathsf{elems}\;(\Varid{h}\mathbin{:}\Varid{t})\mathrel{=}\{\mskip1.5mu \Varid{h}\mskip1.5mu\}\cup \mathsf{elems}\;\Varid{t}\end{lcbr}}
\end{eqnarray*}

where
\begin{quote}
	\ensuremath{\mathsf{join}\;(\Varid{a},\Varid{s})\mathrel{=}{\{\mskip1.5mu \Varid{a}\mskip1.5mu\}}\mathbin\cup{\Varid{s}}}
\end{quote}
since:
\begin{eqnarray*}
\start
	\ensuremath{\mathsf{join}\mathrel{=}\Lambda{({\p1}\mathbin\cup{\mathbin\in  \comp \p2})}}
\more
	\ensuremath{\Lambda{({\Conid{R}}\mathbin\cup{\Conid{S}})}\;\Varid{a}\mathrel{=}{(\Lambda{\Conid{R}}\;\Varid{a})}\mathbin\cup{(\Lambda{\Conid{S}}\;\Varid{a})}}
\more
	\ensuremath{\Lambda{\mathbin\in }\mathrel{=}{id}}
%
\end{eqnarray*}
etc.
\emskip
Usual way of doing list membership: \ensuremath{{\blue \mathbin\epsilon \mathrel{=}\mathbin\in  \comp \mathsf{elems}}}, cf.\ (\ref{eq:210826a}). 
%

\EXIT

Let us investigate this ``chemistry" between \ensuremath{\fun L \mathbin\dashv \fun R } and coproducts a little bit further:
\begin{eqnarray*}
\start
	\ensuremath{\lceil \Varid{k}\rceil\mathrel{=}\alt{\lceil \Varid{f}\rceil}{\lceil \Varid{g}\rceil}}
%
\just\equiv{ (\ref{eq:230302c}) }
%
	\ensuremath{\begin{lcbr}\lceil \Varid{k}\rceil \comp i_1\mathrel{=}\lceil \Varid{f}\rceil\\\lceil \Varid{k}\rceil \comp i_2\mathrel{=}\lceil \Varid{g}\rceil\end{lcbr}}
%
\just\equiv{ fusion (\ref{eq:200204b}) twice }
%
	\ensuremath{\begin{lcbr}\Varid{k} \comp \fun L \;i_1\mathrel{=}\Varid{f}\\\Varid{k} \comp \fun L \;i_2\mathrel{=}\Varid{g}\end{lcbr}}
%
%
\just\equiv{ coproducts }
%
\end{eqnarray*}

\begin{eqnarray*}
\start
	\ensuremath{\Varid{k} \comp \underbrace{\alt{\fun L \;i_1}{\fun L \;i_2}}_{\delta}\mathrel{=}\alt{\Varid{f}}{\Varid{g}}}
%
\just\equiv{ {isomorphism} \ensuremath{\delta} (see below) }
%
	\ensuremath{\Varid{k}\mathrel{=}\alt{\Varid{f}}{\Varid{g}} \comp \conv{\delta}}
%
\end{eqnarray*}
In summary:
\begin{eqnarray}
	\ensuremath{\alt{\lceil \Varid{f}\rceil}{\lceil \Varid{g}\rceil}} = \ensuremath{\lceil \alt{\Varid{f}}{\Varid{g}} \comp \conv{\delta}\rceil}
	\label{eq:210122a}
\end{eqnarray}
equivalent to
\begin{eqnarray}
	\ensuremath{\lfloor \alt{\lceil \Varid{f}\rceil}{\lceil \Varid{g}\rceil}\rfloor \comp \delta} = \ensuremath{\alt{\Varid{f}}{\Varid{g}}}
	\label{eq:210122z}
\end{eqnarray}

\paragraph{Yoneda gets in}
Checking that \ensuremath{\delta\mathbin{:}\fun L \;\Conid{X}\mathbin{+}\fun L \;\Conid{Y}\to \fun L \;(\Conid{X}\mathbin{+}\Conid{Y})} above is an isomorphism can be done in a calculational
style if framed in a wider setting, which will enable calculations with the
same flavour as \emph{indirect equality} (\ref{eq:230109b}) before.

Given a category \ensuremath{\cat{C}} and an object \ensuremath{\Conid{A}} of \ensuremath{\cat{C}}, let us think of the functor \ensuremath{\fun H _{\Conid{A}}\mathbin{:}\cat{C}\to \cat{S}}
such that
	\ensuremath{\fun H _{\Conid{A}}\;\Conid{X}\mathrel{=}\cat{S}\;(\Conid{X},\Conid{A})} and
	\ensuremath{\fun H _{\Conid{A}}\;\Varid{m}\;\Varid{f}\mathrel{=}\Varid{m} \comp \Varid{f}}. This is called the Yoneda functor.\footnote{More precisely,
this is the \emph{contravariant} version of the Yoneda functor, the \emph{covariant} one being
obtained by swapping \ensuremath{\Conid{X}} with \ensuremath{\Conid{Y}} and \ensuremath{\Varid{m}} with \ensuremath{\Varid{f}} in \ensuremath{\Varid{m} \comp \Varid{f}}.} Among the properties of this
functor we find,
\begin{eqnarray}
	\ensuremath{\cat{S}\;(\Conid{X},\Conid{A})\cong\cat{S}\;(\Conid{Y},\Conid{A})} & \equiv & \ensuremath{\Conid{X}\cong\Conid{Y}}
	\label{eq:230303b}
\end{eqnarray}
i.e.\ it is \emph{faithful}. By downgrading \ensuremath{\cat{S}} to the preorder category of section 
\ref{sec:230302a} (where adjunctions become Galois connections, as we have seen),
we see that (\ref{eq:230303b}) generalizes (\ref{eq:230109b}). Let us use the
calculation layout of that section to prove
\begin{eqnarray}
\start \ensuremath{\fun L \;(\Conid{X}\mathbin{+}\Conid{Y})\cong\fun L \;\Conid{X}\mathbin{+}\fun L \;\Conid{Y}}
	\label{eq:230303c}
\end{eqnarray}
for any \ensuremath{\fun L \mathbin\dashv \fun R }:
%
\begin{eqnarray*}
\start
\ensuremath{\rarrow{\fun L \;(\Conid{X}\mathbin{+}\Conid{Y})}{\Varid{m}}{\Conid{C}}}
\just\equiv{ \ensuremath{\fun L \mathbin\dashv \fun R } }
\ensuremath{\rarrow{\Conid{X}\mathbin{+}\Conid{Y}}{\lceil \Varid{m}\rceil}{\fun R \;\Conid{C}}}
\just\equiv{ \ensuremath{(\mathbin{+})\mathbin\dashv \Delta } }
\ensuremath{\begin{lcbr}\rarrow{\Conid{X}}{\lceil \Varid{m}\rceil \comp i_1}{\fun R \;\Conid{C}}\\\rarrow{\Conid{Y}}{\lceil \Varid{m}\rceil \comp i_2}{\fun R \;\Conid{C}}\end{lcbr}}
\just\equiv{ \ensuremath{\fun L \mathbin\dashv \fun R } twice }
	%eqnnewpage 
\ensuremath{\begin{lcbr}\rarrow{\fun L \;\Conid{X}}{\lfloor \lceil \Varid{m}\rceil \comp i_1\rfloor}{\Conid{C}}\\\rarrow{\fun L \;\Conid{Y}}{\lfloor \lceil \Varid{m}\rceil \comp i_2\rfloor}{\Conid{C}}\end{lcbr})}
\just\equiv{ \ensuremath{(\mathbin{+})\mathbin\dashv \Delta }; (\ref{eq:200204b}) twice }
\ensuremath{\longrarrow{\fun L \;\Conid{X}\mathbin{+}\fun L \;\Conid{Y}}{\alt{\Varid{m} \comp \fun L \;i_1}{\Varid{m} \comp \fun L \;i_2}}{\Conid{C}}}
\just\equiv{ fusion (\ref{eq:200204b}) for \ensuremath{(\mathbin{+})\mathbin\dashv \Delta } }
\ensuremath{\longrarrow{\fun L \;\Conid{X}\mathbin{+}\fun L \;\Conid{Y}}{\Varid{m} \comp \alt{\fun L \;i_1}{\fun L \;i_2}}{\Conid{A}}}
\just{::}{ (\ref{eq:230303b}) }
\ensuremath{\longrarrow{\fun L \;\Conid{X}\mathbin{+}\fun L \;\Conid{Y}}{\delta\mathrel{=}\alt{\fun L \;i_1}{\fun L \;i_2}}{\fun L \;(\Conid{X}\mathbin{+}\Conid{C})}}
\qed
\end{eqnarray*}
As an example, recall \ensuremath{(\anonymous  \times \Conid{K})\mathbin\dashv ({\anonymous }^{\Conid{K}})} (\ref{eq:230208h}),
in which case (\ref{eq:230303c}) becomes the well-known natural isomorphism
\ensuremath{(\Conid{X}\mathbin{+}\Conid{Y}) \times \Conid{K}\cong\Conid{X} \times \Conid{K}\mathbin{+}\Conid{X} \times \Conid{K}} and \ensuremath{\delta\mathrel{=}\alt{\fun L \;i_1}{\fun L \;i_2}} is
\ensuremath{\alt{i_1 \times {id}}{i_2 \times {id}}}. Its converse is the \emph{distributor}
\ensuremath{\mathsf{distl}\mathbin{:}(\Conid{X}\mathbin{+}\Conid{Y}) \times \Conid{K}\to \Conid{X} \times \Conid{K}\mathbin{+}\Conid{X} \times \Conid{K}}. Moreover, 
(\ref{eq:210122a}) becomes
\begin{eqnarray}
	\ensuremath{\alt{\mathbf{curry}\hskip 1pt {\Varid{f}}}{\mathbf{curry}\hskip 1pt {\Varid{g}}}\mathrel{=}\mathbf{curry}\hskip 1pt {(\alt{\Varid{f}}{\Varid{g}} \comp \mathsf{distl})}}
	\label{eq:210127b}
\end{eqnarray}

\begin{eqnarray*}
\ensuremath{(\mathbin\in ) \comp \alt{\Lambda{\Conid{R}}}{\Lambda{\Conid{S}}}\mathrel{=}\alt{\Conid{R}}{\Conid{S}}}
\end{eqnarray*}

\begin{eqnarray}
\xarrayin{
	\ensuremath{\begin{lcbr}\fun J \;\Conid{X}\mathrel{=}\Conid{X}\\\Varid{y}\;(\fun J \;\Varid{k})\;\Varid{x}~\Leftrightarrow~\Varid{y}\mathrel{=}\Varid{k}\;\Varid{x}\\\fun R \;\Conid{X}\mathrel{=}\fun P \;\Conid{X}\mathrel{=}\{\mskip1.5mu \Conid{S}\mid \Conid{S} \subseteq \Conid{X}\mskip1.5mu\}\end{lcbr}}
&&
	\ensuremath{\begin{lcbr}\epsilon \mathrel{=}(\mathbin\in )\\\lceil \Conid{R}\rceil\mathrel{=}\Lambda{\Conid{R}}\\\Varid{y}\;\lfloor \Varid{k}\rfloor\;\Varid{x}\mathrel{=}\Varid{y}\;\mathbin\in \;(\Varid{k}\;\Varid{x})\end{lcbr}}
}
	\label{eq:230209a}
\end{eqnarray}


\footnote{Also known as ``adjoint fold" theorem \citep{Hi13}.}




%
\paragraph{Relational catas thanks to \ensuremath{\fun J \mathbin\dashv \fun P }}
\ensuremath{\lfloor \anonymous \rfloor}-shunting again:
\begin{eqnarray}
\myxym{
	\ensuremath{\muF }
		\ar[d]_{\ensuremath{\Conid{X}}}
&
&
	\ensuremath{\fun F \;\muF }
		\ar[ll]_-{\ensuremath{\mathsf{in}_{\fun T}}}
		\ar[d]_{\ensuremath{\fun F \;\Conid{X}}}
\\
	\ensuremath{\Conid{A}}
&
&
	\ensuremath{\fun F \;\Conid{A}}
		\ar[ll]^{\ensuremath{\Conid{R}}}
}
&\ensuremath{~\Leftrightarrow~}& 
\myxym{
	\ensuremath{\muF }
		\ar[d]_{\ensuremath{\Lambda{\Conid{X}}}}
&
&
	\ensuremath{\fun F \;\muF }
		\ar[ll]_{\ensuremath{\mathsf{in}_{\fun T}}}
		\ar[d]_{\ensuremath{\fun F \;\Lambda{\Conid{X}}}}
\\
	\ensuremath{\fun P \;\Conid{A}}
&
&
	\ensuremath{\fun F \;\fun P \;\Conid{A}}
		\ar[ll]^{\ensuremath{\Lambda{(\Conid{R} \comp \fun F \;\epsilon  \comp \phi )}}}
}
\nonumber\\\nonumber\\
\end{eqnarray}
\emskip
%

\paragraph{Eilenberg-Wright Lemma}
Put in another way:
\emskip
The equivalence




\paragraph{Relational catas thanks to \ensuremath{\fun J \mathbin\dashv \fun P }}
Recall (relational side):
\begin{eqnarray*}
	\ensuremath{\begin{lcbr}\fun J \;\Conid{X}\mathrel{=}\Conid{X}\\\Varid{y}\;(\fun J \;\Varid{f})\;\Varid{x}~\Leftrightarrow~\Varid{y}\mathrel{=}\Varid{f}\;\Varid{x}\end{lcbr}}
\end{eqnarray*}
\emskip
Because \ensuremath{\fun J \;\Conid{X}\mathrel{=}\Conid{X}} we can choose \ensuremath{\fun G \;\Conid{X}\mathrel{=}\fun F \;\Conid{X}} and \ensuremath{\phi \mathrel{=}{id}}.
\emskip
\emph{Functor} \ensuremath{\fun F } extends to a \emph{relator} \ensuremath{\fun G }.
\emskip
As is usual, we use the same symbol for functor and relator, greatly simplifying
diagrams:

\paragraph{Many applications!}
Many results in the literature arise as instances of this theorem.

% The so-called \emph{structural recursion theorem} (Thm. 3.1), pag. 73 \cite{BM97} is a special case
\emskip
\fbox{
\includegraphics[width=1.0\textwidth]{srt.png}
}
\vskip 3pt
Details:
\begin{eqnarray*}
	\ensuremath{\fun L \mathbin\dashv \fun R } := \ensuremath{( \times \Conid{K})\mathbin\dashv ({\anonymous }^{\Conid{K}})}
&&
	\ensuremath{\begin{lcbr}\fun F \;\Conid{X}\mathrel{=}\mathrm{1}\mathbin{+}\Conid{A} \times \Conid{X}\\\fun G \;\Conid{X}\mathrel{=}(\mathrm{1}\mathbin{+}\Conid{K})\mathbin{+}\Conid{A} \times \Conid{X}\end{lcbr}}
\more
	\ensuremath{\phi \mathrel{=}({id}\mathbin{+}\mathsf{assocr}) \comp \mathsf{distl}}
\end{eqnarray*}

%

 computation may be paired with s 

ZZZZ

\paragraph{\ensuremath{\quanta{\anonymous }} fusion, reflection and so on}
\emph{fusion}:
\begin{eqnarray}
	\ensuremath{\Varid{k} \comp \quanta{\Varid{f}}\mathrel{=}\quanta{\Varid{g}}}
&
	\wider\implied
&
	\ensuremath{\Varid{k} \comp \Varid{f}\mathrel{=}\Varid{g} \comp \fun G \;\Varid{k}}
\end{eqnarray}
\emph{reflection}  (in case \ensuremath{\phi } is an \emph{isomorphism}):
\begin{eqnarray}
\start
	\ensuremath{\quanta{\alpha }\mathrel{=}{id}}
\end{eqnarray}
where \ensuremath{\alpha } abbreviates \ensuremath{\fun L \;\mathsf{in}_{\fun T} \comp \conv{\phi }} in
\begin{eqnarray*}
	\ensuremath{\Varid{f}\mathrel{=}\quanta{\Varid{h}}}
&
	\wider\equiv
&
	\ensuremath{\Varid{f} \comp \underbrace{\fun L \;\mathsf{in}_{\fun T} \comp \conv{\phi }}_{\alpha }\mathrel{=}\Varid{h} \comp \fun G \;\Varid{f}}
\end{eqnarray*}
\emph{cancellation}:
\begin{eqnarray*}
\start
	\ensuremath{\quanta{\Varid{h}} \comp \alpha \mathrel{=}\Varid{h} \comp \fun G \;\quanta{\Varid{h}}}
\end{eqnarray*}
%

\paragraph{Relational catas thanks to \ensuremath{\fun J \mathbin\dashv \fun P }}
\ensuremath{\fun G }-hylo (\emph{relational}):
\begin{eqnarray*}
\xymatrix{
	\ensuremath{\muF }
		\ar[d]_{\ensuremath{\Conid{X}}}
&
&
	\ensuremath{\fun G \;\muF }
		\ar[d]_{\ensuremath{\fun G \;\Conid{X}}}
&
	\ensuremath{\fun F \;\muF }
		\ar@/_1.5pc/[lll]_-{\ensuremath{\fun J \;\mathsf{in}_{\fun T}}}
		\ar[l]^{\ensuremath{\phi }}
\\
	\ensuremath{\Conid{A}}
&
&
	\ensuremath{\fun G \;\Conid{A}}
		\ar[ll]_{\ensuremath{\Conid{R}}}
}
\end{eqnarray*}

\emskip

Adjoint \ensuremath{\fun F }-cata (\emph{functional}):
\begin{eqnarray*}
\myxym{
	\ensuremath{\muF }
		\ar[d]_{\ensuremath{\Lambda{\Conid{X}}}}
&
&
&
	\ensuremath{\fun F \;\muF }
		\ar[lll]_{\ensuremath{\mathsf{in}_{\fun T}}}
		\ar[d]_{\ensuremath{\fun F \;\Lambda{\Conid{X}}}}
\\
	\ensuremath{\fun P \;\Conid{A}}
&
&
&
	\ensuremath{\fun F \;\fun P \;\Conid{A}}
		\ar[lll]_{\ensuremath{\Lambda{(\Conid{R} \comp \fun G \;\mathbin\in  \comp \phi )}}}
\\
	\ensuremath{\Conid{A}}
&
	\ensuremath{\fun G \;\Conid{A}}
		\ar[l]_{\ensuremath{\Conid{R}}}
&
	\ensuremath{\fun G \;\fun P \;\Conid{A}}
		\ar[l]_{\ensuremath{\fun G \;\mathbin\in }}
&
	\ensuremath{\fun F \;\fun P \;\Conid{A}}
		\ar[l]_{\ensuremath{\phi }}
}
\end{eqnarray*}
%

\paragraph{Relational catas thanks to \ensuremath{\fun J \mathbin\dashv \fun P }}
Recall (relational side):
\begin{eqnarray*}
	\ensuremath{\begin{lcbr}\fun J \;\Conid{X}\mathrel{=}\fun J \;\Conid{X}\\\Varid{y}\;(\fun J \;\Varid{f})\;\Varid{x}~\Leftrightarrow~\Varid{y}\mathrel{=}\Varid{f}\;\Varid{x}\end{lcbr}}
\end{eqnarray*}

\vskip 3em
$\arrayin{
	\framebox(140.00,20.00)[cc]{  relational \ensuremath{\fun G }-recursion}
&&
	\framebox(140.00,20.00)[cc]{  functional \ensuremath{\fun F }-recursion}
\\
\xymatrix{
	\ensuremath{\muF }
		\ar[d]_{\ensuremath{\Conid{X}}}
&
&
	\ensuremath{\fun G \;\muF }
		\ar[d]_{\ensuremath{\fun G \;\Conid{X}}}
&
	\ensuremath{\fun F \;\muF }
		\ar@/_1.5pc/[lll]_-{\ensuremath{\fun J \;\mathsf{in}_{\fun T}}}
		\ar[l]^{\ensuremath{\phi }}
\\
	\ensuremath{\Conid{A}}
&
&
	\ensuremath{\fun G \;\Conid{A}}
		\ar[ll]^{\ensuremath{\Conid{R}}}
}
&& 
\myxym{
	\ensuremath{\muF }
		\ar[d]_{\ensuremath{\Lambda{\Conid{X}}}}
&
&
	\ensuremath{\fun F \;\muF }
		\ar[ll]_{\ensuremath{\mathsf{in}_{\fun T}}}
		\ar[d]_{\ensuremath{\fun F \;\Lambda{\Conid{X}}}}
\\
	\ensuremath{\fun P \;\Conid{A}}
&
&
	\ensuremath{\fun F \;\fun P \;\Conid{A}}
		\ar[ll]^{\ensuremath{\Lambda{(\Conid{R} \comp \fun G \;\epsilon  \comp \phi )}}}
}
}$ % arrayin
%


% \paragraph{Comonad} %

xxx
\begin{eqnarray}
\mbox{ \emph{Functor}}: &&
	\ensuremath{{\Varid{f}}^{\Conid{K}}\mathrel{=}(\Varid{f} \comp )}
\end{eqnarray}
yyy

\begin{eqnarray*}
\myxym{
	\ensuremath{\cat{S}}
		\ar@/_1.0pc/[r]_-{\ensuremath{\Delta }}
&
	\ensuremath{{\cat{S}}^{\mathrm{2}}}
		\ar@/_1.0pc/[l]_-{\ensuremath{( \times )}}
\\
	\ensuremath{\Conid{B} \times \Conid{A}}
&
	\ensuremath{\fun L \;(\Conid{B} \times \Conid{A})}
	\ar[r]^-{\ensuremath{(\p1,\p2)}}
&
	(B,A)
\\
C
	\ar[u]^{\ensuremath{\Varid{k}\mathrel{=}\conj{\Varid{f}}{\Varid{g}}}}
&
	\ensuremath{\fun L \;\Conid{C}}
	\ar[u]^{\ensuremath{(\Varid{k},\Varid{k})}}
	\ar[ru]_{\ensuremath{(\Varid{f},\Varid{g})}}
}
	%label{eq:200206a}
\end{eqnarray*}

\begin{eqnarray*}
\myxym{
	\ensuremath{{\cat{S}}^{\mathrm{2}}}
		\ar@/_1.0pc/[r]_-{\ensuremath{(\mathbin{+})}}
&
	\ensuremath{\cat{S}}
		\ar@/_1.0pc/[l]_-{\ensuremath{\Delta }}
\\
	\ensuremath{(\Conid{A},\Conid{A})}
&
\ensuremath{\Conid{A}\mathbin{+}\Conid{A}}
	\ar[r]^-{\ensuremath{\nabla }}
&
	\ensuremath{\Conid{A}}
\\
	\ensuremath{(\Conid{C},\Conid{D})}
	\ar[u]^{\ensuremath{(\Varid{f},\Varid{g})\mathrel{=}(\Varid{k} \comp i_1,\Varid{k} \comp i_2)}}
&
	\ensuremath{\Conid{C}\mathbin{+}\Conid{D}}
	\ar[u]^{\ensuremath{\Varid{f}\mathbin{+}\Varid{g}}}
	\ar[ru]_{\ensuremath{\Varid{k}}}
}
	%label{eq:200206a}
\end{eqnarray*}

----------


As with \emph{GC}s, universal property can be expressed in a dual way, as follows:

\begin{eqnarray*}
\start
	\ensuremath{\Varid{k}\mathrel{=}\lfloor \Varid{f}\rfloor}
%
\just\equiv{ identity; homset isomorphism }
%
	\ensuremath{\lceil \Varid{k} \comp {id}\rceil\mathrel{=}\Varid{f}}
%
\just\equiv{ absorption (\ref{eq:211017a}) ; \ensuremath{\lceil {id}\rceil\mathrel{=}\eta } }
%
	\ensuremath{\underbrace{(\fun R \;\Varid{k}) \comp \eta }_{\lceil \Varid{k}\rceil}\mathrel{=}\Varid{f}}
%qed
\end{eqnarray*}
%

\paragraph{Dual formulation}

Diagram:

\begin{itemize}
\item	\ensuremath{\fun L } --- left adjoint functor
\item	\ensuremath{\fun R } --- right adjoint functor
\end{itemize}

\paragraph{(``Lossy'') natural transformations}
xxx The same \emph{game} of (\ref{eq:221027b}), but in the \emph{champions league}
Champions league version:

----------

\(
\xymatrix{
	\ensuremath{\Varid{a}}
 		\ar[d]_{\ensuremath{\Varid{f}}}
&
	\ensuremath{\muF }
 		\ar[d]_{\ensuremath{\Varid{f}}}
&
	\ensuremath{\fun F \;\muF }
 		\ar[l]_{\ensuremath{\Varid{a}}}
 		\ar[d]^{\ensuremath{\fun F \;\Varid{f}}}
\\
	\ensuremath{\Varid{b}}
&
	\ensuremath{\Conid{A}}
&
	\ensuremath{\fun F \;\Conid{A}}
 		\ar[l]^{\ensuremath{\Varid{b}}}
}
\)

For non-functional programmers: 
\begin{tabbing}\ttfamily
~int~fib\char40{}int~n\char41{}\\
\ttfamily ~\char123{}\\
\ttfamily ~~~~int~x\char61{}1\char59{}~int~y\char61{}1\char59{}~int~i\char59{}\\
\ttfamily ~~~~for~\char40{}i\char61{}1\char59{}i\char60{}\char61{}n\char59{}i\char43{}\char43{}\char41{}~\char123{}int~a\char61{}x\char59{}~x\char61{}x\char43{}y\char59{}~y\char61{}a\char59{}\char125{}\\
\ttfamily ~~~~return~y\char59{}\\
\ttfamily ~\char125{}\char59{}
\end{tabbing}
%

%paragraph{Why mutual recursion matters --- binomial coefficient}
%

\paragraph{Why mutual recursion matters --- Catalan numbers}
\begin{eqnarray*}
	C_n = \frac{(2n)!}{(n+1)! (n!) }
	\label{eq:cat}
\end{eqnarray*}
\emskip
Lots of factorial (re)calculations --- try ``\emph{DP} artilhery"?
\emskip
No --- use \emph{mutual recursion} instead, based on this property:
\vfill
\begin{eqnarray*}
	C_{n+1} = \frac{4n+2}{n+2} C_n
\end{eqnarray*}
\emskip
Three functions in mutual recursion:
\vfill
\begin{eqnarray*}
\start	\ensuremath{\Varid{c}\;\Varid{n}} = C_n
\more 	\ensuremath{\Varid{f}\;\Varid{n}} = 4n+2
\more	\ensuremath{\Varid{g}\;\Varid{n}} = n+2
\end{eqnarray*}
\vfill
Then (next slide):
\vfill ~
%

\paragraph{Why mutual recursion matters --- Catalan numbers}
``Peano unfolding":
\begin{eqnarray*}
\start	\ensuremath{\Varid{c}\;\mathrm{0}\mathrel{=}\mathrm{1}}
\more	\ensuremath{\Varid{c}\;(\Varid{n}\mathbin{+}\mathrm{1})} = \frac{\ensuremath{(\Varid{f}\;\Varid{n})}\times\ensuremath{(\Varid{c}\;\Varid{n})}}{\ensuremath{\Varid{g}\;\Varid{n}}}
\more 	\ensuremath{\Varid{f}\;\mathrm{0}} = 2
\more	\ensuremath{\Varid{f}\;(\Varid{n}\mathbin{+}\mathrm{1})} = \ensuremath{\Varid{f}\;\Varid{n}\mathbin{+}\mathrm{4}}
\more	\ensuremath{\Varid{g}\;\mathrm{0}} = 2
\more	\ensuremath{\Varid{g}\;(\Varid{n}\mathbin{+}\mathrm{1})} = \ensuremath{\Varid{g}\;\Varid{n}\mathbin{+}\mathrm{1}}
\end{eqnarray*}
Finally applying the law we get a \emph{for}-loop with 3 local variables:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{c}\mathrel{=}\Varid{prj} \comp \for{\Varid{loop}}{\mathsf{init}}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{loop}\;(\Varid{c},\Varid{f},\Varid{g})\mathrel{=}((\Varid{f}\mathbin{*}\Varid{c})\div \Varid{g},\Varid{f}\mathbin{+}\mathrm{4},\Varid{g}\mathbin{+}\mathrm{1}){}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{inic}\mathrel{=}(\mathrm{1},\mathrm{2},\mathrm{2}){}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{prj}\;(\Varid{c},\anonymous ,\anonymous )\mathrel{=}\Varid{c}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
%


\paragraph{Why mutual recursion matters --- minimax}
\begin{center}
	\includegraphics[width=0.8\textwidth]{castor11.png}
\end{center}
%

\paragraph{Why mutual recursion matters --- minimax}
\href{https://en.wikipedia.org/wiki/Minimax}{Wikipedia}:
\begin{center}
	\includegraphics[width=0.8\textwidth]{minimax.png}
\end{center}
%

\paragraph{Why mutual recursion matters --- minimax}
\small
Mutual recursion (players \ensuremath{\Varid{alice}} and \ensuremath{\Varid{bob}}):
\begin{eqnarray*}
	\ensuremath{\Varid{minimax}\mathrel{=}\conj{\Varid{alice}}{\Varid{bob}}}
\end{eqnarray*}
where
\begin{eqnarray*}
\ensuremath{\begin{lcbr}\Varid{alice} \comp \mathsf{in}_{\fun T}\mathrel{=}\alt{{id}}{\Varid{umax}} \comp \fun F \;\Varid{bob}\\\Varid{bob} \comp \mathsf{in}_{\fun T}\mathrel{=}\alt{{id}}{\Varid{umin}} \comp \fun F \;\Varid{alice}\end{lcbr}}
\end{eqnarray*}
\vfill
assuming
\begin{eqnarray*}
\start	\ensuremath{\mathsf{in}_{\fun T}\mathrel{=}\alt{\mathsf{leaf}}{\mathsf{fork}}}
\more	\ensuremath{\fun F \;\Varid{f}\mathrel{=}{id}\mathbin{+}\Varid{f} \times \Varid{f}}
\end{eqnarray*}
in the context of
\begin{quote}
\ensuremath{\mathbf{data}\;\mathsf{LTree}\;\Varid{a}\mathrel{=}\mathsf{leaf}\;\Varid{a}\mid \mathsf{fork}\;(\mathsf{LTree}\;\Varid{a},\mathsf{LTree}\;\Varid{a})}
\end{quote}
(generalizable to other \ensuremath{\fun F } tree-structures).
%

\emskip
It comes handy in particular \emph{dynamic programming} situations.
\emskip
Examples follow in the Peano-recursion (\ensuremath{\mathsf{in}_{\fun T}\mathrel{=}\alt{\mathsf{zero}}{\mathsf{succ}}}) setting, whose catamorphisms (folds) are \emph{for}-loops,
\begin{eqnarray*}
	\ensuremath{\for{\Varid{f}}{\Varid{i}}\mathrel{=}\llparenthesis\,\alt{\kons{\Varid{i}}}{\Varid{f}}\,\rrparenthesis}
\end{eqnarray*}
that is
\begin{eqnarray*}
\start
	\ensuremath{\for{\Varid{f}}{\Varid{i}}\;\mathrm{0}\mathrel{=}\Varid{i}}
\more
	\ensuremath{\for{\Varid{f}}{\Varid{i}}\;(\Varid{n}\mathbin{+}\mathrm{1})\mathrel{=}\Varid{f}\;\for{\Varid{f}}{\Varid{i}}\;\Varid{n}}
\end{eqnarray*}
Example (Church numerals): \ensuremath{\Varid{church}\;\Varid{n}\;\Varid{f}\;\Varid{b}\mathrel{=}\for{\Varid{f}}{\Varid{b}}\;\Varid{n}}.
%

\begin{eqnarray*}
\xymatrix{
	\ensuremath{\muF }
 		\ar@/^1pc/[rr]^{\ensuremath{\conv{\mathsf{in}_{\fun T}}}}
 		\ar[d]_{\ensuremath{\lceil \Varid{f}\rceil}}
&
        \iso
&
	\ensuremath{\fun F \;\muF }
 		\ar@/^1pc/[ll]^{\ensuremath{\mathsf{in}_{\fun T}}}
 		\ar[d]^{\ensuremath{\fun F \;\lceil \Varid{f}\rceil}}
\\
	\ensuremath{\fun R \;\Conid{A}}
&&
	\ensuremath{\fun F \;\fun R \;\Conid{A}}
 		\ar@/^1pc/[ll]^{\ensuremath{\lceil \Varid{h}\rceil}}
}
\end{eqnarray*}
%
%

\paragraph{Dual formulation}

As with \emph{GC}s, universal property can be expressed in a dual way, as follows:

\begin{eqnarray*}
\start
	\ensuremath{\Varid{k}\mathrel{=}\lfloor \Varid{f}\rfloor}
%
\just\equiv{ identity; homset isomorphism }
%
	\ensuremath{\lceil \Varid{k} \comp {id}\rceil\mathrel{=}\Varid{f}}
%
\just\equiv{ absorption (\ref{eq:211017a}) ; \ensuremath{\lceil {id}\rceil\mathrel{=}\eta } }
%
	\ensuremath{\underbrace{(\fun R \;\Varid{k}) \comp \eta }_{\lceil \Varid{k}\rceil}\mathrel{=}\Varid{f}}
%qed
\end{eqnarray*}
%

\paragraph{Dual formulation}

Diagram:

\begin{eqnarray*}
	k = \ensuremath{\lfloor \Varid{f}\rfloor} \wider\equiv \ensuremath{\underbrace{\fun R \;\Varid{k} \comp \eta }_{\lceil \Varid{k}\rceil}\mathrel{=}\Varid{f}}
& ~~~~ &
        \myxym{
	\ensuremath{\fun L \;\Conid{B}}
		\ar[d]_{\ensuremath{\Varid{k}\mathrel{=}\lfloor \Varid{f}\rfloor}}
&
	\ensuremath{\fun R \;(\fun L \;\Conid{B})}
		\ar[d]_{\ensuremath{\fun R \;\Varid{k}}}
&
	B
		\ar[l]_{\ensuremath{\eta }}
		\ar[ld]^{f}
\\
	C
&
	\ensuremath{\fun R \;\Conid{C}}
}
\end{eqnarray*}


Example (\ensuremath{\fun J \mathbin\dashv \fun P }):

\vskip -3em

\begin{eqnarray*}
	\ensuremath{\Conid{R}\mathrel{=}\underbrace{\mathbin\in  \comp \Varid{f}}_{\lfloor \Varid{f}\rfloor}} \wider\equiv \ensuremath{\underbrace{\fun P \;\Conid{R} \comp \eta }_{\Lambda{\Conid{R}}}\mathrel{=}\Varid{f}}
& ~~~~ &
        \myxym{
	\ensuremath{\cat{R}}
&
	\ensuremath{\cat{S}}
\\
	\ensuremath{\Conid{B}}
		\ar[d]_{\ensuremath{\Conid{R}\mathrel{=}\lfloor \Varid{f}\rfloor}}
&
	\ensuremath{\fun P \;\Conid{B}}
		\ar[d]_{\ensuremath{\fun P \;\Conid{R}}}
&
	B
		\ar[l]_{\ensuremath{\eta \mathrel{=}\{\mskip1.5mu \anonymous \mskip1.5mu\}}}
		\ar[ld]^{f}
\\
	C
&
	\ensuremath{\fun P \;\Conid{C}}
}
\end{eqnarray*}
%
\fbox{ CORTE FOI AQUI }

\EXIT

\paragraph{Relational catas thanks to \ensuremath{\fun J \mathbin\dashv \fun P }}
In summary, \emskip
\begin{quote}
	\ensuremath{(\fun J \mathbin\dashv \fun P )\mathbin{+}\llparenthesis\,\anonymous \,\rrparenthesis}
\end{quote}
leads as to \emph{inductive relations}, with universal property:

\begin{eqnarray*}
	\ensuremath{\Conid{X} \comp \mathsf{in}_{\fun T}\mathrel{=}\Conid{R} \comp \fun F \;\Conid{X}} & \ensuremath{~\Leftrightarrow~} & \ensuremath{\Conid{X}\mathrel{=}\llparenthesis\,\Conid{R}\,\rrparenthesis}
\end{eqnarray*}
\emskip
Instance for \emph{Peano recursion}, where
\begin{quote}
\ensuremath{\mathsf{in}_{\fun T}\mathrel{=}\alt{\mathsf{zero}}{\mathsf{succ}}}
\\
\ensuremath{\fun F \;\Conid{X}\mathrel{=}{id}\mathbin{+}\Conid{X}}
\end{quote}
but this time relationally:
\begin{eqnarray*}
\ensuremath{\Conid{X}\mathrel{=}\llparenthesis\,\Conid{R}\,\rrparenthesis} & \ensuremath{~\Leftrightarrow~} &
	\ensuremath{\begin{lcbr}\Conid{X} \comp \mathsf{zero}\mathrel{=}\Conid{R} \comp i_1\\\Conid{X} \comp \mathsf{succ}\mathrel{=}\Conid{R} \comp i_2 \comp \Conid{X}\end{lcbr}}
\end{eqnarray*}
%

\paragraph{Inductive relations thanks to \ensuremath{\fun J \mathbin\dashv \fun P }}
\small
Remember \ensuremath{{\blue \larrow{\N_0}{(\geq )}{\N_0}}}?
\emskip
Now we know how to define it over the Peano algebra,
\begin{eqnarray}
	\ensuremath{(\geq )\mathrel{=}\llparenthesis\,\alt{\top }{\mathsf{succ}}\,\rrparenthesis}
	\label{eq:220629b}
\end{eqnarray}
where \ensuremath{\top } is the largest relation of its type.
(\ensuremath{\Varid{b}\;\top \;\Varid{a}\mathrel{=}\textsc{t}} for all \ensuremath{\Varid{a}} and \ensuremath{\Varid{b}}.)
Unfolding (\ref{eq:220629b}):
\begin{eqnarray*}
\start
	\ensuremath{(\geq )\mathrel{=}\llparenthesis\,\alt{\top }{\mathsf{succ}}\,\rrparenthesis}
%
\just\equiv{previous slide}
%
	\ensuremath{\begin{lcbr}(\geq ) \comp \mathsf{zero}\mathrel{=}\top \\(\geq ) \comp \mathsf{succ}\mathrel{=}\mathsf{succ} \comp (\geq )\end{lcbr}}
%
\just\equiv{ go pointwise (in \ensuremath{\cat{R}}) }
%
	\ensuremath{\begin{lcbr}\Varid{y}\geq \mathrm{0}\mathrel{=}\textsc{t}\\\Varid{y}\geq (\Varid{x}\mathbin{+}\mathrm{1})\mathrel{=}\rcb{\exists }{\Varid{z}}{\Varid{y}\mathrel{=}\Varid{z}\mathbin{+}\mathrm{1}}{\Varid{z}\geq \Varid{x}}\end{lcbr}}
\qed
\end{eqnarray*}
%

\paragraph{Inductive relations thanks to \ensuremath{\fun J \mathbin\dashv \fun P }}
Remember list \emph{prefixes} and \emph{sublists}, \ensuremath{\Varid{ys}\sqsubseteq \Varid{xs}} and \ensuremath{\Varid{ys}\preceq \Varid{xs}}?
\emskip
Now we have a way to define them properly:
\begin{eqnarray*}
\start
    \ensuremath{(\mathbin{\preceq})\mathbin{:}{\Conid{A}}^{*}\leftarrow {\Conid{A}}^{*}}
\more
    \ensuremath{(\mathbin{\preceq})\mathrel{=}\llparenthesis\,\alt{\mathsf{nil}}{{\mathsf{cons}}\mathbin\cup{\mathsf{nil}}}\,\rrparenthesis}
	\label{eq:220629c}
\end{eqnarray*}
and
\begin{eqnarray*}
\start
	\ensuremath{(\mathbin{\sqsubseteq})\mathbin{:}{\Conid{A}}^{*}\leftarrow {\Conid{A}}^{*}} \nonumber
\more
	\ensuremath{(\mathbin{\sqsubseteq})\mathrel{=}\llparenthesis\,\alt{\mathsf{nil}}{{\mathsf{cons}}\mathbin\cup{\p2}}\,\rrparenthesis}
	\label{eq:201227a}
\end{eqnarray*}
where  \ensuremath{\begin{lcbr}\mathsf{nil}\;\anonymous \mathrel{=}[\mskip1.5mu \mskip1.5mu]\\\mathsf{cons}\;(\Varid{h},\Varid{t})\mathrel{=}\Varid{h}\mathbin{:}\Varid{t}\end{lcbr}}
make up the \emph{initial algebra} of finite lists:
\begin{quote}
\ensuremath{\mathsf{in}_{\fun T}\mathrel{=}\alt{\mathsf{nil}}{\mathsf{cons}}}
\end{quote}
%

\paragraph{Inductive relations thanks to \ensuremath{\fun J \mathbin\dashv \fun P }}
Recalling \ensuremath{\mathsf{take}}, now we see  where (\ref{eq:100101c}) came from:
\begin{eqnarray*}
\start
    \ensuremath{(\mathbin{\preceq})\mathrel{=}\llparenthesis\,\alt{\mathsf{nil}}{{\mathsf{cons}}\mathbin\cup{\mathsf{nil}}}\,\rrparenthesis}
%
\just\equiv{ universal property above }
%
    \ensuremath{\begin{lcbr}(\mathbin{\preceq}) \comp \mathsf{nil}\mathrel{=}\mathsf{nil}\\(\mathbin{\preceq}) \comp \mathsf{cons}\mathrel{=}({\mathsf{cons}}\mathbin\cup{\mathsf{nil}}) \comp ({id} \times (\mathbin{\preceq}))\end{lcbr}}
%
\just\equiv{ go pointwise }
%
    \ensuremath{\begin{lcbr}\Varid{y}\sqsubseteq [\mskip1.5mu \mskip1.5mu]~\Leftrightarrow~\Varid{y}\mathrel{=}[\mskip1.5mu \mskip1.5mu]\\\Varid{y}\sqsubseteq (\Varid{h}\mathbin{:}\Varid{t})~\Leftrightarrow~\Varid{y}\mathrel{=}[\mskip1.5mu \mskip1.5mu]\mathrel{\vee}\rcb{\exists }{\Varid{t'}}{\Varid{y}\mathrel{=}\Varid{h}\mathbin{:}\Varid{t'}}{\Varid{t'}\sqsubseteq \Varid{t}}\end{lcbr}}
%
\end{eqnarray*}

%

\paragraph{Back to Galois connections --- in \ensuremath{\cat{R}}}
Remember GC \hfill \ensuremath{\Varid{f}\;\Varid{b}\sqsubseteq \Varid{a}~\Leftrightarrow~\Varid{b}\leq \Varid{g}\;\Varid{a}}? \hfill ~
\emskip
Now, every component of the GC ---  \ensuremath{\Varid{f}}, \ensuremath{\Varid{g}}, \ensuremath{(\sqsubseteq )} and \ensuremath{(\leq )} --- is a \emph{morphism} in \ensuremath{\cat{R}} and:
\begin{eqnarray}
\vcenter{\xymatrix@R=4mm@C=4mm{
	\ensuremath{\Conid{A}}
		\ar[dd]_{\ensuremath{\conv{\Varid{f}}}}
&&
	\ensuremath{\Conid{A}}
		\ar[dd]^{\ensuremath{\Varid{g}}}
		\ar[ll]_{\ensuremath{(\sqsubseteq )}}
\\
&	\ensuremath{\mathrel{=}}
\\
	\ensuremath{\Conid{B}}
&&
	\ensuremath{\Conid{B}}
		\ar[ll]^{\ensuremath{(\leq )}}
}}
\end{eqnarray}
\begin{center}
	\ensuremath{\Varid{f}\mathbin\dashv \Varid{g}} ~~ \ensuremath{~\Leftrightarrow~} ~~ \ensuremath{\conv{\Varid{f}} \comp (\sqsubseteq )\mathrel{=}(\leq ) \comp \Varid{g}}
\end{center}
\emph{NB}: \ensuremath{\conv{\Conid{R}}} is the converse of \ensuremath{\Conid{R}}, which always exists in \ensuremath{\cat{R}} --- but not in the original \ensuremath{\cat{S}}.
%

\paragraph{More about this}

See e.g. my talk
\begin{quote}
\href{https://ifipwg21wiki.cs.kuleuven.be/IFIP21/OnlineOct21}{On the power of adjoint recursion}. Contributed talk to IFIP WG 2.1 Short On-line Meeting \#O6, 26 October 2021.
\end{quote}

Several more examples also in
\begin{quote}
Ralf Hinze.
\newblock Adjoint folds and unfolds --- an extended study.
\newblock \emph{Science of Computer Programming}, 78\penalty0 (11):\penalty0
  2108--2159, 2013.
\end{quote}
which inspired this work.
%

\paragraph{Wrapping up}
Original motivation was Ralf \cite{Hi13}:
\begin{quote}
(...) Finally, we have left the exploration of \emph{relational} adjoint (un)folds to future work.
\end{quote}
As shown, doing this leads to the algebra of inductive relations.
\emskip
Altogether,
\begin{itemize}
\item	I have learned to appreciate ``adjoint folds'' even more.
\item	\emph{Adjunctions} are a very fertile device for structuring the MPC --- \emph{teaching} them (inc.\ \emph{Galois connections}) should be mainstream.
\item	Current work: ``adjoint folds" in language semantics and in linear algebra.
\end{itemize}

%

\paragraph{Final quote}
\begin{quote}\em
"My experience has been that theories are often more structured and more interesting when they are based on the real problems; somehow they are more exciting than completely abstract theories will ever be."\em Donald \cite{Kn73}
\end{quote}

%

\appendix

\paragraph{Composing \ensuremath{(\mathbin{+})\mathbin\dashv \Delta } and \ensuremath{\fun L \mathbin\dashv \fun R }}
\begin{eqnarray*}
\myxym{
	\ensuremath{{\cat{S}}^{\mathrm{2}}}
		\ar@/_1.0pc/[r]_-{\ensuremath{(\mathbin{+})}}
&
	\ensuremath{\cat{S}}
		\ar@/_1.0pc/[l]_-{\ensuremath{\Delta }}
		\ar@/_1.0pc/[r]_-{\ensuremath{\fun L }}
&
	\ensuremath{\cat{C}}
		\ar@/_1.0pc/[l]_-{\ensuremath{\fun R }}
}
\end{eqnarray*}

\begin{eqnarray*}
\myxym{
	\ensuremath{(\fun R \;\Conid{A},\fun R \;\Conid{A})}
&&
	\ensuremath{\fun R \;\Conid{A}\mathbin{+}\fun R \;\Conid{A}}
	\ar[r]^-{\ensuremath{\alt{{id}}{{id}}}}
&
	\ensuremath{\fun R \;\Conid{A}}
\\
	\ensuremath{(\Conid{C},\Conid{D})}
	\ar[u]^{\ensuremath{(\lceil \Varid{f}\rceil,\lceil \Varid{g}\rceil)}}
&&
	\ensuremath{\Conid{C}\mathbin{+}\Conid{D}}
	\ar[u]^{\ensuremath{\lceil \Varid{f}\rceil\mathbin{+}\lceil \Varid{g}\rceil}}
	\ar[ru]_{\ensuremath{\lceil \Varid{k}\rceil}}
\\
	\ensuremath{\begin{lcbr}\lceil \Varid{f}\rceil\mathrel{=}\lceil \Varid{k}\rceil \comp i_1\\\lceil \Varid{g}\rceil\mathrel{=}\lceil \Varid{k}\rceil \comp i_2\end{lcbr}}
&
	\equiv
&
	\ensuremath{\lceil \Varid{k}\rceil\mathrel{=}\alt{\lceil \Varid{f}\rceil}{\lceil \Varid{g}\rceil}}
}
	%label{eq:200206a}
\end{eqnarray*}
%

\paragraph{``Chemistry" between \ensuremath{\fun L \mathbin\dashv \fun R } and coproducts}
\begin{eqnarray*}
\start
	\ensuremath{\lceil \Varid{k}\rceil\mathrel{=}\alt{\lceil \Varid{f}\rceil}{\lceil \Varid{g}\rceil}}
%
\just\equiv{ universal property }
%
	\ensuremath{\begin{lcbr}\lceil \Varid{k}\rceil \comp i_1\mathrel{=}\lceil \Varid{f}\rceil\\\lceil \Varid{k}\rceil \comp i_2\mathrel{=}\lceil \Varid{g}\rceil\end{lcbr}}
%
\just\equiv{ fusion (\ref{eq:200204b}) twice }
%
	\ensuremath{\begin{lcbr}\Varid{k} \comp \fun L \;i_1\mathrel{=}\Varid{f}\\\Varid{k} \comp \fun L \;i_2\mathrel{=}\Varid{g}\end{lcbr}}
%
%
\just\equiv{ coproducts }
%
\end{eqnarray*}

\begin{eqnarray*}
\start
	\ensuremath{\Varid{k} \comp \underbrace{\alt{\fun L \;i_1}{\fun L \;i_2}}_{\delta}\mathrel{=}\alt{\Varid{f}}{\Varid{g}}}
%
\just\equiv{ {isomorphism} \ensuremath{\delta} }
%
	\ensuremath{\Varid{k}\mathrel{=}\alt{\Varid{f}}{\Varid{g}} \comp \conv{\delta}}
%
\end{eqnarray*}
%
How can we be sure \ensuremath{\delta} is an isomorphism?
%

\paragraph{Limits and colimits}
Left adjoints \ensuremath{\fun L } preserve colimits, and thus \emph{coproducts}:
\begin{eqnarray*}
\myxym{
	\ensuremath{\fun L \;(\Conid{A}\mathbin{+}\Conid{B})}
 		\ar@/^1pc/[rr]^{\ensuremath{\conv{\delta}}}
&
	\iso
&
	\ensuremath{\fun L \;\Conid{A}\mathbin{+}\fun L \;\Conid{B}}
 		\ar@/^1pc/[ll]^{\ensuremath{\delta}}
}
&
	~~~~
&
	\ensuremath{\delta\mathrel{=}\alt{\fun L \;i_1}{\fun L \;i_2}}
\end{eqnarray*}
Diagram:
\begin{eqnarray*}\wine
\xymatrix{
	\ensuremath{\fun L \;\Conid{A}}
		\ar[r]^{i_1}
		\ar[dr]_{\ensuremath{\fun L \;i_1}}
&
	\ensuremath{\fun L \;\Conid{A}}+\ensuremath{\fun L \;\Conid{B}}
		\ar[d]^{\ensuremath{\delta}}
&
        \ensuremath{\fun L \;\Conid{B}}
		\ar[l]_{i_2}
		\ar[dl]^{\ensuremath{\fun L \;i_2}}
\\
&
	\ensuremath{\fun L \;(\Conid{A}\mathbin{+}\Conid{B})}
}
\end{eqnarray*}
Example: \hfill (\ensuremath{\fun L \;\Conid{X}\mathrel{=}\Conid{X} \times \Conid{K}})
\begin{eqnarray*}
\myxym{
	\ensuremath{(\Conid{A}\mathbin{+}\Conid{B}) \times \Conid{K}}
 		\ar@/^1pc/[rr]^{\ensuremath{\conv{\delta}\mathrel{=}\mathsf{distl}}}
&
	\iso
&
	\ensuremath{\Conid{A} \times \Conid{K}\mathbin{+}\Conid{B} \times \Conid{K}}
 		\ar@/^1pc/[ll]^{\ensuremath{\delta\mathrel{=}\mathsf{undistl}}}
}
\end{eqnarray*}
%

\paragraph{``Chemistry" between \ensuremath{\fun L \mathbin\dashv \fun R } and coproducts}
Diagrams:
\begin{eqnarray*}\wine
\xymatrix{
	A
		\ar[ddr]_{\ensuremath{\lceil \Varid{h}\rceil}}
		\ar[r]^-{\ensuremath{i_1}}
&
	A+B
		\ar[dd]|(.34)*{\ensuremath{\alt{\lceil \Varid{h}\rceil}{\lceil \Varid{k}\rceil}}}
&
	B
		\ar[l]_-{\ensuremath{i_2}}
		\ar[ddl]^{\ensuremath{\lceil \Varid{k}\rceil}}
\\
\\
&
	\ensuremath{\fun R \;\Conid{C}}
}
&&
	\wine
\xymatrix{
&
	\ensuremath{\fun L \;(\Conid{A}\mathbin{+}\Conid{B})}
		\ar[d]^-{\ensuremath{\conv{\delta}}}
\\
	\ensuremath{\fun L \;\Conid{A}}
		\ar[dr]_{\ensuremath{\Varid{h}}}
		\ar[r]^-{\ensuremath{i_1}}
&
	\ensuremath{\fun L \;\Conid{A}\mathbin{+}\fun L \;\Conid{B}}
		\ar[d]_{\ensuremath{\alt{\Varid{h}}{\Varid{k}}}}
&
	\ensuremath{\fun L \;\Conid{B}}
		\ar[l]_-{\ensuremath{i_2}}
		\ar[dl]^{\ensuremath{\Varid{k}}}
\\
&
	\ensuremath{\Conid{C}}
}
\end{eqnarray*}

%

\paragraph{Examples}
For
\hfill
	\ensuremath{{\blue \fun L \mathbin\dashv \fun R \mathbin{:=}( \times \Conid{K})\mathbin\dashv ({\anonymous }^{\Conid{K}})}}
\hfill
~
\emskip
(covariant exponentials),
	\ensuremath{{\blue \alt{\lceil \Varid{h}\rceil}{\lceil \Varid{k}\rceil}\mathrel{=}\lceil \alt{\Varid{h}}{\Varid{k}} \comp \conv{\delta}\rceil}}
(\ref{eq:210122a}) becomes
\begin{eqnarray}
	\ensuremath{\alt{\mathbf{curry}\hskip 1pt {\Varid{f}}}{\mathbf{curry}\hskip 1pt {\Varid{g}}}\mathrel{=}\mathbf{curry}\hskip 1pt {(\alt{\Varid{f}}{\Varid{g}} \comp \mathsf{distl})}}
	\label{eq:210127b}
\end{eqnarray}




For
\hfill
	\ensuremath{\fun L \mathbin\dashv \fun R \mathbin{:=}\fun J \mathbin\dashv \fun P }
\hfill
~
\emskip
\ensuremath{\delta} is the identity (relation) and so (\ref{eq:210122a}) becomes:
\begin{eqnarray}
	\ensuremath{\Lambda{\alt{\Conid{R}}{\Conid{S}}}\mathrel{=}\alt{\Lambda{\Conid{R}}}{\Lambda{\Conid{S}}}}
	\label{eq:210220c}
\end{eqnarray}

Thus \emph{relational coproducts} can be defined by:
\begin{eqnarray*}
	\ensuremath{\alt{\Conid{R}}{\Conid{S}}\mathrel{=}\mathbin\in  \comp \alt{\Lambda{\Conid{R}}}{\Lambda{\Conid{S}}}}
\end{eqnarray*}
%

\paragraph{Dual theorem}
\begin{eqnarray}
	\ensuremath{\fun R \;\mathsf{out} \comp \Varid{f}\mathrel{=}\phi  \comp \fun G \;\Varid{f} \comp \Varid{h}} & \ensuremath{~\Leftrightarrow~} & \ensuremath{\lfloor \Varid{f}\rfloor\mathrel{=}\mathopen{[\!(}\lfloor \phi  \comp \fun G \;\eta  \comp \Varid{h}\rfloor\mathclose{)\!]}}
	%label{eq:200204f}
\end{eqnarray}
Calculation:
\begin{eqnarray*}
\start
	\ensuremath{\lfloor \Varid{f}\rfloor\mathrel{=}\mathopen{[\!(}\lfloor \phi  \comp \fun G \;\eta  \comp \Varid{h}\rfloor\mathclose{)\!]}}
%
\just\equiv{ ana-universal }
%
	\ensuremath{\mathsf{out} \comp \lfloor \Varid{f}\rfloor\mathrel{=}\fun F \;\lfloor \Varid{f}\rfloor \comp \lfloor \phi  \comp \fun G \;\eta  \comp \Varid{h}\rfloor}
%	|ceil f . inT = ceil(h . fG eta . phi) . fF (ceil f)|
%
\just\equiv{ fusion (\ref{eq:211026b}) twice }
%
	\ensuremath{\lfloor \fun R \;\mathsf{out} \comp \Varid{f}\rfloor\mathrel{=}\lfloor \fun R \;\fun F \;\lfloor \Varid{f}\rfloor \comp \phi  \comp \fun G \;\eta  \comp \Varid{h}\rfloor}
%
\just\equiv{ isomorphism \ensuremath{\lfloor \anonymous \rfloor} ; natural-\ensuremath{\phi } }
%
	\ensuremath{\fun R \;\mathsf{out} \comp \Varid{f}\mathrel{=}\phi  \comp \fun G \;\fun R \;\lfloor \Varid{f}\rfloor \comp \fun G \;\eta  \comp \Varid{h}}
%
\just\equiv{ functor \ensuremath{\fun G }; cancellation \ensuremath{\fun R \;\lfloor \Varid{f}\rfloor \comp \eta \mathrel{=}\Varid{f}} (\ref{eq:211026a}) }
%
	\ensuremath{\fun R \;\mathsf{out} \comp \Varid{f}\mathrel{=}\phi  \comp \fun G \;\Varid{f} \comp \Varid{h}}
\qed
\end{eqnarray*}
%

\paragraph{Dual theorem --- diagram}
\ensuremath{\fun G }-hylomorphism
\begin{eqnarray*}
\xymatrix{
	\ensuremath{\fun R \;\muF }
		\ar@/^1.5pc/[rrr]^-{\ensuremath{\fun R \;\mathsf{out}}}
&
&
	\ensuremath{\fun G \;\fun R \;\muF }
		\ar[r]^{\ensuremath{\phi }}
&
	\ensuremath{\fun R \;\fun F \;\muF }
\\
	\ensuremath{\Conid{A}}
		\ar[rr]_{\ensuremath{\Varid{h}}}
		\ar[u]_{\ensuremath{\Varid{f}}}
&
&
	\ensuremath{\fun G \;\Conid{A}}
		\ar[u]_{\ensuremath{\fun G \;\Varid{f}}}
}
\end{eqnarray*}
\ensuremath{\fun F }-anamorphism :
\begin{eqnarray*}
\xymatrix{
	\ensuremath{\muF }
		\ar@/^1.5pc/[rrr]^-{\ensuremath{\mathsf{out}}}
&
&
&
	\ensuremath{\fun F \;\muF }
\\
	\ensuremath{\fun L \;\Conid{A}}
		\ar[rrr]_{\ensuremath{\lfloor \phi  \comp \fun G \;\eta  \comp \Varid{h}\rfloor}}
		\ar[u]_{\ensuremath{\lfloor \Varid{f}\rfloor}}
&
&
&
	\ensuremath{\fun F \;\fun L \;\Conid{A}}
		\ar[u]_{\ensuremath{\fun F \;\lfloor \Varid{f}\rfloor}}
\\
&
	\ensuremath{\lfloor \Varid{f}\rfloor\mathrel{=}\mathopen{[\!(}\lfloor \phi  \comp \fun G \;\eta  \comp \Varid{h}\rfloor\mathclose{)\!]}}
}
\end{eqnarray*}
%

\nocite{Ol20}

\paragraph{Monads}
A \emph{monad}
\begin{quote}
	\ensuremath{\xymatrix{\Conid{A}\ar[r]^{\eta } & \fun M \Conid{A} & \fun M ^2 \Conid{A} \ar[l]_{\mu}}}
\end{quote}
arises from any adjunction, where:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\fun M \mathrel{=}\fun R  \comp \fun L {}\<[E]%
\\
\>[B]{}\eta \mathrel{=}\lceil {id}\rceil{}\<[E]%
\\
\>[B]{}\mu\mathrel{=}\fun R \;\epsilon {}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Monadic laws come straight from the adjunction laws.
~~~~~~ ~ Unit:
\begin{eqnarray*}
\start
	\ensuremath{\mu \comp \eta \mathrel{=}{id}\mathrel{=}\mu \comp \fun M \;\eta }
%
\just\equiv{\ensuremath{\mu\mathrel{=}\fun R \;\epsilon }, \ensuremath{\eta \mathrel{=}\lceil {id}\rceil} etc}
%
	\ensuremath{\fun R \;\epsilon  \comp \lceil {id}\rceil\mathrel{=}{id}\mathrel{=}\fun R \;\epsilon  \comp (\fun R \;\fun L \;\eta )}
%
\just\equiv{absorption (\ref{eq:211017a}); functor \ensuremath{\fun R }  }
%
	\ensuremath{\lceil \epsilon \rceil\mathrel{=}{id}\mathrel{=}\fun R \;(\epsilon  \comp \fun L \;\eta )}
%
\just\equiv{ reflection (\ref{eq:211017b}); cancellation (\ref{eq:210127a}) }
%
	\ensuremath{\Varid{true}}
\qed
\end{eqnarray*}
%
%

\paragraph{Monad}
Multiplication:
\begin{eqnarray*}
\start
	\ensuremath{\mu \comp \mu\mathrel{=}\mu \comp \fun M \;\mu}
%
\just\equiv{\ensuremath{\mu\mathrel{=}\fun R \;\epsilon }; functor \ensuremath{\fun R } }
%
	\ensuremath{\fun R \;(\epsilon  \comp \epsilon )\mathrel{=}(\fun R \;\epsilon ) \comp (\fun R \;(\fun L \;(\fun R \;\epsilon )))}
%
\just\equiv{functor \ensuremath{\fun R } }
%
	\ensuremath{\fun R \;(\epsilon  \comp \epsilon )\mathrel{=}\fun R \;(\epsilon  \comp \fun L \;(\fun R \;\epsilon ))}
%
\just\equiv{ natural-\ensuremath{\epsilon } (\ref{eq:210128b}) }
%
	\ensuremath{\fun R \;(\epsilon  \comp \epsilon )\mathrel{=}\fun R \;(\epsilon  \comp \epsilon )}
\qed
\end{eqnarray*}
%

\paragraph{Kleisli composition}
From the usual definition of \emph{Kleisli composition},
\ensuremath{\Varid{f}\kcomp\Varid{g}\mathrel{=}\mu \comp \fun M \;\Varid{f} \comp \Varid{g}}
(aside) we can infer:
	\ensuremath{{\blue \Varid{f}\kcomp\Varid{g}\mathrel{=}\lceil \lfloor \Varid{f}\rfloor \comp \lfloor \Varid{g}\rfloor\rceil}}
\begin{eqnarray*}
\start
	f \kcomp g
%
\just={ \ensuremath{\Varid{f}\kcomp\Varid{g}\mathrel{=}\mu \comp \fun M \;\Varid{f} \comp \Varid{g}}} %  (\ref{eq:001230a})
%
	µ \comp \ensuremath{\fun M \;\Varid{f}} \comp g
%
\just={ \ensuremath{\fun M \mathrel{=}\fun R  \comp \fun L }; \ensuremath{\mu\mathrel{=}\fun R \;\epsilon } }
%
	\ensuremath{\fun R \;\epsilon  \comp (\fun R \;(\fun L \;\Varid{f})) \comp \Varid{g}}
%
\just={ functor \ensuremath{\fun R } }
%
	\ensuremath{\fun R \;(\epsilon  \comp \fun L \;\Varid{f}) \comp \Varid{g}}
%
\just={ cancellation: \ensuremath{\epsilon  \comp \fun L \;\Varid{f}\mathrel{=}\lfloor \Varid{f}\rfloor}; \ensuremath{\Varid{g}\mathrel{=}\lceil \lfloor \Varid{g}\rfloor\rceil} }
%
	\ensuremath{\fun R \;\lfloor \Varid{f}\rfloor \comp \lceil \lfloor \Varid{g}\rfloor\rceil}
%
\just={ absorption: \ensuremath{(\fun R \;\Varid{g}) \comp \lceil \Varid{h}\rceil\mathrel{=}\lceil \Varid{g} \comp \Varid{h}\rceil} }
%
	\ensuremath{\lceil \lfloor \Varid{f}\rfloor \comp \lfloor \Varid{g}\rfloor\rceil}
%
\end{eqnarray*}

xxxx


\begin{eqnarray*}
\start
	\ensuremath{\lceil \Conid{X} \comp \Conid{Y}\rceil}	
%	
\just={ absorption: \ensuremath{(\fun R \;\Varid{g}) \comp \lceil \Varid{h}\rceil\mathrel{=}\lceil \Varid{g} \comp \Varid{h}\rceil} }	
%	
	\ensuremath{\fun R \;\Conid{X} \comp \lceil \Conid{Y}\rceil}	
%	
\just={ cancellation: \ensuremath{\epsilon  \comp \fun L \;\Varid{f}\mathrel{=}\Conid{X}}; \ensuremath{\Varid{g}\mathrel{=}\lceil \Conid{Y}\rceil} }	
%	
	\ensuremath{\fun R \;(\epsilon  \comp \fun L \;\Varid{f}) \comp \Varid{g}}	
%	
\just={ functor \ensuremath{\fun R } }	
%	
	\ensuremath{\fun R \;\epsilon  \comp (\fun R \;(\fun L \;\Varid{f})) \comp \Varid{g}}	
%	
\just={ \ensuremath{\fun M \mathrel{=}\fun R  \comp \fun L }; \ensuremath{\mu\mathrel{=}\fun R \;\epsilon } }	
%	
	µ \comp \ensuremath{\fun M \;\Varid{f}} \comp g	
%	
\just={ \ensuremath{\Varid{f}\kcomp\Varid{g}\mathrel{=}\mu \comp \fun M \;\Varid{f} \comp \Varid{g}}} %  (\ref{eq:001230a})	
%	
	f \kcomp g	
%
\end{eqnarray*}

\paragraph{Other relational hylos and their adjoints}

Example: \emph{list membership}

\begin{eqnarray*}
\ensuremath{\begin{lcbr}\Varid{a}\;\mathbin\epsilon \;[\mskip1.5mu \mskip1.5mu]\mathrel{=}\textsc{f}\\\Varid{a}\;\mathbin\epsilon \;(\Varid{h}\mathbin{:}\Varid{t})\mathrel{=}(\Varid{a}\mathrel{=}\Varid{h})\mathrel{\vee}\Varid{a}\;\mathbin\epsilon \;\Varid{t}\end{lcbr}}
\end{eqnarray*}
\emskip
is the relational \emph{hylo}

\begin{eqnarray}
\ensuremath{\mathbin\epsilon \mathrel{=}\alt{\bot }{{\p1}\mathbin\cup{\mathbin\epsilon  \comp \p2}} \comp \conv{\mathsf{in}_{\fun T}}}
	\label{eq:211026c}
\end{eqnarray}
\vfill
\emph{NB}: not the relational \emph{cata} \ensuremath{{\blue \mathbin\epsilon \mathrel{=}\llparenthesis\,\alt{\bot }{{\p1}\mathbin\cup{\p2}}\,\rrparenthesis}} that one might feel tempted to write... which is the empty relation!
%

\paragraph{Other relational hylos and their adjoints}
ot a cata... But perhaps this hylo (\ref{eq:211026c}) has an \emph{adjoint} cata? Yes, since
\begin{eqnarray*}
\ensuremath{\mathbin\epsilon \mathrel{=}\alt{\bot }{{\p1}\mathbin\cup{\mathbin\epsilon  \comp \p2}} \comp \conv{\mathsf{in}_{\fun T}}}
\end{eqnarray*}

unfolds into \emskip

\begin{quote}
\ensuremath{\mathbin\epsilon  \comp \mathsf{in}_{\fun T}\mathrel{=}\underbrace{\alt{\bot }{\alt{{id}}{{id}}}}_{\Conid{R}} \comp \underbrace{{id}\mathbin{+}({id}\mathbin{+}\mathbin\epsilon )}_{\fun G \;\mathbin\epsilon } \comp \underbrace{{id}\mathbin{+}({i_1 \comp \p1}\mathbin\cup{i_2 \comp \p2})}_{\Phi }}
\end{quote}
where the core of
\begin{eqnarray*}
	\ensuremath{\Phi \mathbin{:}\underbrace{\mathrm{1}\mathbin{+}\Conid{A} \times {\Conid{A}}^{*}}_{\fun F \;{\Conid{A}}^{*}}\to \underbrace{\mathrm{1}\mathbin{+}(\Conid{A}\mathbin{+}{\Conid{A}}^{*})}_{\fun G \;{\Conid{A}}^{*}}}
\end{eqnarray*}
\emskip
is the (disjoint) union of the two projections \ensuremath{{\p1}\mathbin\cup{\p2}}.
%

\paragraph{Relational hylos and their adjoints}
What is its adjoint? Not surprisingly:
\begin{eqnarray}
\start
	\ensuremath{\Lambda{\mathbin\epsilon }\mathrel{=}\llparenthesis\,\Lambda{\alt{\bot }{{\p1}\mathbin\cup{\mathbin\in  \comp \p2}}}\,\rrparenthesis}
	\nonumber
%
\just\equiv{ \ensuremath{\fun P }-transpose of coproducts (\ref{eq:210220c}) }
%
	\ensuremath{\Lambda{\mathbin\epsilon }\mathrel{=}\llparenthesis\,\alt{\Lambda{\bot }}{\Lambda{({\p1}\mathbin\cup{\mathbin\in  \comp \p2})}}\,\rrparenthesis}
	\nonumber
%
\just\equiv{ introduce \ensuremath{\mathsf{join}} etc (see below) }
%
	\ensuremath{\Lambda{\mathbin\epsilon }\mathrel{=}\llparenthesis\,\alt{\kons{\{\mskip1.5mu \mskip1.5mu\}}}{\mathsf{join}}\,\rrparenthesis}
	\nonumber
%
\just\equiv{ introduce \ensuremath{\mathsf{elems}} }
%
	\ensuremath{\Lambda{\mathbin\epsilon }\mathrel{=}\mathsf{elems}}
	\label{eq:210826a}
%
\end{eqnarray}
where
\begin{eqnarray*}
	\ensuremath{\begin{lcbr}\mathsf{elems}\;[\mskip1.5mu \mskip1.5mu]\mathrel{=}\{\mskip1.5mu \mskip1.5mu\}\\\mathsf{elems}\;(\Varid{h}\mathbin{:}\Varid{t})\mathrel{=}\{\mskip1.5mu \Varid{h}\mskip1.5mu\}\cup \mathsf{elems}\;\Varid{t}\end{lcbr}}
\end{eqnarray*}

%

\paragraph{Relational hylos and their adjoints}

Details:

\begin{eqnarray*}
%
	\ensuremath{\mathsf{elems}\mathrel{=}\llparenthesis\,\alt{\kons{\{\mskip1.5mu \mskip1.5mu\}}}{\mathsf{join}}\,\rrparenthesis}
&
	\equiv
&
	\ensuremath{\begin{lcbr}\mathsf{elems}\;[\mskip1.5mu \mskip1.5mu]\mathrel{=}\{\mskip1.5mu \mskip1.5mu\}\\\mathsf{elems}\;(\Varid{h}\mathbin{:}\Varid{t})\mathrel{=}\{\mskip1.5mu \Varid{h}\mskip1.5mu\}\cup \mathsf{elems}\;\Varid{t}\end{lcbr}}
\end{eqnarray*}

where
\begin{quote}
	\ensuremath{{\blue \mathsf{join}\;(\Varid{a},\Varid{s})\mathrel{=}{\{\mskip1.5mu \Varid{a}\mskip1.5mu\}}\mathbin\cup{\Varid{s}}}}
\end{quote}
since:
\begin{eqnarray*}
\start
	\ensuremath{{\blue \mathsf{join}\mathrel{=}\Lambda{({\p1}\mathbin\cup{\mathbin\in  \comp \p2})}}}
\more
	\ensuremath{{\blue \Lambda{({\Conid{R}}\mathbin\cup{\Conid{S}})}\;\Varid{a}\mathrel{=}{(\Lambda{\Conid{R}}\;\Varid{a})}\mathbin\cup{(\Lambda{\Conid{S}}\;\Varid{a})}}}
\more
	\ensuremath{\Lambda{\mathbin\in }\mathrel{=}{id}}
%
\end{eqnarray*}
etc.
\emskip
Usual way of doing list membership: \ensuremath{\mathbin\epsilon \mathrel{=}\mathbin\in  \comp \mathsf{elems}}, cf.\ (\ref{eq:210826a}).
%

\paragraph{(Contravariant) exponentials: \ensuremath{({\Conid{K}}^{\anonymous })\mathbin\dashv ({\Conid{K}}^{\anonymous })}}
Isomorphism
\vskip -1em
\begin{eqnarray*}
\xymatrix{
	\ensuremath{\fun L \;\Conid{A}\to \Conid{B}}
 		\ar@/^1pc/[rr]^{\ensuremath{\lceil \anonymous \rceil}}
&
        \iso
&
	\ensuremath{\Conid{A}\to \fun R \;\Conid{B}}
 		\ar@/^1pc/[ll]^{\ensuremath{\lfloor \anonymous \rfloor}}
}
\end{eqnarray*}
becomes (note the arrows reversed on the left side)
\begin{eqnarray*}
\xymatrix{
	\ensuremath{{\Conid{K}}^{\Conid{A}}\leftarrow \Conid{B}}
 		\ar@/^1pc/[rr]^{\ensuremath{\mathsf{flip}\ \cdot }}
&
        \iso
&
	\ensuremath{\Conid{A}\to {\Conid{K}}^{\Conid{B}}}
 		\ar@/^1pc/[ll]^{\ensuremath{\mathsf{flip}\ \cdot }}
}
\end{eqnarray*}
recalling (Haskell): \wine
\begin{tabbing}\ttfamily
~flip~\char58{}\char58{}~\char40{}a~\char45{}\char62{}~b~\char45{}\char62{}~c\char41{}~\char45{}\char62{}~b~\char45{}\char62{}~a~\char45{}\char62{}~c\\
\ttfamily ~flip~f~b~a~\char61{}~f~a~b
\end{tabbing}
%

\paragraph{(Contravariant) exponentials: \ensuremath{({\Conid{K}}^{\anonymous })\mathbin\dashv ({\Conid{K}}^{\anonymous })}}
Contravariant \emph{self-adjunction}.
More formally:
\vskip 0.3ex
\begin{eqnarray*}
	\ensuremath{\begin{lcbr}\fun L \;\Conid{X}\mathrel{=}{\Conid{K}}^{\Conid{X}}\\\fun R \;\Conid{X}\mathrel{=}{\Conid{K}}^{\Conid{X}}\\\epsilon \mathrel{=}\Varid{fid}\mathrel{=}\mathsf{flip}\ {id}\end{lcbr}}
&&
	\ensuremath{\begin{lcbr}\lceil \Varid{f}\rceil\mathrel{=}\mathsf{flip}\ \Varid{f}\\\lfloor \Varid{f}\rfloor\mathrel{=}\mathsf{flip}\ \Varid{f}\end{lcbr}}
\end{eqnarray*}
\vskip -1.5em
\begin{eqnarray*}
\ensuremath{\Varid{k}\mathrel{=}\mathsf{flip}\ \Varid{f}} \wider\equiv \ensuremath{\Varid{f}\mathrel{=}\underbrace{{\Conid{K}}^{\Varid{k}} \comp \Varid{fid}}_{\mathsf{flip}\ \Varid{k}}}
&&
\myxym{
	\ensuremath{\cat{S}}
		\ar@/_1.0pc/[r]_-{\ensuremath{{\Conid{K}}^{\anonymous }}}
&
	\ensuremath{{\cat{S}}^{\Varid{op}}}
		\ar@/_1.0pc/[l]_-{\ensuremath{{\Conid{K}}^{\anonymous }}}
\\
	\ensuremath{{\Conid{K}}^{\Conid{B}}}
&
	\ensuremath{{\Conid{K}}^{({\Conid{K}}^{\Conid{B}})}}
		\ar[d]_{\ensuremath{{\Conid{K}}^{\Varid{k}}}}
&
	B
		\ar[l]_-{\ensuremath{\Varid{fid}}}
		\ar[ld]^{f}
\\
	A
		\ar[u]^{\ensuremath{\Varid{k}\mathrel{=}\mathsf{flip}\ \Varid{f}}}
&
	\ensuremath{{\Conid{K}}^{\Conid{A}}}
}
\end{eqnarray*}
%

\paragraph{(Contravariant) exponentials: \ensuremath{({\Conid{K}}^{\anonymous })\mathbin\dashv ({\Conid{K}}^{\anonymous })}}
Contravariant \emph{exponential functor}:
\begin{eqnarray*}
\ensuremath{\begin{lcbr}{\Conid{K}}^{(\mathbin{-})}\mathbin{:}(\Conid{A}\to \Conid{B})\to (\Conid{B}\to \Conid{K})\to \Conid{A}\to \Conid{K}\\{\Conid{K}}^{\Varid{k}}\;\Varid{g}\mathrel{=}\Varid{g} \comp \Varid{k}\end{lcbr}}
&&
\myxym{
	\ensuremath{\cat{S}}
		\ar@/_0.0pc/[r]^-{\ensuremath{{\Conid{K}}^{\anonymous }}}
&
	\ensuremath{{\cat{S}}^{\Varid{op}}}
\\
	\ensuremath{\Conid{B}}
&
	\ensuremath{{\Conid{K}}^{\Conid{B}}}
		\ar[d]_{\ensuremath{{\Conid{K}}^{\Varid{k}}}}
&
\\
	A
		\ar[u]^{\ensuremath{\Varid{k}}}
&
	\ensuremath{{\Conid{K}}^{\Conid{A}}}
}
\end{eqnarray*}
That is:

\begin{eqnarray}
	\ensuremath{{\Conid{K}}^{\Varid{k}}\mathrel{=}( \comp \Varid{k})}
\end{eqnarray}
%


\part{References}

------

and
\emskip\footnotesize
\emph{NB:} assuming the sublist ordering \ensuremath{\Varid{ys}\preceq \Varid{xs}} such that e.g.
\ensuremath{``\Varid{ab''}\preceq ``\Varid{acb''}} holds but
\ensuremath{``\Varid{ab''}\preceq ``\Varid{bca''}} \emph{does not} hold.
%


Whole division \emph{specification}:
\begin{quote}\centering
 \ensuremath{\Varid{a} \times \Varid{y}\leq \Varid{x}~\Leftrightarrow~\Varid{a}\leq \Varid{x}\div \Varid{y}}
\end{quote}
that is:
\begin{center}
	\ensuremath{\Varid{a}\;\underbrace{ \times \Varid{y}}_{\Varid{f}}\leq \Varid{x}~\Leftrightarrow~\Varid{a}\leq \Varid{x}\;\underbrace{\div \Varid{y}}_{\Varid{g}}}
\end{center}
that is:
%
	\includegraphics[width=0.1\textwidth]{dichotomy.jpg}
	\includegraphics[width=0.3\textwidth]{rcb.png}
%
%
%


\ToDo{
\newpage
\begin{itemize}
\item	WADT 82 ... -- (algebraic) \emph{abstract data type} trend
\item	WADT 92 -- Hermida fibred \emph{adjunctions}
\item	WADT ... -- lots of other interesting topics!
\end{itemize}

Algebraic techniques in this talk:
\begin{itemize}
\item	\emph{Galois connections} as one of their most useful instances.
\end{itemize}
\emskip
Perspective:
\begin{itemize}
\item	mathematics of program construction.
\end{itemize}
}


\EXIT


\paragraph{Summary}

\begin{itemize}
\item	
	Revisiting the "\emph{adjoint (un)fold}" construction that Ralf \cite{Hi13} addressed in his landmark \emph{SCP} paper.

\item
	Instead of Mendler's (``triangular'' diagram) style I will use the more widespread ``rectangular'' style.

\item
	This makes the \emph{divide-and-conquer} (hylo) structure of algorithms more explicit.
\end{itemize}
%

\paragraph{In this talk}

Quoting Ralf \cite{Hi13}:

\begin{quote}
(...) Finally, we have left the exploration of \emph{relational} adjoint (un)folds to future work.
\end{quote}

I am going in this direction, exploiting adjoint folding in \emph{relation algebra}.

\emskip

For instance, a result known as the
\emph{Eilenberg-Wright Lemma}
is an instance of adjoint folding.
%

\paragraph{About this talk}
\begin{itemize}
\item
	Lots of diagrams, (hopefully) light-weight
\footnote{
	Material intended for future PhD course on these topics (\href{https://mapi.map.edu.pt/}{MAPi} PhD Programme).\\~\\
}
\item
	Tutorial styled: browsing the \emph{\wine ``chemistry of universals''} which leads to the main results
\item
	Focus on applications: Olivier Danvy's ``left Peano'' recursion; AoP structural recursion theorem; % continuation style folds;
Eilenberg-Wright Lemma; relational cata/hylomorphisms; quantamorphisms; denotational / SOS semantics adjunction, etc.
\end{itemize}
%

\paragraph{Important detail concerning \ensuremath{\Phi }}
Most natural transformations \ensuremath{\phi \mathbin{:}\fun R \;\Conid{X}\to \fun G \;\Conid{X}} in \ensuremath{\cat{R}} (ordered category of \emph{relations}) are \emph{lax}, i.e.\ weaker:
\begin{eqnarray}
\ensuremath{\phi  \comp (\fun F \;\Conid{R})\; \subseteq \;(\fun G \;\Conid{R}) \comp \phi }
\end{eqnarray}
However, very often such \ensuremath{\phi } are equalities for functions (\ensuremath{\Conid{R}\mathbin{:=}\Varid{f}}).
\emskip
Such is the case of \ensuremath{{\blue {i_1 \comp \p1}\mathbin\cup{i_2 \comp \p2}}} above --- that is, \ensuremath{{\blue \conv{\alt{\conv{\p1}}{\conv{\p2}}}}}.
\emskip
(Details in the appendix.)
%

\paragraph{Peano folding}
Back to functions, "\emph{for} loops":

\begin{eqnarray*}
\ensuremath{\begin{lcbr}\for{\Varid{s}}{\Varid{z}}\;\mathrm{0}\mathrel{=}\Varid{z}\\\for{\Varid{s}}{\Varid{z}}\;(\Varid{n}\mathbin{+}\mathrm{1})\mathrel{=}\Varid{s}\;\for{\Varid{s}}{\Varid{z}}\;\Varid{n}\end{lcbr}}
& \ensuremath{~\Leftrightarrow~}
&
	\ensuremath{\for{\Varid{s}}{\Varid{z}}\mathrel{=}\llparenthesis\,\alt{\kons{\Varid{z}}}{\Varid{s}}\,\rrparenthesis}
	\label{eq:110305a}
\end{eqnarray*}
cf.
\begin{eqnarray*}
\wine
\myxym{
	\ensuremath{\N_0}
		\ar[d]_{\ensuremath{\for{\Varid{s}}{\Varid{z}}}}
&
&
&
	\ensuremath{\mathrm{1}\mathbin{+}\N_0}
		\ar[lll]_{\ensuremath{\mathsf{in}_{\fun T}\mathrel{=}\alt{\kons{\mathrm{0}}}{\mathsf{succ}}}}
		\ar[d]^{\ensuremath{{id}\mathbin{+}\for{\Varid{s}}{\Varid{z}}}}
\\
	\ensuremath{\Conid{A}}
&
&
&
	\ensuremath{\mathrm{1}\mathbin{+}\Conid{A}}
		\ar[lll]_{\ensuremath{\alt{\kons{\Varid{z}}}{\Varid{s}}}}
}
\end{eqnarray*}

%

\paragraph{``Left'' Peano folding (Danvy)}

``Tail recursion":

\begin{eqnarray*}
\ensuremath{\begin{lcbr}\Varid{forl}\;\Varid{s}\;\Varid{z}\;\mathrm{0}\mathrel{=}\Varid{z}\\\Varid{forl}\;\Varid{s}\;\Varid{z}\;(\Varid{n}\mathbin{+}\mathrm{1})\mathrel{=}\Varid{forl}\;\Varid{s}\;(\Varid{s}\;\Varid{z})\;\Varid{n}\end{lcbr}}
\end{eqnarray*}

cf.

\begin{quote}\small\wine
\begin{tabbing}\ttfamily
~a~for\char95{}s\char95{}z~\char40{}int~n\char41{}~\char123{}\\
\ttfamily ~~~int~r\char61{}z\char59{}\\
\ttfamily ~~~int~j\char59{}\\
\ttfamily ~~~for~\char40{}j\char61{}1\char59{}j\char60{}n\char43{}1\char59{}j\char43{}\char43{}\char41{}~\char123{}r\char61{}s\char40{}r\char41{}\char59{}\char125{}\\
\ttfamily ~~~return~r\char59{}\\
\ttfamily ~\char125{}\char59{}
\end{tabbing}
\end{quote}
\vfill

\footnotesize

% Olivier \cite{Da19}. Folding left and right over Peano numbers. J. Funct. Program., 29:e6.

%

\paragraph{``Left'' Peano folding (Danvy)}

\emskip
\fbox{
\includegraphics[width=1.0\textwidth]{danvy.png}
}

\vfill

\footnotesize


\paragraph{Left Peano folding (Danvy)}
As it turns out,
\begin{eqnarray*}
	\ensuremath{\for{\cdot }{\cdot }\mathrel{=}\Varid{forl}}
\end{eqnarray*}
follows from the \emph{adjoint recursion} theorem via contravariant exponentials:

\begin{center}
\ensuremath{{\blue ({\Conid{K}}^{\anonymous })\mathbin\dashv ({\Conid{K}}^{\anonymous })}}
\end{center}

Let us recall:
\begin{eqnarray*}
\xymatrix{
	\ensuremath{{\Conid{K}}^{\Conid{A}}\leftarrow \Conid{B}}
 		\ar@/^1pc/[rr]^{\ensuremath{\mathsf{flip}\ \cdot }}
&
        \iso
&
	\ensuremath{\Conid{A}\to {\Conid{K}}^{\Conid{B}}}
 		\ar@/^1pc/[ll]^{\ensuremath{\mathsf{flip}\ \cdot }}
}
\end{eqnarray*}
(arrows reversed on the left side due to contravariance) where
\wine
\begin{tabbing}\ttfamily
~flip~\char58{}\char58{}~\char40{}a~\char45{}\char62{}~b~\char45{}\char62{}~c\char41{}~\char45{}\char62{}~b~\char45{}\char62{}~a~\char45{}\char62{}~c\\
\ttfamily ~flip~f~b~a~\char61{}~f~a~b
\end{tabbing}
%

\paragraph{Left Peano folding (Danvy)}
Details: \emskip

\begin{quote}
	\ensuremath{\fun F \;\Conid{X}\mathrel{=}\mathrm{1}\mathbin{+}\Conid{X}} (Peano recursion)
\\
	\ensuremath{\fun L \;\Conid{X}\mathrel{=}{\Conid{K}}^{\Conid{X}}} (contravariant)
%\\
%	|fR X = expn K X|
\\
	\ensuremath{\lceil \Varid{f}\rceil\mathrel{=}\mathsf{flip}\ \Varid{f}}
\\
	\ensuremath{\epsilon \mathrel{=}\Varid{fid}} ~~~~ (flipped identity)
\end{quote}

Concerning \ensuremath{\fun G } \vskip -1em

\begin{eqnarray*}
	\ensuremath{\fun L \;\fun F \;\Conid{X}\mathrel{=}{\Conid{K}}^{\mathrm{1}\mathbin{+}\Conid{X}}\cong\Conid{K} \times {\Conid{K}}^{\Conid{X}}\mathrel{=}\Conid{K} \times \fun L \;\Conid{X}\mathrel{=}\fun G \;\fun L \;\Conid{X}}
\end{eqnarray*}

leads to  \vskip -1em
\begin{eqnarray*}
\ensuremath{\fun G \;\Conid{X}\mathrel{=}\Conid{K} \times \Conid{X}}
\end{eqnarray*}
%

\paragraph{Diagrams}
\small
\ensuremath{(\Conid{K} \times )}-\emph{hylo} (\ensuremath{{\cat{C}}^{\Varid{op}}}):
\begin{eqnarray*}
\xymatrix{
	\ensuremath{{\Conid{K}}^{\N_0}}
		\ar@/^1.5pc/[rrr]^-{\ensuremath{{\Conid{K}}^{\mathsf{in}_{\fun T}}\mathrel{=}( \comp \mathsf{in}_{\fun T})}}
&
&
	\ensuremath{\Conid{K} \times {\Conid{K}}^{\N_0}}
		\ar[r]^{\ensuremath{\phi }}
&
	\ensuremath{{\Conid{K}}^{\mathrm{1}\mathbin{+}\N_0}}
\\
	\ensuremath{\Conid{K}}
		\ar[rr]_{\ensuremath{\Varid{h}}}
		\ar[u]^{\ensuremath{\Varid{f}}}
&
&
	\ensuremath{\Conid{K} \times \Conid{K}}
		\ar[u]_{\ensuremath{{id} \times \Varid{f}}}
}
\end{eqnarray*}

\emskip

Adjoint \ensuremath{{\Conid{K}}^{\mathbin{-}}}-\emph{cata} (\ensuremath{\cat{C}}):
\begin{eqnarray*}
\xymatrix@R=1.5em{
	\ensuremath{\N_0}
		\ar[d]_{\ensuremath{\mathsf{flip}\ \Varid{f}}}
&
&
&
	\ensuremath{\mathrm{1}\mathbin{+}\N_0}
		\ar[lll]_{\ensuremath{\mathsf{in}_{\fun T}}}
		\ar[d]_{\ensuremath{{id}\mathbin{+}\mathsf{flip}\ \Varid{f}}}
\\
	\ensuremath{{\Conid{K}}^{\Conid{K}}}
&
&
&
	\ensuremath{\mathrm{1}\mathbin{+}{\Conid{K}}^{\Conid{K}}}
		\ar[lll]_{\ensuremath{\mathsf{flip}\ \phi  \comp ({id} \times \Varid{fid}) \comp \Varid{h}}}
\\
	\ensuremath{\Conid{K}}
		\ar[r]^-{\ensuremath{\Varid{h}}}
&
	\ensuremath{\Conid{K} \times \Conid{K}}
		\ar[r]^-{\ensuremath{{id} \times \Varid{fid}}}
&
	\ensuremath{\Conid{K} \times {\Conid{K}}^{{\Conid{K}}^{\Conid{K}}}}
		\ar[r]^-{\ensuremath{\phi }}
&
	\ensuremath{{\Conid{K}}^{\mathrm{1}\mathbin{+}{\Conid{K}}^{\Conid{K}}}}
}
\end{eqnarray*}
%

\paragraph{Diagrams (\ensuremath{\phi })}
Concerning
\begin{eqnarray*}
\xymatrix{
&
&
	\ensuremath{\Conid{K} \times {\Conid{K}}^{\N_0}}
		\ar[r]^{\ensuremath{\phi }}
&
	\ensuremath{{\Conid{K}}^{\mathrm{1}\mathbin{+}\N_0}}
}
\end{eqnarray*}
let us flip it:
\begin{eqnarray}
\xymatrix@R=3em{
	\ensuremath{\mathrm{1}}
		\ar[r]^{\ensuremath{i_1}}
		\ar[dr]_{\ensuremath{\kons{\p1}}}
&
	\ensuremath{\mathrm{1}\mathbin{+}\N_0}
		\ar[d]^{\ensuremath{\mathsf{flip}\ \phi }}
&
	\ensuremath{\N_0}
		\ar[l]^{\ensuremath{i_2}}
		\ar[dl]^-{\ensuremath{\mathsf{flip}\ \p2}}
\\
	\label{eq:phi-flipped}
&
	\ensuremath{{\Conid{K}}^{\Conid{K} \times {\Conid{K}}^{\N_0}}}
}
&&
	\ensuremath{\phi \mathrel{=}\mathsf{flip}\ \alt{\kons{\p1}}{\mathsf{flip}\ \p2}}
\\
	\nonumber
\end{eqnarray}

\emph{NB}: It can be shown that \ensuremath{\phi } is nothing else than \vskip -1em

\begin{eqnarray}
	\ensuremath{\phi \;(\Varid{k},\Varid{f})\mathrel{=}\alt{\kons{\Varid{k}}}{\Varid{f}}}
	\label{eq:211022a}
\end{eqnarray}

%

\paragraph{Reverse specifying \ensuremath{\Varid{forl}}}
\begin{eqnarray*}
\start
	\ensuremath{\begin{lcbr}\Varid{forl}\;\Varid{s}\;\Varid{z}\;\mathrm{0}\mathrel{=}\Varid{z}\\\Varid{forl}\;\Varid{s}\;\Varid{z}\;(\Varid{n}\mathbin{+}\mathrm{1})\mathrel{=}\Varid{forl}\;\Varid{s}\;(\Varid{s}\;\Varid{z})\;\Varid{n}\end{lcbr}}
%
\just\equiv{ introduce shorthand \ensuremath{\Varid{f}\mathrel{=}\Varid{forl}\;\Varid{s}} }
%
	\ensuremath{\begin{lcbr}\Varid{f}\;\Varid{z}\;\mathrm{0}\mathrel{=}\Varid{z}\\\Varid{f}\;\Varid{z}\;(\Varid{n}\mathbin{+}\mathrm{1})\mathrel{=}\Varid{f}\;(\Varid{s}\;\Varid{z})\;\Varid{n}\end{lcbr}}
%
\just\equiv{ drop \ensuremath{\Varid{n}} ; Peano algebra \ensuremath{\mathsf{in}_{\fun T}\mathrel{=}\alt{\kons{\mathrm{0}}}{\mathsf{succ}}} }
%
	\ensuremath{\Varid{f}\;\Varid{z} \comp \mathsf{in}_{\fun T}\mathrel{=}\alt{\kons{\Varid{z}}}{\Varid{f}\;(\Varid{s}\;\Varid{z})}}
%
\just\equiv{introduce \ensuremath{\phi \;(\Varid{k},\Varid{f})\mathrel{=}\alt{\kons{\Varid{k}}}{\Varid{f}}} (\ref{eq:211022a}) }
%
	\ensuremath{\Varid{f}\;\Varid{z} \comp \mathsf{in}_{\fun T}\mathrel{=}\phi \;(\Varid{z},\Varid{f}\;(\Varid{s}\;\Varid{z}))}
%
\end{eqnarray*}
%

\paragraph{Reverse specifying \ensuremath{\Varid{forl}}}

\vskip -2em

\begin{eqnarray*}
\start
%
\just\equiv{ introduce \ensuremath{( \comp \mathsf{in}_{\fun T})} and  drop \ensuremath{\Varid{z}} }
%
	\ensuremath{( \comp \mathsf{in}_{\fun T}) \comp \Varid{f}\mathrel{=}\phi  \comp \conj{{id}}{\Varid{f} \comp \Varid{s}}}
%
\just\equiv{ introduce \ensuremath{\Varid{h}\mathrel{=}\conj{{id}}{\Varid{s}}}; products}
%
	\ensuremath{( \comp \mathsf{in}_{\fun T}) \comp \Varid{f}\mathrel{=}\phi  \comp ({id} \times \Varid{f}) \comp \Varid{h}}
%
\just\equiv{ recall \ensuremath{\fun G \;\Varid{f}\mathrel{=}{id} \times \Varid{f}} and contravariant \ensuremath{\fun L \;\Varid{f}\mathrel{=}{\Conid{K}}^{\Varid{f}}\mathrel{=}( \comp \Varid{f})} }
%
	\ensuremath{\fun L \;\mathsf{in}_{\fun T} \comp \Varid{f}\mathrel{=}\phi  \comp (\fun G \;\Varid{f}) \comp \Varid{h}}
%
\end{eqnarray*}
for \ensuremath{\Varid{h}\mathrel{=}\conj{{id}}{\Varid{s}}}.
\vskip 1em
By the ``adjoint fold" theorem, \ensuremath{\Varid{f}} (i.e. \ensuremath{\Varid{forl}\;\Varid{s}}) is \vskip -1em

\begin{eqnarray*}
	\ensuremath{\Varid{forl}\;\Varid{s}\mathrel{=}\mathsf{flip}\ \llparenthesis\,\mathsf{flip}\ \phi  \comp ({id} \times \Varid{fid}) \comp \conj{{id}}{\Varid{s}}\,\rrparenthesis}
\end{eqnarray*}

%

\paragraph{Towards \ensuremath{\Varid{forl}\mathrel{=}\for{\cdot }{\cdot }}}
Since
\begin{eqnarray}
	\ensuremath{\phi  \comp ({id} \times \Varid{fid}) \comp \conj{{id}}{\Varid{s}}\mathrel{=}\alt{\kons{{id}}}{( \comp \Varid{s})}}
\end{eqnarray}
(proof in the appendix) we have:
\begin{eqnarray}
	\ensuremath{\mathsf{flip}\ \Varid{forl}\;\Varid{s}} \wider= \ensuremath{\llparenthesis\,\alt{\kons{{id}}}{( \comp \Varid{s})}\,\rrparenthesis} \wider= \ensuremath{\for{ \comp \Varid{s}}{{id}}}
	\label{eq:flip-forl}
\end{eqnarray}
\vskip 1ex
Then \ensuremath{\for{\cdot }{\cdot }\mathrel{=}\Varid{forl}} holds:
\small
\begin{eqnarray*}
\start
	\ensuremath{\for{\Varid{s}}{\cdot }\mathrel{=}\Varid{forl}\;\Varid{s}}
%
\just\equiv{ isomorphism \ensuremath{\mathsf{flip}\ \cdot }; (\ref{eq:flip-forl}) }
%
	\ensuremath{\mathsf{flip}\ \for{\Varid{s}}{\cdot }\mathrel{=}\llparenthesis\,\alt{\kons{{id}}}{( \comp \Varid{s})}\,\rrparenthesis}
%
\just\equiv{ cata-universal }
%
	\ensuremath{\begin{lcbr}\mathsf{flip}\ \for{\Varid{s}}{\cdot } \comp \kons{\mathrm{0}}\mathrel{=}\kons{{id}}\\\mathsf{flip}\ \for{\Varid{s}}{\cdot } \comp \mathsf{succ}\mathrel{=}( \comp \Varid{s}) \comp \mathsf{flip}\ \for{\Varid{s}}{\cdot }\end{lcbr}}
\end{eqnarray*}
%

\paragraph{\ensuremath{\Varid{forl}\mathrel{=}\for{\cdot }{\cdot }}}
\small\vskip -1em
\begin{eqnarray*}
\start
%
\just\equiv{ \ensuremath{\mathsf{flip}\ \cdot } absorption and fusion }
%
	\ensuremath{\begin{lcbr}\mathsf{flip}\ \for{\Varid{s}}{\cdot } \comp \kons{\mathrm{0}}\mathrel{=}\kons{{id}}\\\mathsf{flip}\ ( \comp \mathsf{succ}) \comp \for{\Varid{s}}{\cdot }\mathrel{=}\mathsf{flip}\ \for{\Varid{s}}{\cdot } \comp \Varid{s}\end{lcbr}}
%
\just\equiv{ drop \ensuremath{\mathsf{flip}\ \cdot }; go one-step pointwise }
%
	\ensuremath{\begin{lcbr}\mathsf{flip}\ \for{\Varid{s}}{\cdot }\;\mathrm{0}\mathrel{=}{id}\\\for{\Varid{s}}{\Varid{z}} \comp \mathsf{succ}\mathrel{=}\for{\Varid{s}}{\Varid{s}\;\Varid{z}}\end{lcbr}}
%
\just\equiv{ \ensuremath{\for{\Varid{s}}{\Varid{s}\;\Varid{z}}\mathrel{=}\Varid{s} \comp \for{\Varid{s}}{\Varid{z}}} easy to prove (appendix); pointwise }
%
	\ensuremath{\begin{lcbr}\for{\Varid{s}}{\Varid{z}}\;\mathrm{0}\mathrel{=}\Varid{z}\\\for{\Varid{s}}{\Varid{z}}\;(\Varid{n}\mathbin{+}\mathrm{1})\mathrel{=}\Varid{s}\;\for{\Varid{s}}{\Varid{z}}\;\Varid{n}\end{lcbr}}
%
\just\equiv{ definition of \ensuremath{\for{\Varid{s}}{\Varid{z}}} }
%
	\ensuremath{\Varid{true}}
\qed
\end{eqnarray*}
%

\paragraph{Other instances: \ensuremath{\Varid{pfold}}}
\small
The uniqueness of the \ensuremath{\Varid{pfold}} combinator by Alberto \cite{Pa02} is
granted by the generic adjoint fold theorem for \ensuremath{{\blue \fun G \mathrel{=}( \times \Conid{K}) \comp \fun F }}
(\ensuremath{\phi \mathrel{=}\conj{\tau }{\p2}} assuming \ensuremath{\fun F } has \emph{strength} \ensuremath{\tau }):

\begin{eqnarray*}
\wine
\xymatrix{
	\ensuremath{\muF  \times \Conid{K}}
		\ar[d]_{\ensuremath{\Varid{pfold}\;\Varid{f}}}
&
&
	\ensuremath{\fun F \;(\muF  \times \Conid{K}) \times \Conid{K}}
		\ar[d]^{\ensuremath{\fun F \;(\Varid{pfold}\;\Varid{f}) \times {id}}}
&
	\ensuremath{\fun F \;\muF  \times \Conid{K}}
		\ar@/_1.5pc/[lll]_-{\ensuremath{\mathsf{in}_{\fun T} \times {id}}}
		\ar[l]^-{\ensuremath{\phi }}
\\
	\ensuremath{\Conid{A}}
&
&
	\ensuremath{\fun F \;\Conid{A} \times \Conid{K}}
		\ar[ll]_{\ensuremath{\Varid{h}}}
}
\end{eqnarray*}

\emskip

Adjoint \ensuremath{\fun F }-cata:
\begin{eqnarray*}
\wine
\myxym{
	\ensuremath{\muF }
		\ar[d]_{\ensuremath{\mathbf{curry}\hskip 1pt {\Varid{f}}}}
&
&
&
	\ensuremath{\fun F \;\muF }
		\ar[lll]_{\ensuremath{\mathsf{in}_{\fun T}}}
		\ar[d]^{\ensuremath{\fun F \;(\mathbf{curry}\hskip 1pt {\Varid{f}})}}
\\
	\ensuremath{{\Conid{A}}^{\Conid{K}}}
&
&
&
	\ensuremath{\fun F \;{\Conid{A}}^{\Conid{K}}}
		\ar[lll]^{\ensuremath{\mathbf{curry}\hskip 1pt {(\Varid{h} \comp (\fun F \;\mathsf{ev} \times {id}) \comp \phi )}}}
}
\end{eqnarray*}
%

\paragraph{Other instances: quantamorphisms}
	Quantamorphisms \citep{NBO21}:
\begin{itemize}
\item	Typed matrices \ensuremath{\Conid{Q}\mathbin{:}\muF  \times \Conid{A}\to \Conid{A}} that are \ensuremath{\p1}-complemented, \ensuremath{\conj{\p1}{\Conid{Q}}\mathbin{:}\muF  \times \Conid{A}\to \muF  \times \Conid{A}}, so as to achieve \emph{reversibility}
\item	Then generalized to arbitrary \emph{unitary} matrices (= quantum computations)
\item[]
\begin{eqnarray*}
\ensuremath{\Varid{fstcbox}\;\muF \;\Conid{A}\;(\Conid{Q})\;\muF \;\Conid{A}}
\end{eqnarray*}
\item[]
\item	Simulations use \emph{adjoint folds} granted by the \emph{vector space} monad
\item	Restricted to 1st degree polynomial \ensuremath{\fun F } (no-cloning...)
\end{itemize}
%

\paragraph{Other instances: SOS}
\emph{Structural operational semantics} ({SOS}) rules, e.g.
\begin{eqnarray*}
	\frac{\ensuremath{\begin{lcbr}({\red \Varid{s}},\Varid{s})\mathbin{\char126 >}\Varid{s'}\\({\red \Varid{ss}},\Varid{s'})\mathbin{\char126 >}\Varid{s''}\end{lcbr}}}{\ensuremath{({\red \{\mskip1.5mu \Varid{s};\Varid{ss}\mskip1.5mu\}},\Varid{s})\mathbin{\char126 >}\Varid{s''}}}
\end{eqnarray*}
\emskip
In general, relations of type
\begin{eqnarray*}
\ensuremath{(\mathbin{\char126 >})\mathbin{:}\muF  \times \Conid{S}\to \Conid{S}}
\end{eqnarray*}
where \ensuremath{(\mathbin{\char126 >})} is structurally decomposed over the (abstract) \emph{syntax} of language \ensuremath{\Varid{mF}}, captured by \ensuremath{\mathsf{in}_{\fun T}\mathbin{:}\fun F \;\muF \to \muF }

%

\paragraph{The ``Alloy adjunction"}
% [ Cf.\  Naumann \cite{Na16} and \cite{Ol08a} , 20151202 ] For relations, the above generalizes the power transpose to

Relational ``currying" leads to relation-valued functions: \vskip -1ex
\begin{eqnarray*}
	\ensuremath{\Conid{B} \times \Conid{C}\to \Conid{D}} & \ensuremath{\cong} & \ensuremath{{(\Conid{C}\to \Conid{D})}^{\Conid{B}}}
\end{eqnarray*}

(In Alloy, relational type \ensuremath{\Conid{B} \times \Conid{C}\to \Conid{D}} is written \ensuremath{\Conid{B}\to \Conid{C}\to \Conid{D}}.)

\emskip

In fact:

\begin{eqnarray*}
\myxym{
	\ensuremath{\Conid{B} \times \Conid{C}\to \Conid{D}}
		\ar[r]_{\ensuremath{\Lambda{}}}
		\ar@/^1.5pc/[rrr]^-{\ensuremath{\lceil \anonymous \rceil}}
&
	\ensuremath{{\fun P{\Conid{D}}}^{\Conid{B} \times \Conid{C}}}
		\ar[r]_{\ensuremath{\mathbf{curry}\hskip 1pt {}}}
&
	\ensuremath{{({\fun P \;\Conid{D}}^{\Conid{C}})}^{\Conid{B}}}
		\ar[r]_{\ensuremath{{(\mathbin\in  \comp )}^{\Conid{B}}}}
&
	\ensuremath{{(\Conid{C}\to \Conid{D})}^{\Conid{B}}}
\\
}
\end{eqnarray*}
%

\paragraph{Folding over the ``Alloy adjunction"}
\ensuremath{\fun G } relational hylo (\ensuremath{\cat{R}}):
\begin{eqnarray*}
\wine
\xymatrix{
	\ensuremath{\muF  \times \Conid{C}}
		\ar[d]_{\ensuremath{\Conid{X}}}
&
&
	\ensuremath{\fun G \;(\muF  \times {id})}
		\ar[d]_{\ensuremath{\fun G \;\Conid{X}}}
&
	\ensuremath{\fun F \;\muF  \times \Conid{C}}
		\ar@/_1.5pc/[lll]_-{\ensuremath{\mathsf{in}_{\fun T} \times \Conid{C}}}
		\ar[l]^{\ensuremath{\phi }}
\\
	\ensuremath{\Conid{D}}
&
&
	\ensuremath{\fun G \;\Conid{D}}
		\ar[ll]_{\ensuremath{\Conid{R}}}
}
\end{eqnarray*}

\emskip

Adjoint functional \ensuremath{\fun F }-cata (\ensuremath{\cat{S}}):
\begin{eqnarray*}
\wine
\myxym{
	\ensuremath{\muF }
		\ar[d]_{\ensuremath{\lceil \Varid{f}\rceil}}
&
&
&
	\ensuremath{\fun F \;\muF }
		\ar[lll]_{\ensuremath{\mathsf{in}_{\fun T}}}
		\ar[d]_{\ensuremath{\fun F \;\lceil \Varid{f}\rceil}}
\\
	\ensuremath{\Conid{C}\to \Conid{D}}
&
&
&
	\ensuremath{\fun F \;(\Conid{C}\to \Conid{D})}
		\ar[lll]_{\ensuremath{\lceil \Varid{h} \comp \fun G \;\epsilon  \comp \phi \rceil}}
}
\end{eqnarray*}
%

\paragraph{SOS}
\ensuremath{\Conid{S}} denotes the state of the \emph{abstract machine}:
\begin{eqnarray*}
\wine
\xymatrix{
	\ensuremath{\muF  \times \Conid{S}}
		\ar[d]_{\ensuremath{(\mathbin{\char126 >})}}
&
&
	\ensuremath{\fun G \;(\muF  \times {id})}
		\ar[d]_{\ensuremath{\fun G \;(\mathbin{\char126 >})}}
&
	\ensuremath{\fun F \;\muF  \times {id}}
		\ar@/_1.5pc/[lll]_-{\ensuremath{\mathsf{in}_{\fun T} \times {id}}}
		\ar[l]^{\ensuremath{\phi }}
\\
	\ensuremath{\Conid{S}}
&
&
	\ensuremath{\fun G \;\Conid{S}}
		\ar[ll]^{\ensuremath{\mathbin{\char126 >}_{\Conid{R}}}}
}
\end{eqnarray*}
\emskip
SOS rules structurally derived by expanding

\begin{eqnarray*}
	\frac{\ensuremath{\begin{lcbr}\Varid{t}\mathrel{=}\mathsf{in}_{\fun T}\;\Varid{ts}\\\phi \;(\Varid{ts},\Varid{s})\;(\fun G \;(\mathbin{\char126 >}))\;\Varid{ss}\\\Varid{ss}\;\mathbin{\char126 >}_{\Conid{R}}\;\Varid{s'}\end{lcbr}}}{\ensuremath{(\Varid{t},\Varid{s})\mathbin{\char126 >}\Varid{s'}}}
\end{eqnarray*}
%

\paragraph{SOS}
Abstract SOS rule
\begin{eqnarray*}
	\frac{\ensuremath{\begin{lcbr}\Varid{t}\mathrel{=}\mathsf{in}_{\fun T}\;\Varid{ts}\\\phi \;(\Varid{ts},\Varid{s})\;(\fun G \;(\mathbin{\char126 >}))\;\Varid{ss}\\\Varid{ss}\;\mathbin{\char126 >}_{\Conid{R}}\;\Varid{s'}\end{lcbr}}}{\ensuremath{(\Varid{t},\Varid{s})\mathbin{\char126 >}\Varid{s'}}}
\end{eqnarray*}
is the pointfree
\begin{eqnarray*}
	\ensuremath{\underbrace{(\mathbin{\char126 >}_{\Conid{R}}) \comp \fun G \;(\mathbin{\char126 >}) \comp \phi  \comp (\conv{\mathsf{in}_{\fun T}} \times {id})}_{\fun H \;(\mathbin{\char126 >})}\; \subseteq \;(\mathbin{\char126 >})}
\end{eqnarray*}
\emskip
\emskip
So, \ensuremath{(\mathbin{\char126 >})} is a \emph{pre-fixpoint} of \ensuremath{\fun H }.
%

\paragraph{SOS}
In summary:
\vskip 0pt
\begin{eqnarray*}
\xarrayin{
	\ensuremath{\underbrace{(\mathbin{\char126 >})}_{\Conid{SOS}}}
&
	\supseteq
&
	\mu\ensuremath{\fun H }
&
	=
&
	\ensuremath{\lfloor \underbrace{\llparenthesis\,\lceil (\mathbin{\char126 >}_{\Conid{R}}) \comp \fun G \;\epsilon  \comp \phi \rceil\,\rrparenthesis}_{\Conid{DS}}\rfloor}
}
\end{eqnarray*}
\emskip
That is,
\begin{quote}
The adjoint fold of a (relational) \emph{SOS} is a correct by construction \emph{denotational semantics} (DS) for the same language.
\end{quote}
\small
\rule{0pt}{1em}\hfill (Sketchy...)
%

\paragraph{Naturality of \ensuremath{\conv{\alt{\conv{\p1}}{\conv{\p2}}}} for functions}
Type:
\begin{eqnarray*}
	\ensuremath{\conv{\alt{\conv{\p1}}{\conv{\p2}}}\mathbin{:}(\Conid{A} \times {\Conid{A}}^{*})\to (\Conid{A}\mathbin{+}{\Conid{A}}^{*})}
\end{eqnarray*}
Proof:
\begin{eqnarray*}
\start
	\ensuremath{\conv{\alt{\conv{\p1}}{\conv{\p2}}} \comp (\Varid{f} \times {\Varid{f}}^{*})\mathrel{=}(\Varid{f}\mathbin{+}{\Varid{f}}^{*}) \comp \conv{\alt{\conv{\p1}}{\conv{\p2}}}}
%
\just\equiv{converses}
%
	\ensuremath{(\conv{\Varid{f}} \times \conv{({\Varid{f}}^{*})}) \comp \alt{\conv{\p1}}{\conv{\p2}}\mathrel{=}\alt{\conv{\p1}}{\conv{\p2}} \comp (\conv{\Varid{f}}\mathbin{+}\conv{({\Varid{f}}^{*})})}
%
\just\equiv{coproducts and converses}
%
	\ensuremath{\alt{\conv{(\p1 \comp (\Varid{f} \times {\Varid{f}}^{*}))}}{\conv{(\p2 \comp (\Varid{f} \times {\Varid{f}}^{*}))}}\mathrel{=}\alt{\conv{(\Varid{f} \comp \p1)}}{\conv{({\Varid{f}}^{*} \comp \p2)}}}
%
\just\equiv{products and converses}
%
	\ensuremath{\alt{\conv{(\Varid{f} \comp \p1)}}{\conv{({\Varid{f}}^{*} \comp \p2)}}\mathrel{=}\alt{\conv{(\Varid{f} \comp \p1)}}{\conv{({\Varid{f}}^{*} \comp \p2)}}}
\end{eqnarray*}
%

\paragraph{Proof of \ensuremath{\phi  \comp ({id} \times \Varid{fid}) \comp \conj{{id}}{\Varid{s}}\mathrel{=}\alt{\kons{{id}}}{( \comp \Varid{s})}}}
\label{pg:211024a}
\small
\begin{eqnarray*}
\start
	\ensuremath{\mathsf{flip}\ \phi  \comp ({id} \times \Varid{fid}) \comp \conj{{id}}{\Varid{s}}}
%
\just={ products; absorption: \ensuremath{{\Conid{K}}^{\Varid{g}} \comp \mathsf{flip}\ \Varid{h}\mathrel{=}\mathsf{flip}\ \Varid{h} \comp \Varid{g}}} % (\ref{eq:expn-abs})
%
	\ensuremath{{\Conid{K}}^{\conj{{id}}{\Varid{fid} \comp \Varid{s}}} \comp \mathsf{flip}\ \phi }
%
\just={ (\ref{eq:phi-flipped}) ; \ensuremath{{\Conid{K}}^{\Varid{f}}\mathrel{=}( \comp \Varid{f})} }
%
	\ensuremath{( \comp \conj{{id}}{\Varid{fid} \comp \Varid{s}}) \comp \alt{\kons{\p1}}{\mathsf{flip}\ \p2}}
%
\just={ coproducts; constant functions; absorption (\ref{eq:phi-flipped}) }
%
	\ensuremath{\alt{\kons{{id}}}{\mathsf{flip}\ \p2 \comp \conj{{id}}{\Varid{fid} \comp \Varid{s}}}}
%
\just={ products; \ensuremath{\mathsf{flip}\ \Varid{fid} \comp \Varid{h}\mathrel{=}( \comp \Varid{h})} } % (\ref{eq:expn-fun})
%
%	|either (const id) (flip(epsilon.s))|
%
%\just={ exponential functor (\ref{eq:expn-fun}) }
%
	\ensuremath{\alt{\kons{{id}}}{( \comp \Varid{s})}}
\qed
\end{eqnarray*}
%

\paragraph{\ensuremath{\for{\Varid{s}}{\Varid{s}\;\Varid{z}}\mathrel{=}\Varid{s} \comp \for{\Varid{s}}{\Varid{z}}}}
\begin{eqnarray*}
\start
	\ensuremath{\llparenthesis\,\alt{\kons{\Varid{s}\;\Varid{z}}}{\Varid{s}}\,\rrparenthesis\mathrel{=}\Varid{s} \comp \llparenthesis\,\alt{\kons{\Varid{z}}}{\Varid{s}}\,\rrparenthesis}
%
\just\implied{fusion}
%
	\ensuremath{\begin{lcbr}\Varid{s} \comp \kons{\Varid{z}}\mathrel{=}\kons{\Varid{s}\;\Varid{z}}\\\Varid{s} \comp \Varid{s}\mathrel{=}\Varid{s} \comp \Varid{s}\end{lcbr}}
%
\just\equiv{ constant functions}
%
	\ensuremath{\Varid{true}}
\qed
\end{eqnarray*}

%

\paragraph{}
with lax-natural transformations

\begin{eqnarray*}
\start
	\ensuremath{\Lambda{\Conid{X}}\mathrel{=}\llparenthesis\,\Lambda{(\Conid{R} \comp \fun G \;\mathbin\in  \comp \Phi )}\,\rrparenthesis}
%
\just\equiv{ (\ref{eq:210111a}) }
%
	\ensuremath{\Conid{X} \comp \fun J \;\mathsf{in}_{\fun T}\mathrel{=}\Conid{R} \comp \fun G \;\mathbin\in  \comp \Phi  \comp \fun J \;\fun F \;(\Lambda{\Conid{X}})}
%
\just\implies{ {\wine lax}-natural-\ensuremath{\Phi }: \ensuremath{\Varid{wine}\;(\Phi  \comp \fun J \;(\fun F \;\Varid{f})\; \subseteq \;\fun G \;(\fun J \;\Varid{f}) \comp \Phi )} } % 200204c
%
	\ensuremath{\Conid{X} \comp \fun J \;\mathsf{in}_{\fun T}\; \subseteq \;\Conid{R} \comp \fun G \;\mathbin\in  \comp \fun G \;\fun J \;(\Lambda{\Conid{X}}) \comp \Phi }
%
\just\equiv{ functor \ensuremath{\fun G }; cancellation \ensuremath{\mathbin\in  \comp \fun J \;(\Lambda{\Conid{X}})\mathrel{=}\Conid{X}} (\ref{eq:200204d}) }
%
	\ensuremath{\Conid{X} \comp \fun J \;\mathsf{in}_{\fun T}\; \subseteq \;\Conid{R} \comp \fun G \;\Conid{X} \comp \Phi }
%qed
\end{eqnarray*}
%

\paragraph{}
\ensuremath{\Varid{f}\mathbin{:}\Conid{A}\to \Conid{B}} then build \ensuremath{\Varid{f'}\mathbin{:}\Conid{A}\to {\Conid{C}}^{({\Conid{C}}^{\Conid{B}})}}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\eta  \comp \Varid{f}\mathrel{=}\mathsf{flip}\ {id} \comp \Varid{f}\mathrel{=}\mathsf{flip}\  \comp \Varid{f}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathsf{flip}\  \comp \Varid{f}\;\Varid{g}\;\Varid{a}\mathrel{=}\Varid{g}\;(\Varid{f}\;\Varid{a}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Left Peano recursion Danvy

mapAccumRight
%

\paragraph{}
%

\paragraph{}
which is converted into the adjoint \ensuremath{\fun F }-catamorphism (righthand side):
\begin{eqnarray*}
\myxym{
	\ensuremath{\muF }
&
&
&
	\ensuremath{\fun F \;\muF }
		\ar[lll]_{\ensuremath{\mathsf{in}_{\fun T}}}
\\
	\ensuremath{\fun L \;\Conid{A}}
		\ar[u]_{\ensuremath{\lfloor \Varid{f}\rfloor}}
		\ar[rrr]_{\ensuremath{\lfloor \phi  \comp \fun G \;\eta  \comp \Varid{h}\rfloor}}
&
&
&
	\ensuremath{\fun F \;\fun L \;\Conid{A}}
		\ar[u]_{\ensuremath{\fun F \;\lfloor \Varid{f}\rfloor}}
\\
	\ensuremath{\Conid{A}}
		\ar[r]_{\ensuremath{\Varid{h}}}
&
	\ensuremath{\fun G \;\Conid{A}}
		\ar[r]_{\ensuremath{\fun G \;\eta }}
&
	\ensuremath{\fun G \;\fun R \;\fun L \;\Conid{A}}
		\ar[r]_{\ensuremath{\phi }}
&
	\ensuremath{\fun R \;\fun F \;\fun L \;\Conid{A}}
\\
&
	\ensuremath{\lfloor \Varid{f}\rfloor\mathrel{=}\mathopen{[\!(}\lfloor \phi  \comp \fun G \;\eta  \comp \Varid{h}\rfloor\mathclose{)\!]}}
}
\end{eqnarray*}

%

\paragraph{}
\begin{itemize}
\item	Oleg programmers who draw their programs
\item	chemistry between universals
\item	CBJ book quotation
\item	Denotational to operational semantics shift
\item	...
\end{itemize}
%

\paragraph{Universal glueing}
loctite-universal-glue etc
%includegraphics[width=1.0\textwidth]{loctite-universal-glue.png}
%
%

\paragraph{Universals}
Universal morphism from \ensuremath{\rarrow{\cat{D}}{\fun L }{\cat{C}}} to \ensuremath{\Conid{X}}:
\begin{eqnarray*}
	\ensuremath{\Varid{k}\mathrel{=}\lceil \Varid{f}\rceil}
	\wider\equiv
	\ensuremath{\Varid{u} \comp \fun L \;\Varid{k}\mathrel{=}\Varid{f}}
& \rule{1em}{0pt}&
        \myxym{
	\ensuremath{\cat{D}}
		\ar[r]^{\ensuremath{\fun L }}
&
	\ensuremath{\cat{C}}
\\
	\ensuremath{\Conid{B}}
&
	\ensuremath{\fun L \;\Conid{B}}
		\ar[r]^{\ensuremath{\Varid{u}}}
&
	X
\\
	A
		\ar[u]^{\ensuremath{\Varid{k}\mathrel{=}\lceil \Varid{f}\rceil}}
&
	\ensuremath{\fun L \;\Conid{A}}
	\ar[u]^{\ensuremath{\fun L \;\Varid{k}}}
	\ar[ru]_{f}
}
\end{eqnarray*}
%

\paragraph{}
\ensuremath{\Varid{f}\;\Varid{a}\leq \Varid{x}\Rightarrow \rcb{\exists }{\Varid{b}}{\Varid{a}\leq \Varid{b}}{\Varid{f}\;\Varid{b}\leq \Varid{x}}}

\ensuremath{\Varid{a}\leq \Varid{b}~\Leftrightarrow~\Varid{f}\;\Varid{a}\leq \Varid{b}} pre fixpoint, thus \ensuremath{\Varid{f}\;\Varid{b}\leq \Varid{b}}.

\begin{eqnarray*}
\start
	\ensuremath{\Varid{a}\leq \Varid{b}}
%
\just\implies{}
%
	\ensuremath{\Varid{f}\;\Varid{a}\leq \Varid{f}\;\Varid{b}}
%
\just\implies{ since \ensuremath{\Varid{f}\;\Varid{b}\leq \Varid{b}}}
%
	\ensuremath{\Varid{f}\;\Varid{a}\leq \Varid{b}}
\qed
\end{eqnarray*}
LPP:
\ensuremath{\mu\;\Varid{f}\leq \Varid{b}\Leftarrow\Varid{f}\;\Varid{b}\leq \Varid{b}}
\\
\ensuremath{\Varid{f}\;(\mu\;\Varid{f})\leq \mu\;\Varid{f}}

%

\paragraph{Adjunction \ensuremath{\fun L \mathbin\dashv \fun R }}
\begin{eqnarray*}
\rule{1em}{0pt}
\vcenter{
\xymatrix@R=2ex{
	\ensuremath{\cat{D}}
		\ar@/_1pc/[dd]_{\ensuremath{\fun L }}
\\
	\dashv
\\
	\ensuremath{\cat{C}}
		\ar@/_1pc/[uu]_{\ensuremath{\fun R }}
}}
& \rule{1em}{0pt} &
\vcenter{
\xymatrix{
	\ensuremath{\cat{C}\;(\fun L \;\Conid{A},\Conid{X})}
 		\ar@/^1pc/[rr]^{\ensuremath{\lceil \cdot \rceil}}
&
	\iso
&
	\ensuremath{\cat{D}\;(\Conid{A},\fun R \;\Conid{X})}
		\ar@/^1pc/[ll]^{\ensuremath{\lfloor \cdot \rfloor}}
}}
\end{eqnarray*}
\emskip
Well known special case (preorders as ``thin" categories):

\begin{eqnarray*}
\rule{1em}{0pt}
\vcenter{
\xymatrix@R=2ex{
	\ensuremath{(\preceq )}
		\ar@/_1pc/[dd]_{\ensuremath{\Varid{f}}}
\\
	\dashv
\\
	\ensuremath{(\leq )}
		\ar@/_1pc/[uu]_{\ensuremath{\Varid{g}}}
}}
& \rule{1em}{0pt} &
\vcenter{
\xymatrix{
	\ensuremath{\Varid{f}\;\Varid{a}\leq \Varid{x}}
 		\ar@/^1pc/[rr]^{\ensuremath{}}
&
	\equiv
&
	\ensuremath{\Varid{a}\preceq \Varid{g}\;\Varid{x}}
		\ar@/^1pc/[ll]^{\ensuremath{}}
}}
\end{eqnarray*}
\hfill \emph{Galois connections}
%

\section{Auxiliary lemmas and proofs}
\label{sec:150329b}
%label{sec:150329a}

\begin{lemma}
Given predicate \ensuremath{\Varid{q}} and function \ensuremath{\Varid{f}},
\begin{eqnarray}
	\ensuremath{(\Varid{q} \comp \Varid{f})\hskip-1pt\mathit{?}} = \ensuremath{\ap{\delta}(\Varid{q}\hskip-1pt\mathit{?} \comp \Varid{f})}
	\label{eq:150924a}
\end{eqnarray}
holds, where
\begin{eqnarray}
	\ensuremath{\ap{\delta}\Conid{R}\mathrel{=}{{id}}\mathbin\cap{\conv{\Conid{R}} \comp \Conid{R}}}
	\label{eq:020624j}
\end{eqnarray}
is the \emph{domain} of \ensuremath{\Conid{R}}.
\\ Proof:
\begin{eqnarray*}
\start
	\ensuremath{(\Varid{q} \comp \Varid{f})\hskip-1pt\mathit{?}}
%
\just={ (\ref{eq:160121c}) }
%
	\ensuremath{{{id}}\mathbin\cap{\frac{\Varid{true}}{\Varid{q} \comp \Varid{f}}}}
%
\just={ since \ensuremath{\frac{\Varid{f}}{\Varid{f}}} is reflexive (\ref{eq:160112e}) }
%
	\ensuremath{{{id}}\mathbin\cap{{\frac{\Varid{f}}{\Varid{f}}}\mathbin\cap{\frac{\Varid{true} \comp \Varid{f}}{\Varid{q} \comp \Varid{f}}}}}
%
\just={ (\ref{eq:160111a}) ; products }
%
	\ensuremath{{{id}}\mathbin\cap{\frac{({{id}}\kr{\Varid{true}}) \comp \Varid{f}}{({{id}}\kr{\Varid{q}}) \comp \Varid{f}}}}
%
\just={ (\ref{eq:160117a}) ; (\ref{eq:160111a}) }
%
	\ensuremath{{{id}}\mathbin\cap{\conv{\Varid{f}} \comp ({{id}}\mathbin\cap{\frac{\Varid{true}}{\Varid{q}}}) \comp \Varid{f}}}
%
\just={ (\ref{eq:160121c}) }
%
	\ensuremath{{{id}}\mathbin\cap{\conv{\Varid{f}} \comp \Varid{q}\hskip-1pt\mathit{?} \comp \Varid{f}}}
%
\just={ (\ref{eq:020624j}) }
%
	\ensuremath{\ap{\delta}(\Varid{q}\hskip-1pt\mathit{?} \comp \Varid{f})}
\qed
\end{eqnarray*}
\end{lemma}
%
The rest of this appendix provides proofs of results left pending in the main text. % \label{sec:150329b}

\paragraph{Proof of property (\ref{eq:160115b})}
\emph{Part (\ensuremath{\Rightarrow})} --- \ensuremath{\frac{\Conid{R}}{\Conid{R}}} is always an equivalence relation, recall \secref{sec:170319a}.
\emph{Part (\ensuremath{\Leftarrow})} --- assume that \ensuremath{\Conid{R}} is an equivalence relation. Then:
% ex 4.49 of page 108 \cite{BM97}
\begin{eqnarray*}
\start
	\ensuremath{\Conid{R}\mathrel{=}\Conid{R}\setminus \Conid{R}}
%
\just\equiv{ since \ensuremath{{\Conid{R}}\subseteq{\Conid{R}\setminus \Conid{R}}} just states that \ensuremath{\Conid{R}} is transitive (\ref{eq:020614b}) }
%
	\ensuremath{{\Conid{R}\setminus \Conid{R}}\subseteq{\Conid{R}}}
%
\just\implied{ since \ensuremath{{\Conid{R} \comp (\Conid{R}\setminus \Conid{R})}\subseteq{\Conid{R}}} by (\ref{eq:020614b}) }
%
	\ensuremath{{\Conid{R}\setminus \Conid{R}}\subseteq{\Conid{R} \comp (\Conid{R}\setminus \Conid{R})}}
	\eqnnewpage
%
\just\implied{ composition is monotone }
%
	\ensuremath{{{id}}\subseteq{\Conid{R}}}
%
\just\equiv{ \ensuremath{\Conid{R}} is reflexive }
%
	\ensuremath{\Varid{true}}
%
\end{eqnarray*}
Then:
\begin{eqnarray*}
\start
	\ensuremath{\Conid{R}\mathrel{=}\frac{\Conid{R}}{\Conid{R}}}
%
\just\equiv{ (\ref{eq:160122a}) ; \ensuremath{\conv{\Conid{R}}\mathbin{/}\conv{\Conid{R}}\mathrel{=}\conv{(\Conid{R}\setminus \Conid{R})}}}
%
	\ensuremath{\Conid{R}\mathrel{=}{\Conid{R}\rdiv \Conid{R}}\mathbin\cap{\conv{(\Conid{R}\setminus \Conid{R})}}}
%
\just\equiv{ \ensuremath{\Conid{R}\mathrel{=}\Conid{R}\setminus \Conid{R}} above }
%
	\ensuremath{\Conid{R}\mathrel{=}{\Conid{R}}\mathbin\cap{\conv{\Conid{R}}}}
%
\just\equiv{ since \ensuremath{\Conid{R}} is symmetric: \ensuremath{\Conid{R}\mathrel{=}\conv{\Conid{R}}} }
%
	\ensuremath{\Varid{true}}
\qed
\end{eqnarray*}

\paragraph{Proof of property (\ref{eq:150406c})}
 % in theorem \ref{th:150406b}:
\emph{Part ($\implies$)} --- show that \ensuremath{\Varid{p}\mathrel{=}\Varid{q} \comp \Varid{f}} follows from \ensuremath{\Varid{f} \comp \Varid{p}\hskip-1pt\mathit{?}\mathrel{=}\Varid{q}\hskip-1pt\mathit{?} \comp \Varid{f}}:
\begin{eqnarray*}
\start
	\ensuremath{\Varid{p}\mathrel{=}\Varid{q} \comp \Varid{f}}
%
\just\equiv{ bijection between predicates and partial identities }
%
	\ensuremath{\Varid{p}\hskip-1pt\mathit{?}\mathrel{=}(\Varid{q} \comp \Varid{f})\hskip-1pt\mathit{?}}
%
\just\equiv{ (\ref{eq:150924a}) ; \ensuremath{\Varid{f} \comp \Varid{p}\hskip-1pt\mathit{?}\mathrel{=}\Varid{q}\hskip-1pt\mathit{?} \comp \Varid{f}} assumed }
%
	\ensuremath{\Varid{p}\hskip-1pt\mathit{?}\mathrel{=}\ap{\delta}(\Varid{f} \comp \Varid{p}\hskip-1pt\mathit{?})}
%
\just\equiv{ \ensuremath{\ap{\delta}(\Conid{R} \comp \Conid{S})\mathrel{=}\ap{\delta}(\ap{\delta}\Conid{R} \comp \Conid{S})}}
%
	\ensuremath{\Varid{p}\hskip-1pt\mathit{?}\mathrel{=}\ap{\delta}(\ap{\delta}\Varid{f} \comp \Varid{p}\hskip-1pt\mathit{?})}
%
\just\equiv{ \ensuremath{\ap{\delta}\Varid{f}\mathrel{=}{id}}}
%
	\ensuremath{\Varid{p}\hskip-1pt\mathit{?}\mathrel{=}\ap{\delta}(\Varid{p}\hskip-1pt\mathit{?})}
%
\just\equiv{ domain of a partial identity is itself }
%
	\ensuremath{\Varid{true}}
\qed
\end{eqnarray*}
\emph{Part ($\implied$)} --- show that \ensuremath{\Varid{f} \comp \Varid{p}\hskip-1pt\mathit{?}\mathrel{=}\Varid{q}\hskip-1pt\mathit{?} \comp \Varid{f}} holds assuming \ensuremath{\Varid{p}\mathrel{=}\Varid{q} \comp \Varid{f}}:
\begin{eqnarray*}
\start
	\ensuremath{\Varid{f} \comp \Varid{p}\hskip-1pt\mathit{?}} = \ensuremath{\Varid{q}\hskip-1pt\mathit{?} \comp \Varid{f}}
%
\just\equiv{ substitution \ensuremath{\Varid{p}\mathbin{:=}\Varid{q} \comp \Varid{f}}; (\ref{eq:150924a}) }
%
	\ensuremath{\Varid{f} \comp \ap{\delta}(\Varid{q}\hskip-1pt\mathit{?} \comp \Varid{f})} = \ensuremath{\Varid{q}\hskip-1pt\mathit{?} \comp \Varid{f}}
%
\just\implied{ \ensuremath{ \subseteq }-antisymmetry, since \ensuremath{{\ap{\delta}(\Varid{q}\hskip-1pt\mathit{?} \comp \Varid{f})}\subseteq{\conv{\Varid{f}} \comp \Varid{q}\hskip-1pt\mathit{?} \comp \Varid{f}}} and \ensuremath{\Varid{f} \comp \conv{\Varid{f}}\; \subseteq \;{id}}}
%
	\ensuremath{{\Varid{q}\hskip-1pt\mathit{?} \comp \Varid{f}}\subseteq{\Varid{f} \comp \ap{\delta}(\Varid{q}\hskip-1pt\mathit{?} \comp \Varid{f})}}
%
\just\equiv{ \ensuremath{\Conid{R}\mathrel{=}\Conid{R} \comp \ap{\delta}\Conid{R}} }
%
	\ensuremath{{\Varid{q}\hskip-1pt\mathit{?} \comp \Varid{f} \comp \ap{\delta}(\Varid{q}\hskip-1pt\mathit{?} \comp \Varid{f})}\subseteq{\Varid{f} \comp \ap{\delta}(\Varid{q}\hskip-1pt\mathit{?} \comp \Varid{f})}}
%
\just\implied{ monotonicity of composition }
%
	\ensuremath{\Varid{q}\hskip-1pt\mathit{?}} \wider\subseteq \ensuremath{{id}}
%
\just\equiv{\ensuremath{\Varid{q}\hskip-1pt\mathit{?}} is a partial identity}
%
	\ensuremath{\Varid{true}}
\qed
\end{eqnarray*}

\paragraph{Proof of property (\ref{eq:150407a-modified})}
By (\ref{eq:160112f}), \ensuremath{\Varid{p}\;{\leq_{\cdot }}\;\Varid{f}} is equivalent to the
existence of some \ensuremath{\Varid{q}} such that \ensuremath{\Varid{p}\mathrel{=}\Varid{q} \comp \Varid{f}} holds, which in turn is equivalent to
\ensuremath{\Varid{f} \comp \Varid{p}\hskip-1pt\mathit{?}} = \ensuremath{\Varid{q}\hskip-1pt\mathit{?} \comp \Varid{f}} by (\ref{eq:150406c}). Then:
\begin{eqnarray*}
\start
	\ensuremath{\frac{\Varid{f}}{\Varid{f}} \comp \Varid{p}\hskip-1pt\mathit{?}}
%
\just={ metaphors (\ref{eq:160117a}) ; (\ref{eq:150406c}) }
%
	\ensuremath{\conv{\Varid{f}} \comp \Varid{q}\hskip-1pt\mathit{?} \comp \Varid{f}}
%
\just={ converses ; partial identities }
%
	\ensuremath{\conv{(\Varid{q}\hskip-1pt\mathit{?} \comp \Varid{f})} \comp \Varid{f}}
%
\just={ again (\ref{eq:150406c}) and (\ref{eq:160117a}) }
%
	\ensuremath{\Varid{p}\hskip-1pt\mathit{?} \comp \frac{\Varid{f}}{\Varid{f}}}
\qed
\end{eqnarray*}
%----------------------------------------------

\paragraph{Proof of property (\ref{eq:150214b})}
Our strategy is indirect equality carried over the universal property of the shrinking operator (\ref{eq:100116d}):
\begin{eqnarray*}
\start
	X \subseteq S \shrunkby (\ensuremath{\Varid{q}\hskip-1pt\mathit{?}} \comp \top)
%
\just\equiv{ (\ref{eq:100116d}) ; (\ref{eq:060124a}) }
%
	X \subseteq S \land X\comp\conv S \subseteq \ensuremath{\Varid{q}\hskip-1pt\mathit{?}} \comp \ensuremath{\frac{\mathop{!}}{\mathop{!}}}
	\eqnnewpage
%
\just\equiv{ shunting (\ref{eq:020617f}) ; converses }
%
	X \subseteq S \land X\comp\conv{(\bang\comp S)} \subseteq \ensuremath{\Varid{q}\hskip-1pt\mathit{?}} \comp \conv\bang
%
\just\equiv{ assume \ensuremath{\Conid{S}} entire, so \ensuremath{\mathop{!} \comp \Conid{S}\mathrel{=}\mathop{!}} }
%
	X \subseteq S \land X\comp\conv\bang \subseteq \ensuremath{\Varid{q}\hskip-1pt\mathit{?}} \comp \conv\bang
%
\just\equiv{ shunting (\ref{eq:020617f}) ;  (\ref{eq:060124a}) }
%
	X \subseteq S \land X \subseteq \ensuremath{\Varid{q}\hskip-1pt\mathit{?} \comp \top }
%
\just\equiv{ (\ref{eq:071215a}) below }
%
%	X \subseteq S \cap |(crflx q)| \comp \top
%
	X \subseteq \ensuremath{\Varid{q}\hskip-1pt\mathit{?}}\comp S
%
\just{::}{ indirect equality}
%
	\ensuremath{{\Conid{S}}\shrunkby{(\Varid{q}\hskip-1pt\mathit{?} \comp \top )}\mathrel{=}\Varid{q}\hskip-1pt\mathit{?} \comp \Conid{S}}
\qed
\end{eqnarray*}
The proof relies on a well-known property of partial identities,
given below together with its converse version:
\begin{eqnarray}
R\comp \ensuremath{\Varid{p}\hskip-1pt\mathit{?}} & = & R \cap \top\comp \ensuremath{\Varid{p}\hskip-1pt\mathit{?}}
\label{eq:081025a}
\\
\ensuremath{\Varid{q}\hskip-1pt\mathit{?}}\comp R & = & R \cap \ensuremath{\Varid{q}\hskip-1pt\mathit{?}}\comp \top
\label{eq:071215a}
\end{eqnarray}
see e.g.\ \cite{Ol08b}.
%-----------------------------------

\paragraph{Proof of Theorem \ref{th:150327a}}
Equality (\ref{eq:160118c}) follows immediately from (\ref{eq:150326b})
by fold-cancellation (\ref{eq:150402b}). Next we show the equivalence
between (\ref{eq:150326b}) and (\ref{eq:150326a}):
\begin{eqnarray*}
\start
	\ensuremath{\Conid{R} \comp \Varid{h}\mathrel{=}\Conid{R} \comp \Varid{h} \comp (\fun F \;\Conid{R})}
%
\just\equiv{\ensuremath{\Conid{R} \comp \Varid{h}\; \subseteq \;\Conid{R} \comp \Varid{h} \comp (\fun F \;\Conid{R})} holds by \ensuremath{{{id}}\subseteq{\fun F \;\Conid{R}}}, since \ensuremath{{{id}}\subseteq{\Conid{R}}}}
%
	\ensuremath{\Conid{R} \comp \Varid{h} \comp (\fun F \;\Conid{R})\; \subseteq \;\Conid{R} \comp \Varid{h}}
%
\just\equiv{ \ensuremath{(\Conid{R} \comp )} is a {closure} operation, see (\ref{eq:060613c-modified})  below}
%
	\ensuremath{\Varid{h} \comp (\fun F \;\Conid{R})\; \subseteq \;\Conid{R} \comp \Varid{h}}
\qed
\end{eqnarray*}
The last step relies on the fact that composition with equivalence relations is a \emph{closure}
operation:
\begin{eqnarray}
	 R \comp S \subseteq R \comp Q & \equiv & S \subseteq R \comp Q
	\label{eq:060613c-modified}
\end{eqnarray}
This fact is used elsewhere \cite{Ol11} to reason about functional dependencies in databases.
Below we rephrase its proof using the power transpose \ensuremath{\Lambda{\Conid{R}}} which maps
objects to their \ensuremath{\Conid{R}}-equivalence classes (\ref{eq:160115a}):
\begin{eqnarray*}
\start
	\ensuremath{\Conid{R} \comp \Conid{S}\; \subseteq \;\Conid{R} \comp \Conid{Q}}
%
\just\equiv{ \ensuremath{\Conid{R}\mathrel{=}\frac{\Lambda{\Conid{R}}}{\Lambda{\Conid{R}}}} (\ref{eq:160115a}) }
%
	\ensuremath{\frac{\Lambda{\Conid{R}}}{\Lambda{\Conid{R}}} \comp \Conid{S}\; \subseteq \;\frac{\Lambda{\Conid{R}}}{\Lambda{\Conid{R}}} \comp \Conid{Q}}
%
\just\equiv{ \ensuremath{\frac{\Lambda{\Conid{R}}}{\Lambda{\Conid{R}}}\mathrel{=}\conv{\Lambda{\Conid{R}}} \comp \Lambda{\Conid{R}}} (\ref{eq:160117a}) ; shunting (\ref{eq:020617e}) }
%
	\ensuremath{\Lambda{\Conid{R}} \comp \conv{\Lambda{\Conid{R}}} \comp \Lambda{\Conid{R}} \comp \Conid{S}\; \subseteq \;\Lambda{\Conid{R}} \comp \Conid{Q}}
%
\just\equiv{\ensuremath{\Varid{f} \comp \conv{\Varid{f}} \comp \Varid{f}\mathrel{=}\Varid{f}} (difunctionality)}
%
	\ensuremath{\Lambda{\Conid{R}} \comp \Conid{S}\; \subseteq \;\Lambda{\Conid{R}} \comp \Conid{Q}}
%
\just\equiv{ shunting (\ref{eq:020617e}) ; \ensuremath{\conv{\Lambda{\Conid{R}}} \comp \Lambda{\Conid{R}}\mathrel{=}\frac{\Lambda{\Conid{R}}}{\Lambda{\Conid{R}}}\mathrel{=}\Conid{R}} (\ref{eq:160115a})}
%
	\ensuremath{\Conid{S}\; \subseteq \;\Conid{R} \comp \Conid{Q}}
\qed
\end{eqnarray*}
Finally, the proof that (\ref{eq:160120c}) is equivalent to (\ref{eq:150326a}) for the special case \ensuremath{\Conid{R}\mathrel{=}\frac{\Varid{f}}{\Varid{f}}}:
\begin{eqnarray*}
\start
	\ensuremath{\Varid{h} \comp (\fun F \;\frac{\Varid{f}}{\Varid{f}})\; \subseteq \;\frac{\Varid{f}}{\Varid{f}} \comp \Varid{h}}	
%	
\just\equiv{ metaphor algebra: (\ref{eq:160117a}) etc }	
%	
	\ensuremath{\fun F \;\frac{\Varid{f}}{\Varid{f}}\; \subseteq \;\frac{\Varid{f} \comp \Varid{h}}{\Varid{f} \comp \Varid{h}}}	
%	
\just\equiv{ injectivity preorder (\ref{eq:160112f}) ; relator \ensuremath{\fun F } (\ref{eq:160118d}) }	
%	
	\ensuremath{\Varid{f} \comp \Varid{h}\leq \fun F \;\Varid{f}}	
\qed
\end{eqnarray*}
%-----------------------------------

\end{document}
